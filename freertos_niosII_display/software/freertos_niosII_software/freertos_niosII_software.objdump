
freertos_niosII_software.elf:     file format elf32-littlenios2
freertos_niosII_software.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x01080000

Program Header:
    LOAD off    0x00001000 vaddr 0x00800000 paddr 0x00800000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00800020 paddr 0x00800020 align 2**12
         filesz 0x00000234 memsz 0x00000234 flags r-x
    LOAD off    0x00002000 vaddr 0x01080000 paddr 0x01080000 align 2**12
         filesz 0x00008cb4 memsz 0x00008cb4 flags r-x
    LOAD off    0x0000acb4 vaddr 0x01088cb4 paddr 0x01089fc8 align 2**12
         filesz 0x00001314 memsz 0x00001314 flags rw-
    LOAD off    0x0000c2dc vaddr 0x0108b2dc paddr 0x0108b2dc align 2**12
         filesz 0x00000000 memsz 0x0003d2c8 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00800000  00800000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000234  00800020  00800020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00008b64  01080000  01080000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000150  01088b64  01088b64  0000ab64  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001314  01088cb4  01089fc8  0000acb4  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0003d372  0108b2dc  0108b2dc  0000c2dc  2**2
                  ALLOC, SMALL_DATA
  6 .sdram        00000000  00800254  00800254  0000bfc8  2**0
                  CONTENTS
  7 .onchip_memory2_0 00000000  010c85a4  010c85a4  0000bfc8  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0000bfc8  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000758  00000000  00000000  0000bff0  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000e0d2  00000000  00000000  0000c748  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00003fc6  00000000  00000000  0001a81a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00005884  00000000  00000000  0001e7e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00002250  00000000  00000000  00024064  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00003687  00000000  00000000  000262b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00001877  00000000  00000000  0002993b  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000030  00000000  00000000  0002b1b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000002e8  00000000  00000000  0002b1e8  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  0002ea5e  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0002ea61  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0002ea6d  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0002ea6e  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0002ea6f  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0002ea73  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0002ea77  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0002ea7b  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000b  00000000  00000000  0002ea86  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000b  00000000  00000000  0002ea91  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 0000000a  00000000  00000000  0002ea9c  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000050  00000000  00000000  0002eaa6  2**0
                  CONTENTS, READONLY
 30 .jdi          00004189  00000000  00000000  0002eaf6  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     0006bd77  00000000  00000000  00032c7f  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00800000 l    d  .entry	00000000 .entry
00800020 l    d  .exceptions	00000000 .exceptions
01080000 l    d  .text	00000000 .text
01088b64 l    d  .rodata	00000000 .rodata
01088cb4 l    d  .rwdata	00000000 .rwdata
0108b2dc l    d  .bss	00000000 .bss
00800254 l    d  .sdram	00000000 .sdram
010c85a4 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../freertos_niosII_software_bsp//obj/HAL/src/crt0.o
01080048 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/Source/portable/GCC/NiosII/port_asm.o
00800020 l       .exceptions	00000000 save_context
0080009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
008000ac l       .exceptions	00000000 hw_irq_test
00800150 l       .exceptions	00000000 soft_exceptions
008000c0 l       .exceptions	00000000 hw_irq_handler
008000d4 l       .exceptions	00000000 restore_context
0080016c l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 event_groups.c
010806dc l     F .text	00000070 prvTestWaitCondition
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
010809dc l     F .text	0000002c prvReadGp
01080b40 l     F .text	0000009c prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_1.c
0108b34c l     O .bss	0003d090 ucHeap
0108b2dc l     O .bss	00000004 xNextFreeByte
0108b2e0 l     O .bss	00000004 pucAlignedHeap.2618
00000000 l    df *ABS*	00000000 queue.c
010810a8 l     F .text	00000084 prvInitialiseNewQueue
0108112c l     F .text	00000060 prvInitialiseMutex
01081f10 l     F .text	0000018c prvCopyDataToQueue
010822c4 l     F .text	00000058 prvIsQueueFull
01082138 l     F .text	000000f4 prvUnlockQueue
0108209c l     F .text	0000009c prvCopyDataFromQueue
0108222c l     F .text	00000050 prvIsQueueEmpty
01081ec0 l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 stream_buffer.c
01083190 l     F .text	00000080 prvInitialiseNewStreamBuffer
0108311c l     F .text	00000074 prvBytesInBuffer
010828c4 l     F .text	000000d4 prvWriteMessageToBuffer
01082f14 l     F .text	000000f4 prvWriteBytesToBuffer
01082c7c l     F .text	000000bc prvReadMessageFromBuffer
01083008 l     F .text	00000114 prvReadBytesFromBuffer
00000000 l    df *ABS*	00000000 tasks.c
010c83dc l     O .bss	00000064 pxReadyTasksLists
010c8440 l     O .bss	00000014 xDelayedTaskList1
010c8454 l     O .bss	00000014 xDelayedTaskList2
0108b2e8 l     O .bss	00000004 pxDelayedTaskList
0108b2ec l     O .bss	00000004 pxOverflowDelayedTaskList
010c8468 l     O .bss	00000014 xPendingReadyList
010c847c l     O .bss	00000014 xTasksWaitingTermination
0108b2f0 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
010c8490 l     O .bss	00000014 xSuspendedTaskList
0108b2f4 l     O .bss	00000004 uxCurrentNumberOfTasks
0108b2f8 l     O .bss	00000004 xTickCount
0108b2fc l     O .bss	00000004 uxTopReadyPriority
0108b300 l     O .bss	00000004 xSchedulerRunning
0108b304 l     O .bss	00000004 xPendedTicks
0108b308 l     O .bss	00000004 xYieldPending
0108b30c l     O .bss	00000004 xNumOfOverflows
0108b310 l     O .bss	00000004 uxTaskNumber
0108b314 l     O .bss	00000004 xNextTaskUnblockTime
0108b318 l     O .bss	00000004 xIdleTaskHandle
0108b31c l     O .bss	00000004 uxSchedulerSuspended
010832f8 l     F .text	000001e4 prvInitialiseNewTask
010834dc l     F .text	000000fc prvAddNewTaskToReadyList
01084768 l     F .text	000000b8 prvInitialiseTaskLists
01084964 l     F .text	00000044 prvDeleteTCB
010849a8 l     F .text	00000054 prvResetNextTaskUnblockTime
01085614 l     F .text	000000e8 prvAddCurrentTaskToDelayedList
01083b50 l     F .text	0000006c prvTaskIsTaskSuspended
0108474c l     F .text	0000001c prvIdleTask
01084820 l     F .text	00000080 prvCheckTasksWaitingTermination
010848a0 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 main.c
010856fc l     F .text	0000004c set_output
01085748 l     F .text	00000064 enable
010857ac l     F .text	00000074 write
01085820 l     F .text	00000094 read_busy
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 fvwrite_small_str.c
00000000 l    df *ABS*	00000000 impure.c
01088cb4 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 vfprintf.c
0108666c l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
01086e24 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_write.c
01086fc0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
01087108 l     F .text	00000038 alt_dev_reg
01088d94 l     O .rwdata	00001060 jtag_uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
010873e4 l     F .text	00000210 altera_avalon_jtag_uart_irq
010875f4 l     F .text	000000a8 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
01087d74 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
01087edc l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
01087f08 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
01088030 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
01088170 l     F .text	00000050 alt_get_errno
010881c0 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
01086f10 g     F .text	0000006c alt_main
01086384 g     F .text	00000080 _puts_r
010c84a4 g     O .bss	00000100 alt_irq
008000c4 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
0108439c g     F .text	00000064 vTaskPlaceOnUnorderedEventList
01080ed0 g     F .text	0000002c xPortGetFreeHeapSize
01080434 g     F .text	0000003c xEventGroupGetBitsFromISR
01089fc8 g       *ABS*	00000000 __flash_rwdata_start
0108380c g     F .text	00000058 uxTaskPriorityGet
01086490 g     F .text	0000001c vsprintf
01082998 g     F .text	00000158 xStreamBufferReceive
01085948 g     F .text	00000094 hd44780_home
010800a0 g     F .text	00000184 xEventGroupSync
0108660c g     F .text	00000060 memmove
01084da0 g     F .text	00000054 vTaskEnterCritical
01081520 g     F .text	000000f4 xQueueGenericSendFromISR
01084038 g     F .text	00000040 pcTaskGetName
0108b320 g     O .bss	00000004 n
0108b324 g     O .bss	00000004 Queue_lcd_rs
01082584 g     F .text	00000088 xStreamBufferSpacesAvailable
01086f7c g     F .text	00000044 alt_putstr
010885ec g     F .text	00000024 altera_nios2_gen2_irq_init
0108247c g     F .text	0000009c xStreamBufferReset
01086564 g     F .text	000000a8 __sfvwrite_small_str
00800000 g     F .entry	0000001c __reset
010811e8 g     F .text	00000090 xQueueGiveMutexRecursive
0108b2e4 g     O .bss	00000004 pxCurrentTCB
00800020 g       *ABS*	00000000 __flash_exceptions_start
0108b330 g     O .bss	00000004 errno
010827d4 g     F .text	000000f0 xStreamBufferSendFromISR
0108b33c g     O .bss	00000004 alt_argv
01091f9c g       *ABS*	00000000 _gp
010838b0 g     F .text	000001a4 vTaskPrioritySet
01084608 g     F .text	0000003c vTaskInternalSetTimeOutState
01080224 g     F .text	000001a8 xEventGroupWaitBits
01085ebc g     F .text	0000016c hd44780_init
01089e1c g     O .rwdata	00000180 alt_fd_list
010859dc g     F .text	000000d4 hd44780_display
01080ae8 g     F .text	00000038 xPortStartScheduler
0108559c g     F .text	00000078 ulTaskNotifyValueClear
01083df8 g     F .text	00000048 vTaskEndScheduler
01088610 g     F .text	00000090 alt_find_dev
0108633c g     F .text	00000028 memcpy
0108434c g     F .text	00000050 vTaskPlaceOnEventList
010844f4 g     F .text	000000c8 vTaskRemoveFromUnorderedEventList
010880f4 g     F .text	0000007c alt_io_redirect
01081d3c g     F .text	0000007c xQueuePeekFromISR
01086404 g     F .text	00000014 puts
01080e88 g     F .text	00000024 vPortFree
01081898 g     F .text	00000210 xQueueSemaphoreTake
010877f4 g     F .text	0000021c altera_avalon_jtag_uart_read
01085d64 g     F .text	0000009c hd44780_print
01080000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
01086d68 g     F .text	00000064 .hidden __udivsi3
01084904 g     F .text	00000060 uxTaskGetStackHighWaterMark
010807e0 g     F .text	0000008c vListInsertEnd
01088868 g     F .text	00000090 alt_icache_flush
0108004c g     F .text	00000054 xEventGroupCreate
01080664 g     F .text	0000003c vEventGroupSetBitsCallback
01083c88 g     F .text	000000e0 xTaskResumeFromISR
010807b4 g     F .text	0000002c vListInitialiseItem
01089fb8 g     O .rwdata	00000004 alt_max_fd
01080bdc g     F .text	0000004c vPortSysTickHandler
010816f0 g     F .text	000001a8 xQueueReceive
01083864 g     F .text	0000004c uxTaskPriorityGetFromISR
01080c28 g     F .text	000001a0 alt_irq_register
01089f9c g     O .rwdata	00000004 _global_impure_ptr
01080470 g     F .text	00000180 xEventGroupSetBits
010c85a4 g       *ABS*	00000000 __bss_end
010884e4 g     F .text	00000108 alt_tick
01086110 g     F .text	00000060 sayInBitween
01080dc8 g     F .text	000000c0 pvPortMalloc
01081e84 g     F .text	0000003c vQueueDelete
01080b20 g     F .text	00000020 vPortEndScheduler
0108074c g     F .text	00000068 vListInitialise
01082d38 g     F .text	00000058 xStreamBufferIsEmpty
01088448 g     F .text	0000009c alt_alarm_stop
0108b334 g     O .bss	00000004 alt_irq_active
0080017c g     F .exceptions	000000d8 alt_irq_handler
01089df4 g     O .rwdata	00000028 alt_dev_null
01083fc4 g     F .text	00000028 xTaskGetTickCount
0108136c g     F .text	000001b4 xQueueGenericSend
0108264c g     F .text	00000188 xStreamBufferSend
01082e90 g     F .text	00000084 xStreamBufferReceiveCompletedFromISR
010858b4 g     F .text	00000094 hd44780_clear
01087e94 g     F .text	00000048 alt_dcache_flush_all
01082af0 g     F .text	000000a8 xStreamBufferNextMessageLengthBytes
01084b64 g     F .text	000000fc xTaskPriorityDisinherit
01089fc8 g       *ABS*	00000000 __ram_rwdata_end
01089fb0 g     O .rwdata	00000008 alt_dev_list
01087010 g     F .text	000000f8 write
01084400 g     F .text	000000f4 xTaskRemoveFromEventList
01088cb4 g       *ABS*	00000000 __ram_rodata_end
010803cc g     F .text	00000068 xEventGroupClearBits
01081aa8 g     F .text	000001b0 xQueuePeek
01086dcc g     F .text	00000058 .hidden __umodsi3
010c85a4 g       *ABS*	00000000 end
01082b98 g     F .text	000000e4 xStreamBufferReceiveFromISR
010835d8 g     F .text	000000e8 vTaskDelete
01087328 g     F .text	000000bc altera_avalon_jtag_uart_init
01084e98 g     F .text	00000038 pvTaskIncrementMutexHeldCount
010d5730 g       *ABS*	00000000 __alt_stack_pointer
01087a10 g     F .text	00000224 altera_avalon_jtag_uart_write
01084644 g     F .text	000000e0 xTaskCheckForTimeOut
01084a24 g     F .text	00000140 xTaskPriorityInherit
010889a0 g     F .text	00000190 __call_exitprocs
01082418 g     F .text	00000064 vStreamBufferDelete
01084ed0 g     F .text	000000b0 ulTaskNotifyTake
01080000 g     F .text	0000004c _start
01085b9c g     F .text	00000130 hd44780_cgram
0108b344 g     O .bss	00000004 _alt_tick_rate
01083e40 g     F .text	0000002c vTaskSuspendAll
01082d90 g     F .text	0000007c xStreamBufferIsFull
01083fec g     F .text	0000002c xTaskGetTickCountFromISR
0108b348 g     O .bss	00000004 _alt_nticks
01087178 g     F .text	0000004c alt_sys_init
01080944 g     F .text	00000098 uxListRemove
0108236c g     F .text	000000ac xStreamBufferGenericCreate
0108769c g     F .text	00000068 altera_avalon_jtag_uart_close
01088cb4 g       *ABS*	00000000 __ram_rwdata_start
01088b64 g       *ABS*	00000000 __ram_rodata_start
01085524 g     F .text	00000078 xTaskNotifyStateClear
01083bbc g     F .text	000000cc vTaskResume
01084274 g     F .text	000000d8 vTaskSwitchContext
010871c4 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
010887b4 g     F .text	000000b4 alt_get_fd
01084f80 g     F .text	000000f4 xTaskNotifyWait
01088970 g     F .text	00000030 memcmp
01087284 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
010c85a4 g       *ABS*	00000000 __alt_stack_base
010872d4 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
01083a54 g     F .text	000000fc vTaskSuspend
01084078 g     F .text	0000004c xTaskCatchUpTicks
01084018 g     F .text	00000020 uxTaskGetNumberOfTasks
010886a0 g     F .text	00000114 alt_find_file
01087f58 g     F .text	000000a4 alt_dev_llist_insert
010866d8 g     F .text	00000524 ___svfprintf_internal_r
01081278 g     F .text	0000009c xQueueTakeMutexRecursive
010805f0 g     F .text	00000074 vEventGroupDelete
01085074 g     F .text	000001ac xTaskGenericNotify
0108b328 g     O .bss	00000004 Queue_lcd_data
010864ac g     F .text	000000b8 __sfvwrite_small_dev
0108b2dc g       *ABS*	00000000 __bss_start
01085ccc g     F .text	00000098 hd44780_put
01086028 g     F .text	000000e8 sayHello
01086364 g     F .text	00000020 memset
0108621c g     F .text	00000120 main
0108b340 g     O .bss	00000004 alt_envp
01087224 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0108086c g     F .text	000000d8 vListInsert
01089fbc g     O .rwdata	00000004 alt_errno
010836c0 g     F .text	000000f0 vTaskDelayUntil
01081c58 g     F .text	000000e4 xQueueReceiveFromISR
010849fc g     F .text	00000028 xTaskGetCurrentTaskHandle
01086c70 g     F .text	00000084 .hidden __divsi3
01081010 g     F .text	00000098 xQueueGenericCreate
01081314 g     F .text	00000058 xQueueCreateCountingSemaphore
01088b64 g       *ABS*	00000000 __flash_rodata_start
01082518 g     F .text	0000006c xStreamBufferSetTriggerLevel
01085220 g     F .text	000001e4 xTaskGenericNotifyFromISR
01087140 g     F .text	00000038 alt_irq_init
010883e4 g     F .text	00000064 alt_release_fd
01083e6c g     F .text	00000158 xTaskResumeAll
01081df8 g     F .text	00000054 uxQueueSpacesAvailable
01083d68 g     F .text	00000090 vTaskStartScheduler
01086c18 g     F .text	00000058 _write_r
01086434 g     F .text	0000005c _vsprintf_r
0108231c g     F .text	00000050 xQueueIsQueueFullFromISR
01089fa0 g     O .rwdata	00000004 _impure_ptr
0108b338 g     O .bss	00000004 alt_argc
01084724 g     F .text	00000028 vTaskMissedYield
01089fa8 g     O .rwdata	00000008 alt_fs_list
01086bfc g     F .text	0000001c __vfprintf_internal_unused
01081db8 g     F .text	00000040 uxQueueMessagesWaiting
010840c4 g     F .text	000001b0 xTaskIncrementTick
00800020 g       *ABS*	00000000 __ram_exceptions_start
01085e00 g     F .text	000000bc hd44780_printf
01080efc g     F .text	00000114 xQueueGenericReset
01089fc8 g       *ABS*	00000000 _edata
010c85a4 g       *ABS*	00000000 _end
00800254 g       *ABS*	00000000 __ram_exceptions_end
01087704 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
01083210 g     F .text	000000e8 xTaskCreate
01080eac g     F .text	00000024 vPortInitialiseBlocks
010888f8 g     F .text	00000020 exit
01086cf4 g     F .text	00000074 .hidden __modsi3
010837b0 g     F .text	0000005c vTaskDelay
010d5730 g       *ABS*	00000000 __alt_data_end
00800000 g       *ABS*	00000000 __alt_mem_sdram
01084c60 g     F .text	00000140 vTaskPriorityDisinheritAfterTimeout
01088b30 g     F .text	00000034 _exit
01087c34 g     F .text	00000140 alt_alarm_start
01086170 g     F .text	000000ac task_lcd_write
01084df4 g     F .text	00000060 vTaskExitCritical
01086418 g     F .text	0000001c strlen
01080a08 g     F .text	000000e0 pxPortInitialiseStack
0108828c g     F .text	00000158 open
01085ab0 g     F .text	000000ec hd44780_position
01087ffc g     F .text	00000034 alt_icache_flush_all
010845bc g     F .text	0000004c vTaskSetTimeOutState
01088918 g     F .text	00000058 fputs
01089fa4 g     O .rwdata	00000004 alt_priority_mask
0108b32c g     O .bss	00000004 Mutex_write_lcd
01081e4c g     F .text	00000038 uxQueueMessagesWaitingFromISR
0108227c g     F .text	00000048 xQueueIsQueueEmptyFromISR
0108260c g     F .text	00000040 xStreamBufferBytesAvailable
01089fc0 g     O .rwdata	00000008 alt_alarm_list
01084e54 g     F .text	00000044 uxTaskResetEventItemValue
0108118c g     F .text	0000005c xQueueCreateMutex
01087dc4 g     F .text	000000d0 close
01085404 g     F .text	00000120 vTaskNotifyGiveFromISR
01086e8c g     F .text	00000084 alt_load
010806a0 g     F .text	0000003c vEventGroupClearBitsCallback
01082e0c g     F .text	00000084 xStreamBufferSendCompletedFromISR
01081614 g     F .text	000000dc xQueueGiveFromISR



Disassembly of section .entry:

00800000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
  800000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
  800004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
  800008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
  80000c:	00bffd16 	blt	zero,r2,800004 <__alt_data_end+0xff72a8d4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  800010:	00404234 	movhi	at,264
    ori r1, r1, %lo(_start)
  800014:	08400014 	ori	at,at,0
    jmp r1
  800018:	0800683a 	jmp	at
  80001c:	00000000 	call	0 <__alt_mem_sdram-0x800000>

Disassembly of section .exceptions:

00800020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"		

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
  800020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -116		# Create space on the stack.
  800024:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
  800028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
  80002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
  800030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
  800034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
  800038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
  80003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
  800040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
  800044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
  800048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
  80004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
  800050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
  800054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
  800058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
  80005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
  800060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
  800064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
  800068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
  80006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
  800070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
  800074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
  800078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
  80007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
  800080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
  800084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
  800088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
  80008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
  800090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
  800094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
  800098:	df001c15 	stw	fp,112(sp)

0080009c <save_sp_to_pxCurrentTCB>:
  80009c:	06004274 	movhi	et,265

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
  8000a0:	c62cb904 	addi	et,et,-19740
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
  8000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
  8000a8:	c6c00015 	stw	sp,0(et)

008000ac <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending		# Load the Pending Interrupts indication
  8000ac:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 		# Load the eStatus (enabled interrupts).
  8000b0:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1			# Are interrupts enabled globally.
  8000b4:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
  8000b8:	10002526 	beq	r2,zero,800150 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
  8000bc:	20002426 	beq	r4,zero,800150 <soft_exceptions>

008000c0 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
  8000c0:	080017c0 	call	80017c <alt_irq_handler>

008000c4 <restore_sp_from_pxCurrentTCB>:
  8000c4:	06004274 	movhi	et,265

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
  8000c8:	c62cb904 	addi	et,et,-19740
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
  8000cc:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
  8000d0:	c6c00017 	ldw	sp,0(et)

008000d4 <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
  8000d4:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
  8000d8:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
  8000dc:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
  8000e0:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
  8000e4:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
  8000e8:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
  8000ec:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
  8000f0:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
  8000f4:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
  8000f8:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
  8000fc:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
  800100:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
  800104:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
  800108:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
  80010c:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
  800110:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
  800114:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
  800118:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
  80011c:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
  800120:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
  800124:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
  800128:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
  80012c:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
  800130:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
  800134:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
  800138:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
  80013c:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
  800140:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
  800144:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
  800148:	dec01d04 	addi	sp,sp,116

    eret					# Return to address ea, loading eStatus into Status.
  80014c:	ef80083a 	eret

00800150 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
  800150:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
  800154:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
  800158:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
  80015c:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
  800160:	c0000226 	beq	et,zero,80016c <call_scheduler>
  	break							# This is an un-implemented instruction or muldiv problem.
  800164:	003da03a 	break	0
  	br		restore_context			# its something else
  800168:	003fda06 	br	8000d4 <__alt_data_end+0xff72a9a4>

0080016c <call_scheduler>:

call_scheduler:
	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
  80016c:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
  800170:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
  800174:	10842740 	call	1084274 <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore. 
  800178:	003fd206 	br	8000c4 <__alt_data_end+0xff72a994>

0080017c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  80017c:	defff904 	addi	sp,sp,-28
  800180:	dfc00615 	stw	ra,24(sp)
  800184:	df000515 	stw	fp,20(sp)
  800188:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  80018c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  800190:	0005313a 	rdctl	r2,ipending
  800194:	e0bffe15 	stw	r2,-8(fp)

  return active;
  800198:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  80019c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  8001a0:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  8001a4:	00800044 	movi	r2,1
  8001a8:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  8001ac:	e0fffb17 	ldw	r3,-20(fp)
  8001b0:	e0bffc17 	ldw	r2,-16(fp)
  8001b4:	1884703a 	and	r2,r3,r2
  8001b8:	10001526 	beq	r2,zero,800210 <alt_irq_handler+0x94>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
  8001bc:	00804374 	movhi	r2,269
  8001c0:	10a12904 	addi	r2,r2,-31580
  8001c4:	e0fffd17 	ldw	r3,-12(fp)
  8001c8:	180690fa 	slli	r3,r3,3
  8001cc:	10c5883a 	add	r2,r2,r3
  8001d0:	10c00017 	ldw	r3,0(r2)
  8001d4:	00804374 	movhi	r2,269
  8001d8:	10a12904 	addi	r2,r2,-31580
  8001dc:	e13ffd17 	ldw	r4,-12(fp)
  8001e0:	200890fa 	slli	r4,r4,3
  8001e4:	1105883a 	add	r2,r2,r4
  8001e8:	10800104 	addi	r2,r2,4
  8001ec:	10800017 	ldw	r2,0(r2)
  8001f0:	e17ffd17 	ldw	r5,-12(fp)
  8001f4:	1009883a 	mov	r4,r2
  8001f8:	183ee83a 	callr	r3
#endif
        break;
  8001fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  800200:	0005313a 	rdctl	r2,ipending
  800204:	e0bfff15 	stw	r2,-4(fp)

  return active;
  800208:	e0bfff17 	ldw	r2,-4(fp)
  80020c:	00000706 	br	80022c <alt_irq_handler+0xb0>
      }
      mask <<= 1;
  800210:	e0bffc17 	ldw	r2,-16(fp)
  800214:	1085883a 	add	r2,r2,r2
  800218:	e0bffc15 	stw	r2,-16(fp)
      i++;
  80021c:	e0bffd17 	ldw	r2,-12(fp)
  800220:	10800044 	addi	r2,r2,1
  800224:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  800228:	003fe006 	br	8001ac <__alt_data_end+0xff72aa7c>

    active = alt_irq_pending ();
  80022c:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  800230:	e0bffb17 	ldw	r2,-20(fp)
  800234:	103fda1e 	bne	r2,zero,8001a0 <__alt_data_end+0xff72aa70>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  800238:	0001883a 	nop
}
  80023c:	0001883a 	nop
  800240:	e037883a 	mov	sp,fp
  800244:	dfc00117 	ldw	ra,4(sp)
  800248:	df000017 	ldw	fp,0(sp)
  80024c:	dec00204 	addi	sp,sp,8
  800250:	f800283a 	ret

Disassembly of section .text:

01080000 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 1080000:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 1080004:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 1080008:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 108000c:	00bffd16 	blt	zero,r2,1080004 <__alt_data_end+0xfffaa8d4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 1080010:	06c04374 	movhi	sp,269
    ori sp, sp, %lo(__alt_stack_pointer)
 1080014:	ded5cc14 	ori	sp,sp,22320
    movhi gp, %hi(_gp)
 1080018:	06804274 	movhi	gp,265
    ori gp, gp, %lo(_gp)
 108001c:	d687e714 	ori	gp,gp,8092
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 1080020:	00804234 	movhi	r2,264
    ori r2, r2, %lo(__bss_start)
 1080024:	10acb714 	ori	r2,r2,45788

    movhi r3, %hi(__bss_end)
 1080028:	00c04334 	movhi	r3,268
    ori r3, r3, %lo(__bss_end)
 108002c:	18e16914 	ori	r3,r3,34212

    beq r2, r3, 1f
 1080030:	10c00326 	beq	r2,r3,1080040 <_start+0x40>

0:
    stw zero, (r2)
 1080034:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 1080038:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 108003c:	10fffd36 	bltu	r2,r3,1080034 <__alt_data_end+0xfffaa904>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 1080040:	1086e8c0 	call	1086e8c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 1080044:	1086f100 	call	1086f10 <alt_main>

01080048 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 1080048:	003fff06 	br	1080048 <__alt_data_end+0xfffaa918>

0108004c <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
 108004c:	defffd04 	addi	sp,sp,-12
 1080050:	dfc00215 	stw	ra,8(sp)
 1080054:	df000115 	stw	fp,4(sp)
 1080058:	df000104 	addi	fp,sp,4
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 108005c:	01000604 	movi	r4,24
 1080060:	1080dc80 	call	1080dc8 <pvPortMalloc>
 1080064:	e0bfff15 	stw	r2,-4(fp)

		if( pxEventBits != NULL )
 1080068:	e0bfff17 	ldw	r2,-4(fp)
 108006c:	10000626 	beq	r2,zero,1080088 <xEventGroupCreate+0x3c>
		{
			pxEventBits->uxEventBits = 0;
 1080070:	e0bfff17 	ldw	r2,-4(fp)
 1080074:	10000015 	stw	zero,0(r2)
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 1080078:	e0bfff17 	ldw	r2,-4(fp)
 108007c:	10800104 	addi	r2,r2,4
 1080080:	1009883a 	mov	r4,r2
 1080084:	108074c0 	call	108074c <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
 1080088:	e0bfff17 	ldw	r2,-4(fp)
	}
 108008c:	e037883a 	mov	sp,fp
 1080090:	dfc00117 	ldw	ra,4(sp)
 1080094:	df000017 	ldw	fp,0(sp)
 1080098:	dec00204 	addi	sp,sp,8
 108009c:	f800283a 	ret

010800a0 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
 10800a0:	defff504 	addi	sp,sp,-44
 10800a4:	dfc00a15 	stw	ra,40(sp)
 10800a8:	df000915 	stw	fp,36(sp)
 10800ac:	df000904 	addi	fp,sp,36
 10800b0:	e13ffc15 	stw	r4,-16(fp)
 10800b4:	e17ffd15 	stw	r5,-12(fp)
 10800b8:	e1bffe15 	stw	r6,-8(fp)
 10800bc:	e1ffff15 	stw	r7,-4(fp)
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
 10800c0:	e0bffc17 	ldw	r2,-16(fp)
 10800c4:	e0bff815 	stw	r2,-32(fp)
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
 10800c8:	e03ff915 	stw	zero,-28(fp)
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
 10800cc:	1083e400 	call	1083e40 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
 10800d0:	e0bff817 	ldw	r2,-32(fp)
 10800d4:	10800017 	ldw	r2,0(r2)
 10800d8:	e0bffa15 	stw	r2,-24(fp)

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 10800dc:	e17ffd17 	ldw	r5,-12(fp)
 10800e0:	e13ffc17 	ldw	r4,-16(fp)
 10800e4:	10804700 	call	1080470 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 10800e8:	e0fffa17 	ldw	r3,-24(fp)
 10800ec:	e0bffd17 	ldw	r2,-12(fp)
 10800f0:	1886b03a 	or	r3,r3,r2
 10800f4:	e0bffe17 	ldw	r2,-8(fp)
 10800f8:	1886703a 	and	r3,r3,r2
 10800fc:	e0bffe17 	ldw	r2,-8(fp)
 1080100:	18800d1e 	bne	r3,r2,1080138 <xEventGroupSync+0x98>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
 1080104:	e0fffa17 	ldw	r3,-24(fp)
 1080108:	e0bffd17 	ldw	r2,-12(fp)
 108010c:	1884b03a 	or	r2,r3,r2
 1080110:	e0bff715 	stw	r2,-36(fp)

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 1080114:	e0bff817 	ldw	r2,-32(fp)
 1080118:	10c00017 	ldw	r3,0(r2)
 108011c:	e0bffe17 	ldw	r2,-8(fp)
 1080120:	0084303a 	nor	r2,zero,r2
 1080124:	1886703a 	and	r3,r3,r2
 1080128:	e0bff817 	ldw	r2,-32(fp)
 108012c:	10c00015 	stw	r3,0(r2)

			xTicksToWait = 0;
 1080130:	e03fff15 	stw	zero,-4(fp)
 1080134:	00001106 	br	108017c <xEventGroupSync+0xdc>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
 1080138:	e0bfff17 	ldw	r2,-4(fp)
 108013c:	10000a26 	beq	r2,zero,1080168 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 1080140:	e0bff817 	ldw	r2,-32(fp)
 1080144:	10c00104 	addi	r3,r2,4
 1080148:	e0bffe17 	ldw	r2,-8(fp)
 108014c:	10814034 	orhi	r2,r2,1280
 1080150:	e1bfff17 	ldw	r6,-4(fp)
 1080154:	100b883a 	mov	r5,r2
 1080158:	1809883a 	mov	r4,r3
 108015c:	108439c0 	call	108439c <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
 1080160:	e03ff715 	stw	zero,-36(fp)
 1080164:	00000506 	br	108017c <xEventGroupSync+0xdc>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
 1080168:	e0bff817 	ldw	r2,-32(fp)
 108016c:	10800017 	ldw	r2,0(r2)
 1080170:	e0bff715 	stw	r2,-36(fp)
				xTimeoutOccurred = pdTRUE;
 1080174:	00800044 	movi	r2,1
 1080178:	e0bff915 	stw	r2,-28(fp)
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
 108017c:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 1080180:	e0bffb15 	stw	r2,-20(fp)

	if( xTicksToWait != ( TickType_t ) 0 )
 1080184:	e0bfff17 	ldw	r2,-4(fp)
 1080188:	10002026 	beq	r2,zero,108020c <xEventGroupSync+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
 108018c:	e0bffb17 	ldw	r2,-20(fp)
 1080190:	1000011e 	bne	r2,zero,1080198 <xEventGroupSync+0xf8>
		{
			portYIELD_WITHIN_API();
 1080194:	003b683a 	trap	0

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
 1080198:	1084e540 	call	1084e54 <uxTaskResetEventItemValue>
 108019c:	e0bff715 	stw	r2,-36(fp)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 10801a0:	e0bff717 	ldw	r2,-36(fp)
 10801a4:	1080802c 	andhi	r2,r2,512
 10801a8:	1000131e 	bne	r2,zero,10801f8 <xEventGroupSync+0x158>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
 10801ac:	1084da00 	call	1084da0 <vTaskEnterCritical>
			{
				uxReturn = pxEventBits->uxEventBits;
 10801b0:	e0bff817 	ldw	r2,-32(fp)
 10801b4:	10800017 	ldw	r2,0(r2)
 10801b8:	e0bff715 	stw	r2,-36(fp)

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 10801bc:	e0fff717 	ldw	r3,-36(fp)
 10801c0:	e0bffe17 	ldw	r2,-8(fp)
 10801c4:	1886703a 	and	r3,r3,r2
 10801c8:	e0bffe17 	ldw	r2,-8(fp)
 10801cc:	1880071e 	bne	r3,r2,10801ec <xEventGroupSync+0x14c>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 10801d0:	e0bff817 	ldw	r2,-32(fp)
 10801d4:	10c00017 	ldw	r3,0(r2)
 10801d8:	e0bffe17 	ldw	r2,-8(fp)
 10801dc:	0084303a 	nor	r2,zero,r2
 10801e0:	1886703a 	and	r3,r3,r2
 10801e4:	e0bff817 	ldw	r2,-32(fp)
 10801e8:	10c00015 	stw	r3,0(r2)
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 10801ec:	1084df40 	call	1084df4 <vTaskExitCritical>

			xTimeoutOccurred = pdTRUE;
 10801f0:	00800044 	movi	r2,1
 10801f4:	e0bff915 	stw	r2,-28(fp)
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 10801f8:	e0fff717 	ldw	r3,-36(fp)
 10801fc:	00804034 	movhi	r2,256
 1080200:	10bfffc4 	addi	r2,r2,-1
 1080204:	1884703a 	and	r2,r3,r2
 1080208:	e0bff715 	stw	r2,-36(fp)
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
 108020c:	e0bff717 	ldw	r2,-36(fp)
}
 1080210:	e037883a 	mov	sp,fp
 1080214:	dfc00117 	ldw	ra,4(sp)
 1080218:	df000017 	ldw	fp,0(sp)
 108021c:	dec00204 	addi	sp,sp,8
 1080220:	f800283a 	ret

01080224 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
 1080224:	defff304 	addi	sp,sp,-52
 1080228:	dfc00c15 	stw	ra,48(sp)
 108022c:	df000b15 	stw	fp,44(sp)
 1080230:	df000b04 	addi	fp,sp,44
 1080234:	e13ffc15 	stw	r4,-16(fp)
 1080238:	e17ffd15 	stw	r5,-12(fp)
 108023c:	e1bffe15 	stw	r6,-8(fp)
 1080240:	e1ffff15 	stw	r7,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
 1080244:	e0bffc17 	ldw	r2,-16(fp)
 1080248:	e0bff715 	stw	r2,-36(fp)
EventBits_t uxReturn, uxControlBits = 0;
 108024c:	e03ff615 	stw	zero,-40(fp)
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
 1080250:	e03ff815 	stw	zero,-32(fp)
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
 1080254:	1083e400 	call	1083e40 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 1080258:	e0bff717 	ldw	r2,-36(fp)
 108025c:	10800017 	ldw	r2,0(r2)
 1080260:	e0bff915 	stw	r2,-28(fp)

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 1080264:	e1bfff17 	ldw	r6,-4(fp)
 1080268:	e17ffd17 	ldw	r5,-12(fp)
 108026c:	e13ff917 	ldw	r4,-28(fp)
 1080270:	10806dc0 	call	10806dc <prvTestWaitCondition>
 1080274:	e0bffa15 	stw	r2,-24(fp)

		if( xWaitConditionMet != pdFALSE )
 1080278:	e0bffa17 	ldw	r2,-24(fp)
 108027c:	10000d26 	beq	r2,zero,10802b4 <xEventGroupWaitBits+0x90>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
 1080280:	e0bff917 	ldw	r2,-28(fp)
 1080284:	e0bff515 	stw	r2,-44(fp)
			xTicksToWait = ( TickType_t ) 0;
 1080288:	e0000215 	stw	zero,8(fp)

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
 108028c:	e0bffe17 	ldw	r2,-8(fp)
 1080290:	10002226 	beq	r2,zero,108031c <xEventGroupWaitBits+0xf8>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 1080294:	e0bff717 	ldw	r2,-36(fp)
 1080298:	10c00017 	ldw	r3,0(r2)
 108029c:	e0bffd17 	ldw	r2,-12(fp)
 10802a0:	0084303a 	nor	r2,zero,r2
 10802a4:	1886703a 	and	r3,r3,r2
 10802a8:	e0bff717 	ldw	r2,-36(fp)
 10802ac:	10c00015 	stw	r3,0(r2)
 10802b0:	00001a06 	br	108031c <xEventGroupWaitBits+0xf8>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
 10802b4:	e0800217 	ldw	r2,8(fp)
 10802b8:	1000051e 	bne	r2,zero,10802d0 <xEventGroupWaitBits+0xac>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
 10802bc:	e0bff917 	ldw	r2,-28(fp)
 10802c0:	e0bff515 	stw	r2,-44(fp)
			xTimeoutOccurred = pdTRUE;
 10802c4:	00800044 	movi	r2,1
 10802c8:	e0bff815 	stw	r2,-32(fp)
 10802cc:	00001306 	br	108031c <xEventGroupWaitBits+0xf8>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
 10802d0:	e0bffe17 	ldw	r2,-8(fp)
 10802d4:	10000326 	beq	r2,zero,10802e4 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 10802d8:	e0bff617 	ldw	r2,-40(fp)
 10802dc:	10804034 	orhi	r2,r2,256
 10802e0:	e0bff615 	stw	r2,-40(fp)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
 10802e4:	e0bfff17 	ldw	r2,-4(fp)
 10802e8:	10000326 	beq	r2,zero,10802f8 <xEventGroupWaitBits+0xd4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
 10802ec:	e0bff617 	ldw	r2,-40(fp)
 10802f0:	10810034 	orhi	r2,r2,1024
 10802f4:	e0bff615 	stw	r2,-40(fp)
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 10802f8:	e0bff717 	ldw	r2,-36(fp)
 10802fc:	11000104 	addi	r4,r2,4
 1080300:	e0fffd17 	ldw	r3,-12(fp)
 1080304:	e0bff617 	ldw	r2,-40(fp)
 1080308:	1884b03a 	or	r2,r3,r2
 108030c:	e1800217 	ldw	r6,8(fp)
 1080310:	100b883a 	mov	r5,r2
 1080314:	108439c0 	call	108439c <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
 1080318:	e03ff515 	stw	zero,-44(fp)

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
 108031c:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 1080320:	e0bffb15 	stw	r2,-20(fp)

	if( xTicksToWait != ( TickType_t ) 0 )
 1080324:	e0800217 	ldw	r2,8(fp)
 1080328:	10002226 	beq	r2,zero,10803b4 <xEventGroupWaitBits+0x190>
	{
		if( xAlreadyYielded == pdFALSE )
 108032c:	e0bffb17 	ldw	r2,-20(fp)
 1080330:	1000011e 	bne	r2,zero,1080338 <xEventGroupWaitBits+0x114>
		{
			portYIELD_WITHIN_API();
 1080334:	003b683a 	trap	0

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
 1080338:	1084e540 	call	1084e54 <uxTaskResetEventItemValue>
 108033c:	e0bff515 	stw	r2,-44(fp)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 1080340:	e0bff517 	ldw	r2,-44(fp)
 1080344:	1080802c 	andhi	r2,r2,512
 1080348:	1000151e 	bne	r2,zero,10803a0 <xEventGroupWaitBits+0x17c>
		{
			taskENTER_CRITICAL();
 108034c:	1084da00 	call	1084da0 <vTaskEnterCritical>
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
 1080350:	e0bff717 	ldw	r2,-36(fp)
 1080354:	10800017 	ldw	r2,0(r2)
 1080358:	e0bff515 	stw	r2,-44(fp)

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 108035c:	e1bfff17 	ldw	r6,-4(fp)
 1080360:	e17ffd17 	ldw	r5,-12(fp)
 1080364:	e13ff517 	ldw	r4,-44(fp)
 1080368:	10806dc0 	call	10806dc <prvTestWaitCondition>
 108036c:	10000926 	beq	r2,zero,1080394 <xEventGroupWaitBits+0x170>
				{
					if( xClearOnExit != pdFALSE )
 1080370:	e0bffe17 	ldw	r2,-8(fp)
 1080374:	10000726 	beq	r2,zero,1080394 <xEventGroupWaitBits+0x170>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 1080378:	e0bff717 	ldw	r2,-36(fp)
 108037c:	10c00017 	ldw	r3,0(r2)
 1080380:	e0bffd17 	ldw	r2,-12(fp)
 1080384:	0084303a 	nor	r2,zero,r2
 1080388:	1886703a 	and	r3,r3,r2
 108038c:	e0bff717 	ldw	r2,-36(fp)
 1080390:	10c00015 	stw	r3,0(r2)
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
 1080394:	00800044 	movi	r2,1
 1080398:	e0bff815 	stw	r2,-32(fp)
			}
			taskEXIT_CRITICAL();
 108039c:	1084df40 	call	1084df4 <vTaskExitCritical>
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 10803a0:	e0fff517 	ldw	r3,-44(fp)
 10803a4:	00804034 	movhi	r2,256
 10803a8:	10bfffc4 	addi	r2,r2,-1
 10803ac:	1884703a 	and	r2,r3,r2
 10803b0:	e0bff515 	stw	r2,-44(fp)
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
 10803b4:	e0bff517 	ldw	r2,-44(fp)
}
 10803b8:	e037883a 	mov	sp,fp
 10803bc:	dfc00117 	ldw	ra,4(sp)
 10803c0:	df000017 	ldw	fp,0(sp)
 10803c4:	dec00204 	addi	sp,sp,8
 10803c8:	f800283a 	ret

010803cc <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
 10803cc:	defffa04 	addi	sp,sp,-24
 10803d0:	dfc00515 	stw	ra,20(sp)
 10803d4:	df000415 	stw	fp,16(sp)
 10803d8:	df000404 	addi	fp,sp,16
 10803dc:	e13ffe15 	stw	r4,-8(fp)
 10803e0:	e17fff15 	stw	r5,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
 10803e4:	e0bffe17 	ldw	r2,-8(fp)
 10803e8:	e0bffc15 	stw	r2,-16(fp)
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
 10803ec:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
 10803f0:	e0bffc17 	ldw	r2,-16(fp)
 10803f4:	10800017 	ldw	r2,0(r2)
 10803f8:	e0bffd15 	stw	r2,-12(fp)

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 10803fc:	e0bffc17 	ldw	r2,-16(fp)
 1080400:	10c00017 	ldw	r3,0(r2)
 1080404:	e0bfff17 	ldw	r2,-4(fp)
 1080408:	0084303a 	nor	r2,zero,r2
 108040c:	1886703a 	and	r3,r3,r2
 1080410:	e0bffc17 	ldw	r2,-16(fp)
 1080414:	10c00015 	stw	r3,0(r2)
	}
	taskEXIT_CRITICAL();
 1080418:	1084df40 	call	1084df4 <vTaskExitCritical>

	return uxReturn;
 108041c:	e0bffd17 	ldw	r2,-12(fp)
}
 1080420:	e037883a 	mov	sp,fp
 1080424:	dfc00117 	ldw	ra,4(sp)
 1080428:	df000017 	ldw	fp,0(sp)
 108042c:	dec00204 	addi	sp,sp,8
 1080430:	f800283a 	ret

01080434 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
 1080434:	defffb04 	addi	sp,sp,-20
 1080438:	df000415 	stw	fp,16(sp)
 108043c:	df000404 	addi	fp,sp,16
 1080440:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
 1080444:	e0bfff17 	ldw	r2,-4(fp)
 1080448:	e0bffc15 	stw	r2,-16(fp)
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 108044c:	e03ffd15 	stw	zero,-12(fp)
	{
		uxReturn = pxEventBits->uxEventBits;
 1080450:	e0bffc17 	ldw	r2,-16(fp)
 1080454:	10800017 	ldw	r2,0(r2)
 1080458:	e0bffe15 	stw	r2,-8(fp)
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
 108045c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
 1080460:	e037883a 	mov	sp,fp
 1080464:	df000017 	ldw	fp,0(sp)
 1080468:	dec00104 	addi	sp,sp,4
 108046c:	f800283a 	ret

01080470 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
 1080470:	defff304 	addi	sp,sp,-52
 1080474:	dfc00c15 	stw	ra,48(sp)
 1080478:	df000b15 	stw	fp,44(sp)
 108047c:	df000b04 	addi	fp,sp,44
 1080480:	e13ffe15 	stw	r4,-8(fp)
 1080484:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 1080488:	e03ff615 	stw	zero,-40(fp)
EventGroup_t *pxEventBits = xEventGroup;
 108048c:	e0bffe17 	ldw	r2,-8(fp)
 1080490:	e0bff815 	stw	r2,-32(fp)
BaseType_t xMatchFound = pdFALSE;
 1080494:	e03ff715 	stw	zero,-36(fp)
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
 1080498:	e0bff817 	ldw	r2,-32(fp)
 108049c:	10800104 	addi	r2,r2,4
 10804a0:	e0bff915 	stw	r2,-28(fp)
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 10804a4:	e0bff917 	ldw	r2,-28(fp)
 10804a8:	10800204 	addi	r2,r2,8
 10804ac:	e0bffa15 	stw	r2,-24(fp)
	vTaskSuspendAll();
 10804b0:	1083e400 	call	1083e40 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
 10804b4:	e0bff917 	ldw	r2,-28(fp)
 10804b8:	10800317 	ldw	r2,12(r2)
 10804bc:	e0bff515 	stw	r2,-44(fp)

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
 10804c0:	e0bff817 	ldw	r2,-32(fp)
 10804c4:	10c00017 	ldw	r3,0(r2)
 10804c8:	e0bfff17 	ldw	r2,-4(fp)
 10804cc:	1886b03a 	or	r3,r3,r2
 10804d0:	e0bff817 	ldw	r2,-32(fp)
 10804d4:	10c00015 	stw	r3,0(r2)

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
 10804d8:	00003306 	br	10805a8 <xEventGroupSetBits+0x138>
		{
			pxNext = listGET_NEXT( pxListItem );
 10804dc:	e0bff517 	ldw	r2,-44(fp)
 10804e0:	10800117 	ldw	r2,4(r2)
 10804e4:	e0bffb15 	stw	r2,-20(fp)
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 10804e8:	e0bff517 	ldw	r2,-44(fp)
 10804ec:	10800017 	ldw	r2,0(r2)
 10804f0:	e0bffc15 	stw	r2,-16(fp)
			xMatchFound = pdFALSE;
 10804f4:	e03ff715 	stw	zero,-36(fp)

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
 10804f8:	e0bffc17 	ldw	r2,-16(fp)
 10804fc:	10bfc02c 	andhi	r2,r2,65280
 1080500:	e0bffd15 	stw	r2,-12(fp)
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 1080504:	e0fffc17 	ldw	r3,-16(fp)
 1080508:	00804034 	movhi	r2,256
 108050c:	10bfffc4 	addi	r2,r2,-1
 1080510:	1884703a 	and	r2,r3,r2
 1080514:	e0bffc15 	stw	r2,-16(fp)

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 1080518:	e0bffd17 	ldw	r2,-12(fp)
 108051c:	1081002c 	andhi	r2,r2,1024
 1080520:	1000081e 	bne	r2,zero,1080544 <xEventGroupSetBits+0xd4>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 1080524:	e0bff817 	ldw	r2,-32(fp)
 1080528:	10c00017 	ldw	r3,0(r2)
 108052c:	e0bffc17 	ldw	r2,-16(fp)
 1080530:	1884703a 	and	r2,r3,r2
 1080534:	10000b26 	beq	r2,zero,1080564 <xEventGroupSetBits+0xf4>
				{
					xMatchFound = pdTRUE;
 1080538:	00800044 	movi	r2,1
 108053c:	e0bff715 	stw	r2,-36(fp)
 1080540:	00000806 	br	1080564 <xEventGroupSetBits+0xf4>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 1080544:	e0bff817 	ldw	r2,-32(fp)
 1080548:	10c00017 	ldw	r3,0(r2)
 108054c:	e0bffc17 	ldw	r2,-16(fp)
 1080550:	1886703a 	and	r3,r3,r2
 1080554:	e0bffc17 	ldw	r2,-16(fp)
 1080558:	1880021e 	bne	r3,r2,1080564 <xEventGroupSetBits+0xf4>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
 108055c:	00800044 	movi	r2,1
 1080560:	e0bff715 	stw	r2,-36(fp)
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
 1080564:	e0bff717 	ldw	r2,-36(fp)
 1080568:	10000d26 	beq	r2,zero,10805a0 <xEventGroupSetBits+0x130>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 108056c:	e0bffd17 	ldw	r2,-12(fp)
 1080570:	1080402c 	andhi	r2,r2,256
 1080574:	10000426 	beq	r2,zero,1080588 <xEventGroupSetBits+0x118>
				{
					uxBitsToClear |= uxBitsWaitedFor;
 1080578:	e0fff617 	ldw	r3,-40(fp)
 108057c:	e0bffc17 	ldw	r2,-16(fp)
 1080580:	1884b03a 	or	r2,r3,r2
 1080584:	e0bff615 	stw	r2,-40(fp)
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 1080588:	e0bff817 	ldw	r2,-32(fp)
 108058c:	10800017 	ldw	r2,0(r2)
 1080590:	10808034 	orhi	r2,r2,512
 1080594:	100b883a 	mov	r5,r2
 1080598:	e13ff517 	ldw	r4,-44(fp)
 108059c:	10844f40 	call	10844f4 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
 10805a0:	e0bffb17 	ldw	r2,-20(fp)
 10805a4:	e0bff515 	stw	r2,-44(fp)

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
 10805a8:	e0fff517 	ldw	r3,-44(fp)
 10805ac:	e0bffa17 	ldw	r2,-24(fp)
 10805b0:	18bfca1e 	bne	r3,r2,10804dc <__alt_data_end+0xfffaadac>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 10805b4:	e0bff817 	ldw	r2,-32(fp)
 10805b8:	10c00017 	ldw	r3,0(r2)
 10805bc:	e0bff617 	ldw	r2,-40(fp)
 10805c0:	0084303a 	nor	r2,zero,r2
 10805c4:	1886703a 	and	r3,r3,r2
 10805c8:	e0bff817 	ldw	r2,-32(fp)
 10805cc:	10c00015 	stw	r3,0(r2)
	}
	( void ) xTaskResumeAll();
 10805d0:	1083e6c0 	call	1083e6c <xTaskResumeAll>

	return pxEventBits->uxEventBits;
 10805d4:	e0bff817 	ldw	r2,-32(fp)
 10805d8:	10800017 	ldw	r2,0(r2)
}
 10805dc:	e037883a 	mov	sp,fp
 10805e0:	dfc00117 	ldw	ra,4(sp)
 10805e4:	df000017 	ldw	fp,0(sp)
 10805e8:	dec00204 	addi	sp,sp,8
 10805ec:	f800283a 	ret

010805f0 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
 10805f0:	defffb04 	addi	sp,sp,-20
 10805f4:	dfc00415 	stw	ra,16(sp)
 10805f8:	df000315 	stw	fp,12(sp)
 10805fc:	df000304 	addi	fp,sp,12
 1080600:	e13fff15 	stw	r4,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
 1080604:	e0bfff17 	ldw	r2,-4(fp)
 1080608:	e0bffd15 	stw	r2,-12(fp)
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 108060c:	e0bffd17 	ldw	r2,-12(fp)
 1080610:	10800104 	addi	r2,r2,4
 1080614:	e0bffe15 	stw	r2,-8(fp)

	vTaskSuspendAll();
 1080618:	1083e400 	call	1083e40 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 108061c:	00000506 	br	1080634 <vEventGroupDelete+0x44>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 1080620:	e0bffe17 	ldw	r2,-8(fp)
 1080624:	10800317 	ldw	r2,12(r2)
 1080628:	01408034 	movhi	r5,512
 108062c:	1009883a 	mov	r4,r2
 1080630:	10844f40 	call	10844f4 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 1080634:	e0bffe17 	ldw	r2,-8(fp)
 1080638:	10800017 	ldw	r2,0(r2)
 108063c:	103ff81e 	bne	r2,zero,1080620 <__alt_data_end+0xfffaaef0>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
 1080640:	e13ffd17 	ldw	r4,-12(fp)
 1080644:	1080e880 	call	1080e88 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
 1080648:	1083e6c0 	call	1083e6c <xTaskResumeAll>
}
 108064c:	0001883a 	nop
 1080650:	e037883a 	mov	sp,fp
 1080654:	dfc00117 	ldw	ra,4(sp)
 1080658:	df000017 	ldw	fp,0(sp)
 108065c:	dec00204 	addi	sp,sp,8
 1080660:	f800283a 	ret

01080664 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
 1080664:	defffc04 	addi	sp,sp,-16
 1080668:	dfc00315 	stw	ra,12(sp)
 108066c:	df000215 	stw	fp,8(sp)
 1080670:	df000204 	addi	fp,sp,8
 1080674:	e13ffe15 	stw	r4,-8(fp)
 1080678:	e17fff15 	stw	r5,-4(fp)
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 108067c:	e17fff17 	ldw	r5,-4(fp)
 1080680:	e13ffe17 	ldw	r4,-8(fp)
 1080684:	10804700 	call	1080470 <xEventGroupSetBits>
}
 1080688:	0001883a 	nop
 108068c:	e037883a 	mov	sp,fp
 1080690:	dfc00117 	ldw	ra,4(sp)
 1080694:	df000017 	ldw	fp,0(sp)
 1080698:	dec00204 	addi	sp,sp,8
 108069c:	f800283a 	ret

010806a0 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
 10806a0:	defffc04 	addi	sp,sp,-16
 10806a4:	dfc00315 	stw	ra,12(sp)
 10806a8:	df000215 	stw	fp,8(sp)
 10806ac:	df000204 	addi	fp,sp,8
 10806b0:	e13ffe15 	stw	r4,-8(fp)
 10806b4:	e17fff15 	stw	r5,-4(fp)
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 10806b8:	e17fff17 	ldw	r5,-4(fp)
 10806bc:	e13ffe17 	ldw	r4,-8(fp)
 10806c0:	10803cc0 	call	10803cc <xEventGroupClearBits>
}
 10806c4:	0001883a 	nop
 10806c8:	e037883a 	mov	sp,fp
 10806cc:	dfc00117 	ldw	ra,4(sp)
 10806d0:	df000017 	ldw	fp,0(sp)
 10806d4:	dec00204 	addi	sp,sp,8
 10806d8:	f800283a 	ret

010806dc <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
 10806dc:	defffb04 	addi	sp,sp,-20
 10806e0:	df000415 	stw	fp,16(sp)
 10806e4:	df000404 	addi	fp,sp,16
 10806e8:	e13ffd15 	stw	r4,-12(fp)
 10806ec:	e17ffe15 	stw	r5,-8(fp)
 10806f0:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xWaitConditionMet = pdFALSE;
 10806f4:	e03ffc15 	stw	zero,-16(fp)

	if( xWaitForAllBits == pdFALSE )
 10806f8:	e0bfff17 	ldw	r2,-4(fp)
 10806fc:	1000071e 	bne	r2,zero,108071c <prvTestWaitCondition+0x40>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 1080700:	e0fffd17 	ldw	r3,-12(fp)
 1080704:	e0bffe17 	ldw	r2,-8(fp)
 1080708:	1884703a 	and	r2,r3,r2
 108070c:	10000a26 	beq	r2,zero,1080738 <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
 1080710:	00800044 	movi	r2,1
 1080714:	e0bffc15 	stw	r2,-16(fp)
 1080718:	00000706 	br	1080738 <prvTestWaitCondition+0x5c>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 108071c:	e0fffd17 	ldw	r3,-12(fp)
 1080720:	e0bffe17 	ldw	r2,-8(fp)
 1080724:	1886703a 	and	r3,r3,r2
 1080728:	e0bffe17 	ldw	r2,-8(fp)
 108072c:	1880021e 	bne	r3,r2,1080738 <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
 1080730:	00800044 	movi	r2,1
 1080734:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
 1080738:	e0bffc17 	ldw	r2,-16(fp)
}
 108073c:	e037883a 	mov	sp,fp
 1080740:	df000017 	ldw	fp,0(sp)
 1080744:	dec00104 	addi	sp,sp,4
 1080748:	f800283a 	ret

0108074c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 108074c:	defffe04 	addi	sp,sp,-8
 1080750:	df000115 	stw	fp,4(sp)
 1080754:	df000104 	addi	fp,sp,4
 1080758:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 108075c:	e0bfff17 	ldw	r2,-4(fp)
 1080760:	10c00204 	addi	r3,r2,8
 1080764:	e0bfff17 	ldw	r2,-4(fp)
 1080768:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 108076c:	e0bfff17 	ldw	r2,-4(fp)
 1080770:	00ffffc4 	movi	r3,-1
 1080774:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1080778:	e0bfff17 	ldw	r2,-4(fp)
 108077c:	10c00204 	addi	r3,r2,8
 1080780:	e0bfff17 	ldw	r2,-4(fp)
 1080784:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1080788:	e0bfff17 	ldw	r2,-4(fp)
 108078c:	10c00204 	addi	r3,r2,8
 1080790:	e0bfff17 	ldw	r2,-4(fp)
 1080794:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 1080798:	e0bfff17 	ldw	r2,-4(fp)
 108079c:	10000015 	stw	zero,0(r2)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 10807a0:	0001883a 	nop
 10807a4:	e037883a 	mov	sp,fp
 10807a8:	df000017 	ldw	fp,0(sp)
 10807ac:	dec00104 	addi	sp,sp,4
 10807b0:	f800283a 	ret

010807b4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 10807b4:	defffe04 	addi	sp,sp,-8
 10807b8:	df000115 	stw	fp,4(sp)
 10807bc:	df000104 	addi	fp,sp,4
 10807c0:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 10807c4:	e0bfff17 	ldw	r2,-4(fp)
 10807c8:	10000415 	stw	zero,16(r2)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 10807cc:	0001883a 	nop
 10807d0:	e037883a 	mov	sp,fp
 10807d4:	df000017 	ldw	fp,0(sp)
 10807d8:	dec00104 	addi	sp,sp,4
 10807dc:	f800283a 	ret

010807e0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 10807e0:	defffc04 	addi	sp,sp,-16
 10807e4:	df000315 	stw	fp,12(sp)
 10807e8:	df000304 	addi	fp,sp,12
 10807ec:	e13ffe15 	stw	r4,-8(fp)
 10807f0:	e17fff15 	stw	r5,-4(fp)
ListItem_t * const pxIndex = pxList->pxIndex;
 10807f4:	e0bffe17 	ldw	r2,-8(fp)
 10807f8:	10800117 	ldw	r2,4(r2)
 10807fc:	e0bffd15 	stw	r2,-12(fp)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 1080800:	e0bfff17 	ldw	r2,-4(fp)
 1080804:	e0fffd17 	ldw	r3,-12(fp)
 1080808:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 108080c:	e0bffd17 	ldw	r2,-12(fp)
 1080810:	10c00217 	ldw	r3,8(r2)
 1080814:	e0bfff17 	ldw	r2,-4(fp)
 1080818:	10c00215 	stw	r3,8(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 108081c:	e0bffd17 	ldw	r2,-12(fp)
 1080820:	10800217 	ldw	r2,8(r2)
 1080824:	e0ffff17 	ldw	r3,-4(fp)
 1080828:	10c00115 	stw	r3,4(r2)
	pxIndex->pxPrevious = pxNewListItem;
 108082c:	e0bffd17 	ldw	r2,-12(fp)
 1080830:	e0ffff17 	ldw	r3,-4(fp)
 1080834:	10c00215 	stw	r3,8(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 1080838:	e0bfff17 	ldw	r2,-4(fp)
 108083c:	e0fffe17 	ldw	r3,-8(fp)
 1080840:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 1080844:	e0bffe17 	ldw	r2,-8(fp)
 1080848:	10800017 	ldw	r2,0(r2)
 108084c:	10c00044 	addi	r3,r2,1
 1080850:	e0bffe17 	ldw	r2,-8(fp)
 1080854:	10c00015 	stw	r3,0(r2)
}
 1080858:	0001883a 	nop
 108085c:	e037883a 	mov	sp,fp
 1080860:	df000017 	ldw	fp,0(sp)
 1080864:	dec00104 	addi	sp,sp,4
 1080868:	f800283a 	ret

0108086c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 108086c:	defffb04 	addi	sp,sp,-20
 1080870:	df000415 	stw	fp,16(sp)
 1080874:	df000404 	addi	fp,sp,16
 1080878:	e13ffe15 	stw	r4,-8(fp)
 108087c:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 1080880:	e0bfff17 	ldw	r2,-4(fp)
 1080884:	10800017 	ldw	r2,0(r2)
 1080888:	e0bffd15 	stw	r2,-12(fp)
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 108088c:	e0bffd17 	ldw	r2,-12(fp)
 1080890:	10bfffd8 	cmpnei	r2,r2,-1
 1080894:	1000041e 	bne	r2,zero,10808a8 <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1080898:	e0bffe17 	ldw	r2,-8(fp)
 108089c:	10800417 	ldw	r2,16(r2)
 10808a0:	e0bffc15 	stw	r2,-16(fp)
 10808a4:	00000c06 	br	10808d8 <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 10808a8:	e0bffe17 	ldw	r2,-8(fp)
 10808ac:	10800204 	addi	r2,r2,8
 10808b0:	e0bffc15 	stw	r2,-16(fp)
 10808b4:	00000306 	br	10808c4 <vListInsert+0x58>
 10808b8:	e0bffc17 	ldw	r2,-16(fp)
 10808bc:	10800117 	ldw	r2,4(r2)
 10808c0:	e0bffc15 	stw	r2,-16(fp)
 10808c4:	e0bffc17 	ldw	r2,-16(fp)
 10808c8:	10800117 	ldw	r2,4(r2)
 10808cc:	10800017 	ldw	r2,0(r2)
 10808d0:	e0fffd17 	ldw	r3,-12(fp)
 10808d4:	18bff82e 	bgeu	r3,r2,10808b8 <__alt_data_end+0xfffab188>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 10808d8:	e0bffc17 	ldw	r2,-16(fp)
 10808dc:	10c00117 	ldw	r3,4(r2)
 10808e0:	e0bfff17 	ldw	r2,-4(fp)
 10808e4:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 10808e8:	e0bfff17 	ldw	r2,-4(fp)
 10808ec:	10800117 	ldw	r2,4(r2)
 10808f0:	e0ffff17 	ldw	r3,-4(fp)
 10808f4:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
 10808f8:	e0bfff17 	ldw	r2,-4(fp)
 10808fc:	e0fffc17 	ldw	r3,-16(fp)
 1080900:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = pxNewListItem;
 1080904:	e0bffc17 	ldw	r2,-16(fp)
 1080908:	e0ffff17 	ldw	r3,-4(fp)
 108090c:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 1080910:	e0bfff17 	ldw	r2,-4(fp)
 1080914:	e0fffe17 	ldw	r3,-8(fp)
 1080918:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 108091c:	e0bffe17 	ldw	r2,-8(fp)
 1080920:	10800017 	ldw	r2,0(r2)
 1080924:	10c00044 	addi	r3,r2,1
 1080928:	e0bffe17 	ldw	r2,-8(fp)
 108092c:	10c00015 	stw	r3,0(r2)
}
 1080930:	0001883a 	nop
 1080934:	e037883a 	mov	sp,fp
 1080938:	df000017 	ldw	fp,0(sp)
 108093c:	dec00104 	addi	sp,sp,4
 1080940:	f800283a 	ret

01080944 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1080944:	defffd04 	addi	sp,sp,-12
 1080948:	df000215 	stw	fp,8(sp)
 108094c:	df000204 	addi	fp,sp,8
 1080950:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 1080954:	e0bfff17 	ldw	r2,-4(fp)
 1080958:	10800417 	ldw	r2,16(r2)
 108095c:	e0bffe15 	stw	r2,-8(fp)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1080960:	e0bfff17 	ldw	r2,-4(fp)
 1080964:	10800117 	ldw	r2,4(r2)
 1080968:	e0ffff17 	ldw	r3,-4(fp)
 108096c:	18c00217 	ldw	r3,8(r3)
 1080970:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 1080974:	e0bfff17 	ldw	r2,-4(fp)
 1080978:	10800217 	ldw	r2,8(r2)
 108097c:	e0ffff17 	ldw	r3,-4(fp)
 1080980:	18c00117 	ldw	r3,4(r3)
 1080984:	10c00115 	stw	r3,4(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 1080988:	e0bffe17 	ldw	r2,-8(fp)
 108098c:	10c00117 	ldw	r3,4(r2)
 1080990:	e0bfff17 	ldw	r2,-4(fp)
 1080994:	1880041e 	bne	r3,r2,10809a8 <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 1080998:	e0bfff17 	ldw	r2,-4(fp)
 108099c:	10c00217 	ldw	r3,8(r2)
 10809a0:	e0bffe17 	ldw	r2,-8(fp)
 10809a4:	10c00115 	stw	r3,4(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 10809a8:	e0bfff17 	ldw	r2,-4(fp)
 10809ac:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
 10809b0:	e0bffe17 	ldw	r2,-8(fp)
 10809b4:	10800017 	ldw	r2,0(r2)
 10809b8:	10ffffc4 	addi	r3,r2,-1
 10809bc:	e0bffe17 	ldw	r2,-8(fp)
 10809c0:	10c00015 	stw	r3,0(r2)

	return pxList->uxNumberOfItems;
 10809c4:	e0bffe17 	ldw	r2,-8(fp)
 10809c8:	10800017 	ldw	r2,0(r2)
}
 10809cc:	e037883a 	mov	sp,fp
 10809d0:	df000017 	ldw	fp,0(sp)
 10809d4:	dec00104 	addi	sp,sp,4
 10809d8:	f800283a 	ret

010809dc <prvReadGp>:
void vPortSysTickHandler( void * context, alt_u32 id );

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
 10809dc:	defffe04 	addi	sp,sp,-8
 10809e0:	df000115 	stw	fp,4(sp)
 10809e4:	df000104 	addi	fp,sp,4
 10809e8:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
 10809ec:	e0bfff17 	ldw	r2,-4(fp)
 10809f0:	16800015 	stw	gp,0(r2)
}
 10809f4:	0001883a 	nop
 10809f8:	e037883a 	mov	sp,fp
 10809fc:	df000017 	ldw	fp,0(sp)
 1080a00:	dec00104 	addi	sp,sp,4
 1080a04:	f800283a 	ret

01080a08 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
 1080a08:	defff904 	addi	sp,sp,-28
 1080a0c:	dfc00615 	stw	ra,24(sp)
 1080a10:	df000515 	stw	fp,20(sp)
 1080a14:	df000504 	addi	fp,sp,20
 1080a18:	e13ffd15 	stw	r4,-12(fp)
 1080a1c:	e17ffe15 	stw	r5,-8(fp)
 1080a20:	e1bfff15 	stw	r6,-4(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
 1080a24:	e0bffd17 	ldw	r2,-12(fp)
 1080a28:	10bfff04 	addi	r2,r2,-4
 1080a2c:	e0bffb15 	stw	r2,-20(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
 1080a30:	e0bffc04 	addi	r2,fp,-16
 1080a34:	1009883a 	mov	r4,r2
 1080a38:	10809dc0 	call	10809dc <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 1080a3c:	e0fffd17 	ldw	r3,-12(fp)
 1080a40:	00b7abb4 	movhi	r2,57006
 1080a44:	10afbbc4 	addi	r2,r2,-16657
 1080a48:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 1080a4c:	e0bffd17 	ldw	r2,-12(fp)
 1080a50:	10bfff04 	addi	r2,r2,-4
 1080a54:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
 1080a58:	e0fffb17 	ldw	r3,-20(fp)
 1080a5c:	e0bffd17 	ldw	r2,-12(fp)
 1080a60:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 1080a64:	e0bffd17 	ldw	r2,-12(fp)
 1080a68:	10bfff04 	addi	r2,r2,-4
 1080a6c:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
 1080a70:	e0fffc17 	ldw	r3,-16(fp)
 1080a74:	e0bffd17 	ldw	r2,-12(fp)
 1080a78:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 1080a7c:	e0bffd17 	ldw	r2,-12(fp)
 1080a80:	10bff704 	addi	r2,r2,-36
 1080a84:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
 1080a88:	e0fffe17 	ldw	r3,-8(fp)
 1080a8c:	e0bffd17 	ldw	r2,-12(fp)
 1080a90:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 1080a94:	e0bffd17 	ldw	r2,-12(fp)
 1080a98:	10bfff04 	addi	r2,r2,-4
 1080a9c:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
 1080aa0:	e0bffd17 	ldw	r2,-12(fp)
 1080aa4:	00c00044 	movi	r3,1
 1080aa8:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
 1080aac:	e0bffd17 	ldw	r2,-12(fp)
 1080ab0:	10bff404 	addi	r2,r2,-48
 1080ab4:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
 1080ab8:	e0ffff17 	ldw	r3,-4(fp)
 1080abc:	e0bffd17 	ldw	r2,-12(fp)
 1080ac0:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 1080ac4:	e0bffd17 	ldw	r2,-12(fp)
 1080ac8:	10bffb04 	addi	r2,r2,-20
 1080acc:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
 1080ad0:	e0bffd17 	ldw	r2,-12(fp)
}
 1080ad4:	e037883a 	mov	sp,fp
 1080ad8:	dfc00117 	ldw	ra,4(sp)
 1080adc:	df000017 	ldw	fp,0(sp)
 1080ae0:	dec00204 	addi	sp,sp,8
 1080ae4:	f800283a 	ret

01080ae8 <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
 1080ae8:	defffe04 	addi	sp,sp,-8
 1080aec:	dfc00115 	stw	ra,4(sp)
 1080af0:	df000015 	stw	fp,0(sp)
 1080af4:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 1080af8:	1080b400 	call	1080b40 <prvSetupTimerInterrupt>
 1080afc:	00802034 	movhi	r2,128
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 1080b00:	10803104 	addi	r2,r2,196
 1080b04:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
 1080b08:	0005883a 	mov	r2,zero
}
 1080b0c:	e037883a 	mov	sp,fp
 1080b10:	dfc00117 	ldw	ra,4(sp)
 1080b14:	df000017 	ldw	fp,0(sp)
 1080b18:	dec00204 	addi	sp,sp,8
 1080b1c:	f800283a 	ret

01080b20 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 1080b20:	deffff04 	addi	sp,sp,-4
 1080b24:	df000015 	stw	fp,0(sp)
 1080b28:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
 1080b2c:	0001883a 	nop
 1080b30:	e037883a 	mov	sp,fp
 1080b34:	df000017 	ldw	fp,0(sp)
 1080b38:	dec00104 	addi	sp,sp,4
 1080b3c:	f800283a 	ret

01080b40 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 1080b40:	defffe04 	addi	sp,sp,-8
 1080b44:	dfc00115 	stw	ra,4(sp)
 1080b48:	df000015 	stw	fp,0(sp)
 1080b4c:	d839883a 	mov	fp,sp
	/* Try to register the interrupt handler. */
	if ( -EINVAL == alt_irq_register( TIMER_0_IRQ, 0x0, vPortSysTickHandler ) )
 1080b50:	01804234 	movhi	r6,264
 1080b54:	3182f704 	addi	r6,r6,3036
 1080b58:	000b883a 	mov	r5,zero
 1080b5c:	01000044 	movi	r4,1
 1080b60:	1080c280 	call	1080c28 <alt_irq_register>
 1080b64:	10bffa98 	cmpnei	r2,r2,-22
 1080b68:	1000021e 	bne	r2,zero,1080b74 <prvSetupTimerInterrupt+0x34>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 1080b6c:	003da03a 	break	0
 1080b70:	00001006 	br	1080bb4 <prvSetupTimerInterrupt+0x74>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
 1080b74:	00c00204 	movi	r3,8
 1080b78:	00804434 	movhi	r2,272
 1080b7c:	10840904 	addi	r2,r2,4132
 1080b80:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( TIMER_0_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
 1080b84:	00f0d414 	movui	r3,50000
 1080b88:	00804434 	movhi	r2,272
 1080b8c:	10840a04 	addi	r2,r2,4136
 1080b90:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( TIMER_0_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
 1080b94:	0007883a 	mov	r3,zero
 1080b98:	00804434 	movhi	r2,272
 1080b9c:	10840b04 	addi	r2,r2,4140
 1080ba0:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );	
 1080ba4:	00c001c4 	movi	r3,7
 1080ba8:	00804434 	movhi	r2,272
 1080bac:	10840904 	addi	r2,r2,4132
 1080bb0:	10c00035 	stwio	r3,0(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( TIMER_0_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 1080bb4:	00ffff84 	movi	r3,-2
 1080bb8:	00804434 	movhi	r2,272
 1080bbc:	10840804 	addi	r2,r2,4128
 1080bc0:	10c00035 	stwio	r3,0(r2)
}
 1080bc4:	0001883a 	nop
 1080bc8:	e037883a 	mov	sp,fp
 1080bcc:	dfc00117 	ldw	ra,4(sp)
 1080bd0:	df000017 	ldw	fp,0(sp)
 1080bd4:	dec00204 	addi	sp,sp,8
 1080bd8:	f800283a 	ret

01080bdc <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context, alt_u32 id )
{
 1080bdc:	defffc04 	addi	sp,sp,-16
 1080be0:	dfc00315 	stw	ra,12(sp)
 1080be4:	df000215 	stw	fp,8(sp)
 1080be8:	df000204 	addi	fp,sp,8
 1080bec:	e13ffe15 	stw	r4,-8(fp)
 1080bf0:	e17fff15 	stw	r5,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
 1080bf4:	10840c40 	call	10840c4 <xTaskIncrementTick>
 1080bf8:	10000126 	beq	r2,zero,1080c00 <vPortSysTickHandler+0x24>
	{
        vTaskSwitchContext();
 1080bfc:	10842740 	call	1084274 <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( TIMER_0_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 1080c00:	00ffff84 	movi	r3,-2
 1080c04:	00804434 	movhi	r2,272
 1080c08:	10840804 	addi	r2,r2,4128
 1080c0c:	10c00035 	stwio	r3,0(r2)
}
 1080c10:	0001883a 	nop
 1080c14:	e037883a 	mov	sp,fp
 1080c18:	dfc00117 	ldw	ra,4(sp)
 1080c1c:	df000017 	ldw	fp,0(sp)
 1080c20:	dec00204 	addi	sp,sp,8
 1080c24:	f800283a 	ret

01080c28 <alt_irq_register>:
 * when it is registered. Interrupts should only be enabled after the FreeRTOS.org
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int alt_irq_register( alt_u32 id, void* context, void (*handler)(void*, alt_u32) )
{
 1080c28:	defff104 	addi	sp,sp,-60
 1080c2c:	df000e15 	stw	fp,56(sp)
 1080c30:	df000e04 	addi	fp,sp,56
 1080c34:	e13ffd15 	stw	r4,-12(fp)
 1080c38:	e17ffe15 	stw	r5,-8(fp)
 1080c3c:	e1bfff15 	stw	r6,-4(fp)
	int rc = -EINVAL;  
 1080c40:	00bffa84 	movi	r2,-22
 1080c44:	e0bff215 	stw	r2,-56(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ)
 1080c48:	e0bffd17 	ldw	r2,-12(fp)
 1080c4c:	10800828 	cmpgeui	r2,r2,32
 1080c50:	1000581e 	bne	r2,zero,1080db4 <alt_irq_register+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1080c54:	0005303a 	rdctl	r2,status
 1080c58:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1080c5c:	e0fff617 	ldw	r3,-40(fp)
 1080c60:	00bfff84 	movi	r2,-2
 1080c64:	1884703a 	and	r2,r3,r2
 1080c68:	1001703a 	wrctl	status,r2
  
  return context;
 1080c6c:	e0bff617 	ldw	r2,-40(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistent
		 * state.
		 */
	
		status = alt_irq_disable_all ();
 1080c70:	e0bff415 	stw	r2,-48(fp)
	
		alt_irq[id].handler = handler;
 1080c74:	00804374 	movhi	r2,269
 1080c78:	10a12904 	addi	r2,r2,-31580
 1080c7c:	e0fffd17 	ldw	r3,-12(fp)
 1080c80:	180690fa 	slli	r3,r3,3
 1080c84:	10c5883a 	add	r2,r2,r3
 1080c88:	e0ffff17 	ldw	r3,-4(fp)
 1080c8c:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = context;
 1080c90:	00804374 	movhi	r2,269
 1080c94:	10a12904 	addi	r2,r2,-31580
 1080c98:	e0fffd17 	ldw	r3,-12(fp)
 1080c9c:	180690fa 	slli	r3,r3,3
 1080ca0:	10c5883a 	add	r2,r2,r3
 1080ca4:	10800104 	addi	r2,r2,4
 1080ca8:	e0fffe17 	ldw	r3,-8(fp)
 1080cac:	10c00015 	stw	r3,0(r2)
	
		rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 1080cb0:	e0bfff17 	ldw	r2,-4(fp)
 1080cb4:	10001f26 	beq	r2,zero,1080d34 <alt_irq_register+0x10c>
 1080cb8:	e0bffd17 	ldw	r2,-12(fp)
 1080cbc:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1080cc0:	0005303a 	rdctl	r2,status
 1080cc4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1080cc8:	e0fff717 	ldw	r3,-36(fp)
 1080ccc:	00bfff84 	movi	r2,-2
 1080cd0:	1884703a 	and	r2,r3,r2
 1080cd4:	1001703a 	wrctl	status,r2
  
  return context;
 1080cd8:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 1080cdc:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
 1080ce0:	00c00044 	movi	r3,1
 1080ce4:	e0bff317 	ldw	r2,-52(fp)
 1080ce8:	1884983a 	sll	r2,r3,r2
 1080cec:	1007883a 	mov	r3,r2
 1080cf0:	00804274 	movhi	r2,265
 1080cf4:	10accd04 	addi	r2,r2,-19660
 1080cf8:	10800017 	ldw	r2,0(r2)
 1080cfc:	1886b03a 	or	r3,r3,r2
 1080d00:	00804274 	movhi	r2,265
 1080d04:	10accd04 	addi	r2,r2,-19660
 1080d08:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1080d0c:	00804274 	movhi	r2,265
 1080d10:	10accd04 	addi	r2,r2,-19660
 1080d14:	10800017 	ldw	r2,0(r2)
 1080d18:	100170fa 	wrctl	ienable,r2
 1080d1c:	e0bff817 	ldw	r2,-32(fp)
 1080d20:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1080d24:	e0bff917 	ldw	r2,-28(fp)
 1080d28:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 1080d2c:	0005883a 	mov	r2,zero
 1080d30:	00001f06 	br	1080db0 <alt_irq_register+0x188>
 1080d34:	e0bffd17 	ldw	r2,-12(fp)
 1080d38:	e0bff515 	stw	r2,-44(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1080d3c:	0005303a 	rdctl	r2,status
 1080d40:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1080d44:	e0fffa17 	ldw	r3,-24(fp)
 1080d48:	00bfff84 	movi	r2,-2
 1080d4c:	1884703a 	and	r2,r3,r2
 1080d50:	1001703a 	wrctl	status,r2
  
  return context;
 1080d54:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 1080d58:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
 1080d5c:	00c00044 	movi	r3,1
 1080d60:	e0bff517 	ldw	r2,-44(fp)
 1080d64:	1884983a 	sll	r2,r3,r2
 1080d68:	0084303a 	nor	r2,zero,r2
 1080d6c:	1007883a 	mov	r3,r2
 1080d70:	00804274 	movhi	r2,265
 1080d74:	10accd04 	addi	r2,r2,-19660
 1080d78:	10800017 	ldw	r2,0(r2)
 1080d7c:	1886703a 	and	r3,r3,r2
 1080d80:	00804274 	movhi	r2,265
 1080d84:	10accd04 	addi	r2,r2,-19660
 1080d88:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1080d8c:	00804274 	movhi	r2,265
 1080d90:	10accd04 	addi	r2,r2,-19660
 1080d94:	10800017 	ldw	r2,0(r2)
 1080d98:	100170fa 	wrctl	ienable,r2
 1080d9c:	e0bffb17 	ldw	r2,-20(fp)
 1080da0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1080da4:	e0bffc17 	ldw	r2,-16(fp)
 1080da8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 1080dac:	0005883a 	mov	r2,zero
 1080db0:	e0bff215 	stw	r2,-56(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
 1080db4:	e0bff217 	ldw	r2,-56(fp)
}
 1080db8:	e037883a 	mov	sp,fp
 1080dbc:	df000017 	ldw	fp,0(sp)
 1080dc0:	dec00104 	addi	sp,sp,4
 1080dc4:	f800283a 	ret

01080dc8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 1080dc8:	defffc04 	addi	sp,sp,-16
 1080dcc:	dfc00315 	stw	ra,12(sp)
 1080dd0:	df000215 	stw	fp,8(sp)
 1080dd4:	df000204 	addi	fp,sp,8
 1080dd8:	e13fff15 	stw	r4,-4(fp)
void *pvReturn = NULL;
 1080ddc:	e03ffe15 	stw	zero,-8(fp)
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 1080de0:	e0bfff17 	ldw	r2,-4(fp)
 1080de4:	108000cc 	andi	r2,r2,3
 1080de8:	10000526 	beq	r2,zero,1080e00 <pvPortMalloc+0x38>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 1080dec:	e0ffff17 	ldw	r3,-4(fp)
 1080df0:	00bfff04 	movi	r2,-4
 1080df4:	1884703a 	and	r2,r3,r2
 1080df8:	10800104 	addi	r2,r2,4
 1080dfc:	e0bfff15 	stw	r2,-4(fp)
		}
	}
	#endif

	vTaskSuspendAll();
 1080e00:	1083e400 	call	1083e40 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 1080e04:	d0a4d117 	ldw	r2,-27836(gp)
 1080e08:	1000051e 	bne	r2,zero,1080e20 <pvPortMalloc+0x58>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 1080e0c:	00804274 	movhi	r2,265
 1080e10:	10acd404 	addi	r2,r2,-19632
 1080e14:	00ffff04 	movi	r3,-4
 1080e18:	10c4703a 	and	r2,r2,r3
 1080e1c:	d0a4d115 	stw	r2,-27836(gp)
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 1080e20:	d0e4d017 	ldw	r3,-27840(gp)
 1080e24:	e0bfff17 	ldw	r2,-4(fp)
 1080e28:	1887883a 	add	r3,r3,r2
 1080e2c:	00800134 	movhi	r2,4
 1080e30:	10b422c4 	addi	r2,r2,-12149
 1080e34:	10c00d36 	bltu	r2,r3,1080e6c <pvPortMalloc+0xa4>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
 1080e38:	d0e4d017 	ldw	r3,-27840(gp)
 1080e3c:	e0bfff17 	ldw	r2,-4(fp)
 1080e40:	1885883a 	add	r2,r3,r2
 1080e44:	d0e4d017 	ldw	r3,-27840(gp)
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 1080e48:	1880082e 	bgeu	r3,r2,1080e6c <pvPortMalloc+0xa4>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 1080e4c:	d0e4d117 	ldw	r3,-27836(gp)
 1080e50:	d0a4d017 	ldw	r2,-27840(gp)
 1080e54:	1885883a 	add	r2,r3,r2
 1080e58:	e0bffe15 	stw	r2,-8(fp)
			xNextFreeByte += xWantedSize;
 1080e5c:	d0e4d017 	ldw	r3,-27840(gp)
 1080e60:	e0bfff17 	ldw	r2,-4(fp)
 1080e64:	1885883a 	add	r2,r3,r2
 1080e68:	d0a4d015 	stw	r2,-27840(gp)
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 1080e6c:	1083e6c0 	call	1083e6c <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
 1080e70:	e0bffe17 	ldw	r2,-8(fp)
}
 1080e74:	e037883a 	mov	sp,fp
 1080e78:	dfc00117 	ldw	ra,4(sp)
 1080e7c:	df000017 	ldw	fp,0(sp)
 1080e80:	dec00204 	addi	sp,sp,8
 1080e84:	f800283a 	ret

01080e88 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 1080e88:	defffe04 	addi	sp,sp,-8
 1080e8c:	df000115 	stw	fp,4(sp)
 1080e90:	df000104 	addi	fp,sp,4
 1080e94:	e13fff15 	stw	r4,-4(fp)
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
 1080e98:	0001883a 	nop
 1080e9c:	e037883a 	mov	sp,fp
 1080ea0:	df000017 	ldw	fp,0(sp)
 1080ea4:	dec00104 	addi	sp,sp,4
 1080ea8:	f800283a 	ret

01080eac <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 1080eac:	deffff04 	addi	sp,sp,-4
 1080eb0:	df000015 	stw	fp,0(sp)
 1080eb4:	d839883a 	mov	fp,sp
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
 1080eb8:	d024d015 	stw	zero,-27840(gp)
}
 1080ebc:	0001883a 	nop
 1080ec0:	e037883a 	mov	sp,fp
 1080ec4:	df000017 	ldw	fp,0(sp)
 1080ec8:	dec00104 	addi	sp,sp,4
 1080ecc:	f800283a 	ret

01080ed0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 1080ed0:	deffff04 	addi	sp,sp,-4
 1080ed4:	df000015 	stw	fp,0(sp)
 1080ed8:	d839883a 	mov	fp,sp
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 1080edc:	d0e4d017 	ldw	r3,-27840(gp)
 1080ee0:	00800134 	movhi	r2,4
 1080ee4:	10b42304 	addi	r2,r2,-12148
 1080ee8:	10c5c83a 	sub	r2,r2,r3
}
 1080eec:	e037883a 	mov	sp,fp
 1080ef0:	df000017 	ldw	fp,0(sp)
 1080ef4:	dec00104 	addi	sp,sp,4
 1080ef8:	f800283a 	ret

01080efc <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 1080efc:	defffb04 	addi	sp,sp,-20
 1080f00:	dfc00415 	stw	ra,16(sp)
 1080f04:	df000315 	stw	fp,12(sp)
 1080f08:	df000304 	addi	fp,sp,12
 1080f0c:	e13ffe15 	stw	r4,-8(fp)
 1080f10:	e17fff15 	stw	r5,-4(fp)
Queue_t * const pxQueue = xQueue;
 1080f14:	e0bffe17 	ldw	r2,-8(fp)
 1080f18:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 1080f1c:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 1080f20:	e0bffd17 	ldw	r2,-12(fp)
 1080f24:	10c00017 	ldw	r3,0(r2)
 1080f28:	e0bffd17 	ldw	r2,-12(fp)
 1080f2c:	11000f17 	ldw	r4,60(r2)
 1080f30:	e0bffd17 	ldw	r2,-12(fp)
 1080f34:	10801017 	ldw	r2,64(r2)
 1080f38:	2085383a 	mul	r2,r4,r2
 1080f3c:	1887883a 	add	r3,r3,r2
 1080f40:	e0bffd17 	ldw	r2,-12(fp)
 1080f44:	10c00215 	stw	r3,8(r2)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 1080f48:	e0bffd17 	ldw	r2,-12(fp)
 1080f4c:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
 1080f50:	e0bffd17 	ldw	r2,-12(fp)
 1080f54:	10c00017 	ldw	r3,0(r2)
 1080f58:	e0bffd17 	ldw	r2,-12(fp)
 1080f5c:	10c00115 	stw	r3,4(r2)
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 1080f60:	e0bffd17 	ldw	r2,-12(fp)
 1080f64:	10c00017 	ldw	r3,0(r2)
 1080f68:	e0bffd17 	ldw	r2,-12(fp)
 1080f6c:	10800f17 	ldw	r2,60(r2)
 1080f70:	113fffc4 	addi	r4,r2,-1
 1080f74:	e0bffd17 	ldw	r2,-12(fp)
 1080f78:	10801017 	ldw	r2,64(r2)
 1080f7c:	2085383a 	mul	r2,r4,r2
 1080f80:	1887883a 	add	r3,r3,r2
 1080f84:	e0bffd17 	ldw	r2,-12(fp)
 1080f88:	10c00315 	stw	r3,12(r2)
		pxQueue->cRxLock = queueUNLOCKED;
 1080f8c:	e0bffd17 	ldw	r2,-12(fp)
 1080f90:	00ffffc4 	movi	r3,-1
 1080f94:	10c01105 	stb	r3,68(r2)
		pxQueue->cTxLock = queueUNLOCKED;
 1080f98:	e0bffd17 	ldw	r2,-12(fp)
 1080f9c:	00ffffc4 	movi	r3,-1
 1080fa0:	10c01145 	stb	r3,69(r2)

		if( xNewQueue == pdFALSE )
 1080fa4:	e0bfff17 	ldw	r2,-4(fp)
 1080fa8:	10000a1e 	bne	r2,zero,1080fd4 <xQueueGenericReset+0xd8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1080fac:	e0bffd17 	ldw	r2,-12(fp)
 1080fb0:	10800417 	ldw	r2,16(r2)
 1080fb4:	10000f26 	beq	r2,zero,1080ff4 <xQueueGenericReset+0xf8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1080fb8:	e0bffd17 	ldw	r2,-12(fp)
 1080fbc:	10800404 	addi	r2,r2,16
 1080fc0:	1009883a 	mov	r4,r2
 1080fc4:	10844000 	call	1084400 <xTaskRemoveFromEventList>
 1080fc8:	10000a26 	beq	r2,zero,1080ff4 <xQueueGenericReset+0xf8>
				{
					queueYIELD_IF_USING_PREEMPTION();
 1080fcc:	003b683a 	trap	0
 1080fd0:	00000806 	br	1080ff4 <xQueueGenericReset+0xf8>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 1080fd4:	e0bffd17 	ldw	r2,-12(fp)
 1080fd8:	10800404 	addi	r2,r2,16
 1080fdc:	1009883a 	mov	r4,r2
 1080fe0:	108074c0 	call	108074c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 1080fe4:	e0bffd17 	ldw	r2,-12(fp)
 1080fe8:	10800904 	addi	r2,r2,36
 1080fec:	1009883a 	mov	r4,r2
 1080ff0:	108074c0 	call	108074c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 1080ff4:	1084df40 	call	1084df4 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 1080ff8:	00800044 	movi	r2,1
}
 1080ffc:	e037883a 	mov	sp,fp
 1081000:	dfc00117 	ldw	ra,4(sp)
 1081004:	df000017 	ldw	fp,0(sp)
 1081008:	dec00204 	addi	sp,sp,8
 108100c:	f800283a 	ret

01081010 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 1081010:	defff704 	addi	sp,sp,-36
 1081014:	dfc00815 	stw	ra,32(sp)
 1081018:	df000715 	stw	fp,28(sp)
 108101c:	df000704 	addi	fp,sp,28
 1081020:	e13ffd15 	stw	r4,-12(fp)
 1081024:	e17ffe15 	stw	r5,-8(fp)
 1081028:	3005883a 	mov	r2,r6
 108102c:	e0bfff05 	stb	r2,-4(fp)
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1081030:	e0fffd17 	ldw	r3,-12(fp)
 1081034:	e0bffe17 	ldw	r2,-8(fp)
 1081038:	1885383a 	mul	r2,r3,r2
 108103c:	e0bffa15 	stw	r2,-24(fp)
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 1081040:	e0bffa17 	ldw	r2,-24(fp)
 1081044:	10801204 	addi	r2,r2,72
 1081048:	1009883a 	mov	r4,r2
 108104c:	1080dc80 	call	1080dc8 <pvPortMalloc>
 1081050:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewQueue != NULL )
 1081054:	e0bffb17 	ldw	r2,-20(fp)
 1081058:	10000d26 	beq	r2,zero,1081090 <xQueueGenericCreate+0x80>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 108105c:	e0bffb17 	ldw	r2,-20(fp)
 1081060:	e0bffc15 	stw	r2,-16(fp)
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 1081064:	e0bffc17 	ldw	r2,-16(fp)
 1081068:	10801204 	addi	r2,r2,72
 108106c:	e0bffc15 	stw	r2,-16(fp)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 1081070:	e0ffff03 	ldbu	r3,-4(fp)
 1081074:	e0bffb17 	ldw	r2,-20(fp)
 1081078:	d8800015 	stw	r2,0(sp)
 108107c:	180f883a 	mov	r7,r3
 1081080:	e1bffc17 	ldw	r6,-16(fp)
 1081084:	e17ffe17 	ldw	r5,-8(fp)
 1081088:	e13ffd17 	ldw	r4,-12(fp)
 108108c:	10810a80 	call	10810a8 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 1081090:	e0bffb17 	ldw	r2,-20(fp)
	}
 1081094:	e037883a 	mov	sp,fp
 1081098:	dfc00117 	ldw	ra,4(sp)
 108109c:	df000017 	ldw	fp,0(sp)
 10810a0:	dec00204 	addi	sp,sp,8
 10810a4:	f800283a 	ret

010810a8 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 10810a8:	defffa04 	addi	sp,sp,-24
 10810ac:	dfc00515 	stw	ra,20(sp)
 10810b0:	df000415 	stw	fp,16(sp)
 10810b4:	df000404 	addi	fp,sp,16
 10810b8:	e13ffc15 	stw	r4,-16(fp)
 10810bc:	e17ffd15 	stw	r5,-12(fp)
 10810c0:	e1bffe15 	stw	r6,-8(fp)
 10810c4:	3805883a 	mov	r2,r7
 10810c8:	e0bfff05 	stb	r2,-4(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 10810cc:	e0bffd17 	ldw	r2,-12(fp)
 10810d0:	1000041e 	bne	r2,zero,10810e4 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 10810d4:	e0800217 	ldw	r2,8(fp)
 10810d8:	e0c00217 	ldw	r3,8(fp)
 10810dc:	10c00015 	stw	r3,0(r2)
 10810e0:	00000306 	br	10810f0 <prvInitialiseNewQueue+0x48>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 10810e4:	e0800217 	ldw	r2,8(fp)
 10810e8:	e0fffe17 	ldw	r3,-8(fp)
 10810ec:	10c00015 	stw	r3,0(r2)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 10810f0:	e0800217 	ldw	r2,8(fp)
 10810f4:	e0fffc17 	ldw	r3,-16(fp)
 10810f8:	10c00f15 	stw	r3,60(r2)
	pxNewQueue->uxItemSize = uxItemSize;
 10810fc:	e0800217 	ldw	r2,8(fp)
 1081100:	e0fffd17 	ldw	r3,-12(fp)
 1081104:	10c01015 	stw	r3,64(r2)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 1081108:	01400044 	movi	r5,1
 108110c:	e1000217 	ldw	r4,8(fp)
 1081110:	1080efc0 	call	1080efc <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 1081114:	0001883a 	nop
 1081118:	e037883a 	mov	sp,fp
 108111c:	dfc00117 	ldw	ra,4(sp)
 1081120:	df000017 	ldw	fp,0(sp)
 1081124:	dec00204 	addi	sp,sp,8
 1081128:	f800283a 	ret

0108112c <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
 108112c:	defffd04 	addi	sp,sp,-12
 1081130:	dfc00215 	stw	ra,8(sp)
 1081134:	df000115 	stw	fp,4(sp)
 1081138:	df000104 	addi	fp,sp,4
 108113c:	e13fff15 	stw	r4,-4(fp)
		if( pxNewQueue != NULL )
 1081140:	e0bfff17 	ldw	r2,-4(fp)
 1081144:	10000b26 	beq	r2,zero,1081174 <prvInitialiseMutex+0x48>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 1081148:	e0bfff17 	ldw	r2,-4(fp)
 108114c:	10000215 	stw	zero,8(r2)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1081150:	e0bfff17 	ldw	r2,-4(fp)
 1081154:	10000015 	stw	zero,0(r2)

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 1081158:	e0bfff17 	ldw	r2,-4(fp)
 108115c:	10000315 	stw	zero,12(r2)

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 1081160:	000f883a 	mov	r7,zero
 1081164:	000d883a 	mov	r6,zero
 1081168:	000b883a 	mov	r5,zero
 108116c:	e13fff17 	ldw	r4,-4(fp)
 1081170:	108136c0 	call	108136c <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
 1081174:	0001883a 	nop
 1081178:	e037883a 	mov	sp,fp
 108117c:	dfc00117 	ldw	ra,4(sp)
 1081180:	df000017 	ldw	fp,0(sp)
 1081184:	dec00204 	addi	sp,sp,8
 1081188:	f800283a 	ret

0108118c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
 108118c:	defffa04 	addi	sp,sp,-24
 1081190:	dfc00515 	stw	ra,20(sp)
 1081194:	df000415 	stw	fp,16(sp)
 1081198:	df000404 	addi	fp,sp,16
 108119c:	2005883a 	mov	r2,r4
 10811a0:	e0bfff05 	stb	r2,-4(fp)
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 10811a4:	00800044 	movi	r2,1
 10811a8:	e0bffc15 	stw	r2,-16(fp)
 10811ac:	e03ffd15 	stw	zero,-12(fp)

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 10811b0:	e0bfff03 	ldbu	r2,-4(fp)
 10811b4:	100d883a 	mov	r6,r2
 10811b8:	e17ffd17 	ldw	r5,-12(fp)
 10811bc:	e13ffc17 	ldw	r4,-16(fp)
 10811c0:	10810100 	call	1081010 <xQueueGenericCreate>
 10811c4:	e0bffe15 	stw	r2,-8(fp)
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 10811c8:	e13ffe17 	ldw	r4,-8(fp)
 10811cc:	108112c0 	call	108112c <prvInitialiseMutex>

		return xNewQueue;
 10811d0:	e0bffe17 	ldw	r2,-8(fp)
	}
 10811d4:	e037883a 	mov	sp,fp
 10811d8:	dfc00117 	ldw	ra,4(sp)
 10811dc:	df000017 	ldw	fp,0(sp)
 10811e0:	dec00204 	addi	sp,sp,8
 10811e4:	f800283a 	ret

010811e8 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
 10811e8:	defffa04 	addi	sp,sp,-24
 10811ec:	dfc00515 	stw	ra,20(sp)
 10811f0:	df000415 	stw	fp,16(sp)
 10811f4:	dc000315 	stw	r16,12(sp)
 10811f8:	df000404 	addi	fp,sp,16
 10811fc:	e13ffe15 	stw	r4,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 1081200:	e0bffe17 	ldw	r2,-8(fp)
 1081204:	e0bffd15 	stw	r2,-12(fp)
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 1081208:	e0bffd17 	ldw	r2,-12(fp)
 108120c:	14000217 	ldw	r16,8(r2)
 1081210:	10849fc0 	call	10849fc <xTaskGetCurrentTaskHandle>
 1081214:	8080101e 	bne	r16,r2,1081258 <xQueueGiveMutexRecursive+0x70>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 1081218:	e0bffd17 	ldw	r2,-12(fp)
 108121c:	10800317 	ldw	r2,12(r2)
 1081220:	10ffffc4 	addi	r3,r2,-1
 1081224:	e0bffd17 	ldw	r2,-12(fp)
 1081228:	10c00315 	stw	r3,12(r2)

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 108122c:	e0bffd17 	ldw	r2,-12(fp)
 1081230:	10800317 	ldw	r2,12(r2)
 1081234:	1000051e 	bne	r2,zero,108124c <xQueueGiveMutexRecursive+0x64>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 1081238:	000f883a 	mov	r7,zero
 108123c:	000d883a 	mov	r6,zero
 1081240:	000b883a 	mov	r5,zero
 1081244:	e13ffd17 	ldw	r4,-12(fp)
 1081248:	108136c0 	call	108136c <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
 108124c:	00800044 	movi	r2,1
 1081250:	e0bffc15 	stw	r2,-16(fp)
 1081254:	00000106 	br	108125c <xQueueGiveMutexRecursive+0x74>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
 1081258:	e03ffc15 	stw	zero,-16(fp)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
 108125c:	e0bffc17 	ldw	r2,-16(fp)
	}
 1081260:	e6ffff04 	addi	sp,fp,-4
 1081264:	dfc00217 	ldw	ra,8(sp)
 1081268:	df000117 	ldw	fp,4(sp)
 108126c:	dc000017 	ldw	r16,0(sp)
 1081270:	dec00304 	addi	sp,sp,12
 1081274:	f800283a 	ret

01081278 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
 1081278:	defff904 	addi	sp,sp,-28
 108127c:	dfc00615 	stw	ra,24(sp)
 1081280:	df000515 	stw	fp,20(sp)
 1081284:	dc000415 	stw	r16,16(sp)
 1081288:	df000504 	addi	fp,sp,20
 108128c:	e13ffd15 	stw	r4,-12(fp)
 1081290:	e17ffe15 	stw	r5,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 1081294:	e0bffd17 	ldw	r2,-12(fp)
 1081298:	e0bffc15 	stw	r2,-16(fp)
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 108129c:	e0bffc17 	ldw	r2,-16(fp)
 10812a0:	14000217 	ldw	r16,8(r2)
 10812a4:	10849fc0 	call	10849fc <xTaskGetCurrentTaskHandle>
 10812a8:	8080081e 	bne	r16,r2,10812cc <xQueueTakeMutexRecursive+0x54>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 10812ac:	e0bffc17 	ldw	r2,-16(fp)
 10812b0:	10800317 	ldw	r2,12(r2)
 10812b4:	10c00044 	addi	r3,r2,1
 10812b8:	e0bffc17 	ldw	r2,-16(fp)
 10812bc:	10c00315 	stw	r3,12(r2)
			xReturn = pdPASS;
 10812c0:	00800044 	movi	r2,1
 10812c4:	e0bffb15 	stw	r2,-20(fp)
 10812c8:	00000b06 	br	10812f8 <xQueueTakeMutexRecursive+0x80>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 10812cc:	e17ffe17 	ldw	r5,-8(fp)
 10812d0:	e13ffc17 	ldw	r4,-16(fp)
 10812d4:	10818980 	call	1081898 <xQueueSemaphoreTake>
 10812d8:	e0bffb15 	stw	r2,-20(fp)

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
 10812dc:	e0bffb17 	ldw	r2,-20(fp)
 10812e0:	10000526 	beq	r2,zero,10812f8 <xQueueTakeMutexRecursive+0x80>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 10812e4:	e0bffc17 	ldw	r2,-16(fp)
 10812e8:	10800317 	ldw	r2,12(r2)
 10812ec:	10c00044 	addi	r3,r2,1
 10812f0:	e0bffc17 	ldw	r2,-16(fp)
 10812f4:	10c00315 	stw	r3,12(r2)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
 10812f8:	e0bffb17 	ldw	r2,-20(fp)
	}
 10812fc:	e6ffff04 	addi	sp,fp,-4
 1081300:	dfc00217 	ldw	ra,8(sp)
 1081304:	df000117 	ldw	fp,4(sp)
 1081308:	dc000017 	ldw	r16,0(sp)
 108130c:	dec00304 	addi	sp,sp,12
 1081310:	f800283a 	ret

01081314 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 1081314:	defffb04 	addi	sp,sp,-20
 1081318:	dfc00415 	stw	ra,16(sp)
 108131c:	df000315 	stw	fp,12(sp)
 1081320:	df000304 	addi	fp,sp,12
 1081324:	e13ffe15 	stw	r4,-8(fp)
 1081328:	e17fff15 	stw	r5,-4(fp)
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 108132c:	01800084 	movi	r6,2
 1081330:	000b883a 	mov	r5,zero
 1081334:	e13ffe17 	ldw	r4,-8(fp)
 1081338:	10810100 	call	1081010 <xQueueGenericCreate>
 108133c:	e0bffd15 	stw	r2,-12(fp)

		if( xHandle != NULL )
 1081340:	e0bffd17 	ldw	r2,-12(fp)
 1081344:	10000326 	beq	r2,zero,1081354 <xQueueCreateCountingSemaphore+0x40>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 1081348:	e0bffd17 	ldw	r2,-12(fp)
 108134c:	e0ffff17 	ldw	r3,-4(fp)
 1081350:	10c00e15 	stw	r3,56(r2)
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 1081354:	e0bffd17 	ldw	r2,-12(fp)
	}
 1081358:	e037883a 	mov	sp,fp
 108135c:	dfc00117 	ldw	ra,4(sp)
 1081360:	df000017 	ldw	fp,0(sp)
 1081364:	dec00204 	addi	sp,sp,8
 1081368:	f800283a 	ret

0108136c <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 108136c:	defff504 	addi	sp,sp,-44
 1081370:	dfc00a15 	stw	ra,40(sp)
 1081374:	df000915 	stw	fp,36(sp)
 1081378:	df000904 	addi	fp,sp,36
 108137c:	e13ffc15 	stw	r4,-16(fp)
 1081380:	e17ffd15 	stw	r5,-12(fp)
 1081384:	e1bffe15 	stw	r6,-8(fp)
 1081388:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 108138c:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 1081390:	e0bffc17 	ldw	r2,-16(fp)
 1081394:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 1081398:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 108139c:	e0bff817 	ldw	r2,-32(fp)
 10813a0:	10c00e17 	ldw	r3,56(r2)
 10813a4:	e0bff817 	ldw	r2,-32(fp)
 10813a8:	10800f17 	ldw	r2,60(r2)
 10813ac:	18800336 	bltu	r3,r2,10813bc <xQueueGenericSend+0x50>
 10813b0:	e0bfff17 	ldw	r2,-4(fp)
 10813b4:	10800098 	cmpnei	r2,r2,2
 10813b8:	1000151e 	bne	r2,zero,1081410 <xQueueGenericSend+0xa4>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 10813bc:	e1bfff17 	ldw	r6,-4(fp)
 10813c0:	e17ffd17 	ldw	r5,-12(fp)
 10813c4:	e13ff817 	ldw	r4,-32(fp)
 10813c8:	1081f100 	call	1081f10 <prvCopyDataToQueue>
 10813cc:	e0bff915 	stw	r2,-28(fp)

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 10813d0:	e0bff817 	ldw	r2,-32(fp)
 10813d4:	10800917 	ldw	r2,36(r2)
 10813d8:	10000726 	beq	r2,zero,10813f8 <xQueueGenericSend+0x8c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 10813dc:	e0bff817 	ldw	r2,-32(fp)
 10813e0:	10800904 	addi	r2,r2,36
 10813e4:	1009883a 	mov	r4,r2
 10813e8:	10844000 	call	1084400 <xTaskRemoveFromEventList>
 10813ec:	10000526 	beq	r2,zero,1081404 <xQueueGenericSend+0x98>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 10813f0:	003b683a 	trap	0
 10813f4:	00000306 	br	1081404 <xQueueGenericSend+0x98>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 10813f8:	e0bff917 	ldw	r2,-28(fp)
 10813fc:	10000126 	beq	r2,zero,1081404 <xQueueGenericSend+0x98>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 1081400:	003b683a 	trap	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 1081404:	1084df40 	call	1084df4 <vTaskExitCritical>
				return pdPASS;
 1081408:	00800044 	movi	r2,1
 108140c:	00003f06 	br	108150c <xQueueGenericSend+0x1a0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 1081410:	e0bffe17 	ldw	r2,-8(fp)
 1081414:	1000031e 	bne	r2,zero,1081424 <xQueueGenericSend+0xb8>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 1081418:	1084df40 	call	1084df4 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 108141c:	0005883a 	mov	r2,zero
 1081420:	00003a06 	br	108150c <xQueueGenericSend+0x1a0>
				}
				else if( xEntryTimeSet == pdFALSE )
 1081424:	e0bff717 	ldw	r2,-36(fp)
 1081428:	1000051e 	bne	r2,zero,1081440 <xQueueGenericSend+0xd4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 108142c:	e0bffa04 	addi	r2,fp,-24
 1081430:	1009883a 	mov	r4,r2
 1081434:	10846080 	call	1084608 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 1081438:	00800044 	movi	r2,1
 108143c:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 1081440:	1084df40 	call	1084df4 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 1081444:	1083e400 	call	1083e40 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 1081448:	1084da00 	call	1084da0 <vTaskEnterCritical>
 108144c:	e0bff817 	ldw	r2,-32(fp)
 1081450:	10801103 	ldbu	r2,68(r2)
 1081454:	10803fcc 	andi	r2,r2,255
 1081458:	1080201c 	xori	r2,r2,128
 108145c:	10bfe004 	addi	r2,r2,-128
 1081460:	10bfffd8 	cmpnei	r2,r2,-1
 1081464:	1000021e 	bne	r2,zero,1081470 <xQueueGenericSend+0x104>
 1081468:	e0bff817 	ldw	r2,-32(fp)
 108146c:	10001105 	stb	zero,68(r2)
 1081470:	e0bff817 	ldw	r2,-32(fp)
 1081474:	10801143 	ldbu	r2,69(r2)
 1081478:	10803fcc 	andi	r2,r2,255
 108147c:	1080201c 	xori	r2,r2,128
 1081480:	10bfe004 	addi	r2,r2,-128
 1081484:	10bfffd8 	cmpnei	r2,r2,-1
 1081488:	1000021e 	bne	r2,zero,1081494 <xQueueGenericSend+0x128>
 108148c:	e0bff817 	ldw	r2,-32(fp)
 1081490:	10001145 	stb	zero,69(r2)
 1081494:	1084df40 	call	1084df4 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1081498:	e0fffe04 	addi	r3,fp,-8
 108149c:	e0bffa04 	addi	r2,fp,-24
 10814a0:	180b883a 	mov	r5,r3
 10814a4:	1009883a 	mov	r4,r2
 10814a8:	10846440 	call	1084644 <xTaskCheckForTimeOut>
 10814ac:	1000131e 	bne	r2,zero,10814fc <xQueueGenericSend+0x190>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 10814b0:	e13ff817 	ldw	r4,-32(fp)
 10814b4:	10822c40 	call	10822c4 <prvIsQueueFull>
 10814b8:	10000c26 	beq	r2,zero,10814ec <xQueueGenericSend+0x180>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 10814bc:	e0bff817 	ldw	r2,-32(fp)
 10814c0:	10800404 	addi	r2,r2,16
 10814c4:	e0fffe17 	ldw	r3,-8(fp)
 10814c8:	180b883a 	mov	r5,r3
 10814cc:	1009883a 	mov	r4,r2
 10814d0:	108434c0 	call	108434c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 10814d4:	e13ff817 	ldw	r4,-32(fp)
 10814d8:	10821380 	call	1082138 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 10814dc:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 10814e0:	103fad1e 	bne	r2,zero,1081398 <__alt_data_end+0xfffabc68>
				{
					portYIELD_WITHIN_API();
 10814e4:	003b683a 	trap	0
 10814e8:	003fab06 	br	1081398 <__alt_data_end+0xfffabc68>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 10814ec:	e13ff817 	ldw	r4,-32(fp)
 10814f0:	10821380 	call	1082138 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 10814f4:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 10814f8:	003fa706 	br	1081398 <__alt_data_end+0xfffabc68>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 10814fc:	e13ff817 	ldw	r4,-32(fp)
 1081500:	10821380 	call	1082138 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 1081504:	1083e6c0 	call	1083e6c <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 1081508:	0005883a 	mov	r2,zero
		}
	} /*lint -restore */
}
 108150c:	e037883a 	mov	sp,fp
 1081510:	dfc00117 	ldw	ra,4(sp)
 1081514:	df000017 	ldw	fp,0(sp)
 1081518:	dec00204 	addi	sp,sp,8
 108151c:	f800283a 	ret

01081520 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 1081520:	defff504 	addi	sp,sp,-44
 1081524:	dfc00a15 	stw	ra,40(sp)
 1081528:	df000915 	stw	fp,36(sp)
 108152c:	df000904 	addi	fp,sp,36
 1081530:	e13ffc15 	stw	r4,-16(fp)
 1081534:	e17ffd15 	stw	r5,-12(fp)
 1081538:	e1bffe15 	stw	r6,-8(fp)
 108153c:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 1081540:	e0bffc17 	ldw	r2,-16(fp)
 1081544:	e0bff815 	stw	r2,-32(fp)
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1081548:	e03ff915 	stw	zero,-28(fp)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 108154c:	e0bff817 	ldw	r2,-32(fp)
 1081550:	10c00e17 	ldw	r3,56(r2)
 1081554:	e0bff817 	ldw	r2,-32(fp)
 1081558:	10800f17 	ldw	r2,60(r2)
 108155c:	18800336 	bltu	r3,r2,108156c <xQueueGenericSendFromISR+0x4c>
 1081560:	e0bfff17 	ldw	r2,-4(fp)
 1081564:	10800098 	cmpnei	r2,r2,2
 1081568:	1000231e 	bne	r2,zero,10815f8 <xQueueGenericSendFromISR+0xd8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 108156c:	e0bff817 	ldw	r2,-32(fp)
 1081570:	10801143 	ldbu	r2,69(r2)
 1081574:	e0bffa05 	stb	r2,-24(fp)
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1081578:	e0bff817 	ldw	r2,-32(fp)
 108157c:	10800e17 	ldw	r2,56(r2)
 1081580:	e0bffb15 	stw	r2,-20(fp)
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1081584:	e1bfff17 	ldw	r6,-4(fp)
 1081588:	e17ffd17 	ldw	r5,-12(fp)
 108158c:	e13ff817 	ldw	r4,-32(fp)
 1081590:	1081f100 	call	1081f10 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 1081594:	e0bffa07 	ldb	r2,-24(fp)
 1081598:	10bfffd8 	cmpnei	r2,r2,-1
 108159c:	10000e1e 	bne	r2,zero,10815d8 <xQueueGenericSendFromISR+0xb8>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 10815a0:	e0bff817 	ldw	r2,-32(fp)
 10815a4:	10800917 	ldw	r2,36(r2)
 10815a8:	10001026 	beq	r2,zero,10815ec <xQueueGenericSendFromISR+0xcc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 10815ac:	e0bff817 	ldw	r2,-32(fp)
 10815b0:	10800904 	addi	r2,r2,36
 10815b4:	1009883a 	mov	r4,r2
 10815b8:	10844000 	call	1084400 <xTaskRemoveFromEventList>
 10815bc:	10000b26 	beq	r2,zero,10815ec <xQueueGenericSendFromISR+0xcc>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 10815c0:	e0bffe17 	ldw	r2,-8(fp)
 10815c4:	10000926 	beq	r2,zero,10815ec <xQueueGenericSendFromISR+0xcc>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 10815c8:	e0bffe17 	ldw	r2,-8(fp)
 10815cc:	00c00044 	movi	r3,1
 10815d0:	10c00015 	stw	r3,0(r2)
 10815d4:	00000506 	br	10815ec <xQueueGenericSendFromISR+0xcc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 10815d8:	e0bffa03 	ldbu	r2,-24(fp)
 10815dc:	10800044 	addi	r2,r2,1
 10815e0:	1007883a 	mov	r3,r2
 10815e4:	e0bff817 	ldw	r2,-32(fp)
 10815e8:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 10815ec:	00800044 	movi	r2,1
 10815f0:	e0bff715 	stw	r2,-36(fp)
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
 10815f4:	00000106 	br	10815fc <xQueueGenericSendFromISR+0xdc>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 10815f8:	e03ff715 	stw	zero,-36(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 10815fc:	e0bff717 	ldw	r2,-36(fp)
}
 1081600:	e037883a 	mov	sp,fp
 1081604:	dfc00117 	ldw	ra,4(sp)
 1081608:	df000017 	ldw	fp,0(sp)
 108160c:	dec00204 	addi	sp,sp,8
 1081610:	f800283a 	ret

01081614 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
 1081614:	defff704 	addi	sp,sp,-36
 1081618:	dfc00815 	stw	ra,32(sp)
 108161c:	df000715 	stw	fp,28(sp)
 1081620:	df000704 	addi	fp,sp,28
 1081624:	e13ffe15 	stw	r4,-8(fp)
 1081628:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 108162c:	e0bffe17 	ldw	r2,-8(fp)
 1081630:	e0bffa15 	stw	r2,-24(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1081634:	e03ffb15 	stw	zero,-20(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1081638:	e0bffa17 	ldw	r2,-24(fp)
 108163c:	10800e17 	ldw	r2,56(r2)
 1081640:	e0bffc15 	stw	r2,-16(fp)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
 1081644:	e0bffa17 	ldw	r2,-24(fp)
 1081648:	10800f17 	ldw	r2,60(r2)
 108164c:	e0fffc17 	ldw	r3,-16(fp)
 1081650:	1880202e 	bgeu	r3,r2,10816d4 <xQueueGiveFromISR+0xc0>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 1081654:	e0bffa17 	ldw	r2,-24(fp)
 1081658:	10801143 	ldbu	r2,69(r2)
 108165c:	e0bffd05 	stb	r2,-12(fp)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1081660:	e0bffc17 	ldw	r2,-16(fp)
 1081664:	10c00044 	addi	r3,r2,1
 1081668:	e0bffa17 	ldw	r2,-24(fp)
 108166c:	10c00e15 	stw	r3,56(r2)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 1081670:	e0bffd07 	ldb	r2,-12(fp)
 1081674:	10bfffd8 	cmpnei	r2,r2,-1
 1081678:	10000e1e 	bne	r2,zero,10816b4 <xQueueGiveFromISR+0xa0>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 108167c:	e0bffa17 	ldw	r2,-24(fp)
 1081680:	10800917 	ldw	r2,36(r2)
 1081684:	10001026 	beq	r2,zero,10816c8 <xQueueGiveFromISR+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1081688:	e0bffa17 	ldw	r2,-24(fp)
 108168c:	10800904 	addi	r2,r2,36
 1081690:	1009883a 	mov	r4,r2
 1081694:	10844000 	call	1084400 <xTaskRemoveFromEventList>
 1081698:	10000b26 	beq	r2,zero,10816c8 <xQueueGiveFromISR+0xb4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 108169c:	e0bfff17 	ldw	r2,-4(fp)
 10816a0:	10000926 	beq	r2,zero,10816c8 <xQueueGiveFromISR+0xb4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 10816a4:	e0bfff17 	ldw	r2,-4(fp)
 10816a8:	00c00044 	movi	r3,1
 10816ac:	10c00015 	stw	r3,0(r2)
 10816b0:	00000506 	br	10816c8 <xQueueGiveFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 10816b4:	e0bffd03 	ldbu	r2,-12(fp)
 10816b8:	10800044 	addi	r2,r2,1
 10816bc:	1007883a 	mov	r3,r2
 10816c0:	e0bffa17 	ldw	r2,-24(fp)
 10816c4:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 10816c8:	00800044 	movi	r2,1
 10816cc:	e0bff915 	stw	r2,-28(fp)
 10816d0:	00000106 	br	10816d8 <xQueueGiveFromISR+0xc4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 10816d4:	e03ff915 	stw	zero,-28(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 10816d8:	e0bff917 	ldw	r2,-28(fp)
}
 10816dc:	e037883a 	mov	sp,fp
 10816e0:	dfc00117 	ldw	ra,4(sp)
 10816e4:	df000017 	ldw	fp,0(sp)
 10816e8:	dec00204 	addi	sp,sp,8
 10816ec:	f800283a 	ret

010816f0 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 10816f0:	defff604 	addi	sp,sp,-40
 10816f4:	dfc00915 	stw	ra,36(sp)
 10816f8:	df000815 	stw	fp,32(sp)
 10816fc:	df000804 	addi	fp,sp,32
 1081700:	e13ffd15 	stw	r4,-12(fp)
 1081704:	e17ffe15 	stw	r5,-8(fp)
 1081708:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 108170c:	e03ff815 	stw	zero,-32(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 1081710:	e0bffd17 	ldw	r2,-12(fp)
 1081714:	e0bff915 	stw	r2,-28(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 1081718:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 108171c:	e0bff917 	ldw	r2,-28(fp)
 1081720:	10800e17 	ldw	r2,56(r2)
 1081724:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1081728:	e0bffa17 	ldw	r2,-24(fp)
 108172c:	10001326 	beq	r2,zero,108177c <xQueueReceive+0x8c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1081730:	e17ffe17 	ldw	r5,-8(fp)
 1081734:	e13ff917 	ldw	r4,-28(fp)
 1081738:	108209c0 	call	108209c <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 108173c:	e0bffa17 	ldw	r2,-24(fp)
 1081740:	10ffffc4 	addi	r3,r2,-1
 1081744:	e0bff917 	ldw	r2,-28(fp)
 1081748:	10c00e15 	stw	r3,56(r2)

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 108174c:	e0bff917 	ldw	r2,-28(fp)
 1081750:	10800417 	ldw	r2,16(r2)
 1081754:	10000626 	beq	r2,zero,1081770 <xQueueReceive+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1081758:	e0bff917 	ldw	r2,-28(fp)
 108175c:	10800404 	addi	r2,r2,16
 1081760:	1009883a 	mov	r4,r2
 1081764:	10844000 	call	1084400 <xTaskRemoveFromEventList>
 1081768:	10000126 	beq	r2,zero,1081770 <xQueueReceive+0x80>
					{
						queueYIELD_IF_USING_PREEMPTION();
 108176c:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 1081770:	1084df40 	call	1084df4 <vTaskExitCritical>
				return pdPASS;
 1081774:	00800044 	movi	r2,1
 1081778:	00004206 	br	1081884 <xQueueReceive+0x194>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 108177c:	e0bfff17 	ldw	r2,-4(fp)
 1081780:	1000031e 	bne	r2,zero,1081790 <xQueueReceive+0xa0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 1081784:	1084df40 	call	1084df4 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 1081788:	0005883a 	mov	r2,zero
 108178c:	00003d06 	br	1081884 <xQueueReceive+0x194>
				}
				else if( xEntryTimeSet == pdFALSE )
 1081790:	e0bff817 	ldw	r2,-32(fp)
 1081794:	1000051e 	bne	r2,zero,10817ac <xQueueReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 1081798:	e0bffb04 	addi	r2,fp,-20
 108179c:	1009883a 	mov	r4,r2
 10817a0:	10846080 	call	1084608 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 10817a4:	00800044 	movi	r2,1
 10817a8:	e0bff815 	stw	r2,-32(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 10817ac:	1084df40 	call	1084df4 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 10817b0:	1083e400 	call	1083e40 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 10817b4:	1084da00 	call	1084da0 <vTaskEnterCritical>
 10817b8:	e0bff917 	ldw	r2,-28(fp)
 10817bc:	10801103 	ldbu	r2,68(r2)
 10817c0:	10803fcc 	andi	r2,r2,255
 10817c4:	1080201c 	xori	r2,r2,128
 10817c8:	10bfe004 	addi	r2,r2,-128
 10817cc:	10bfffd8 	cmpnei	r2,r2,-1
 10817d0:	1000021e 	bne	r2,zero,10817dc <xQueueReceive+0xec>
 10817d4:	e0bff917 	ldw	r2,-28(fp)
 10817d8:	10001105 	stb	zero,68(r2)
 10817dc:	e0bff917 	ldw	r2,-28(fp)
 10817e0:	10801143 	ldbu	r2,69(r2)
 10817e4:	10803fcc 	andi	r2,r2,255
 10817e8:	1080201c 	xori	r2,r2,128
 10817ec:	10bfe004 	addi	r2,r2,-128
 10817f0:	10bfffd8 	cmpnei	r2,r2,-1
 10817f4:	1000021e 	bne	r2,zero,1081800 <xQueueReceive+0x110>
 10817f8:	e0bff917 	ldw	r2,-28(fp)
 10817fc:	10001145 	stb	zero,69(r2)
 1081800:	1084df40 	call	1084df4 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1081804:	e0ffff04 	addi	r3,fp,-4
 1081808:	e0bffb04 	addi	r2,fp,-20
 108180c:	180b883a 	mov	r5,r3
 1081810:	1009883a 	mov	r4,r2
 1081814:	10846440 	call	1084644 <xTaskCheckForTimeOut>
 1081818:	1000131e 	bne	r2,zero,1081868 <xQueueReceive+0x178>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 108181c:	e13ff917 	ldw	r4,-28(fp)
 1081820:	108222c0 	call	108222c <prvIsQueueEmpty>
 1081824:	10000c26 	beq	r2,zero,1081858 <xQueueReceive+0x168>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1081828:	e0bff917 	ldw	r2,-28(fp)
 108182c:	10800904 	addi	r2,r2,36
 1081830:	e0ffff17 	ldw	r3,-4(fp)
 1081834:	180b883a 	mov	r5,r3
 1081838:	1009883a 	mov	r4,r2
 108183c:	108434c0 	call	108434c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 1081840:	e13ff917 	ldw	r4,-28(fp)
 1081844:	10821380 	call	1082138 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 1081848:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 108184c:	103fb21e 	bne	r2,zero,1081718 <__alt_data_end+0xfffabfe8>
				{
					portYIELD_WITHIN_API();
 1081850:	003b683a 	trap	0
 1081854:	003fb006 	br	1081718 <__alt_data_end+0xfffabfe8>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
 1081858:	e13ff917 	ldw	r4,-28(fp)
 108185c:	10821380 	call	1082138 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 1081860:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 1081864:	003fac06 	br	1081718 <__alt_data_end+0xfffabfe8>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
 1081868:	e13ff917 	ldw	r4,-28(fp)
 108186c:	10821380 	call	1082138 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 1081870:	1083e6c0 	call	1083e6c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1081874:	e13ff917 	ldw	r4,-28(fp)
 1081878:	108222c0 	call	108222c <prvIsQueueEmpty>
 108187c:	103fa626 	beq	r2,zero,1081718 <__alt_data_end+0xfffabfe8>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 1081880:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 1081884:	e037883a 	mov	sp,fp
 1081888:	dfc00117 	ldw	ra,4(sp)
 108188c:	df000017 	ldw	fp,0(sp)
 1081890:	dec00204 	addi	sp,sp,8
 1081894:	f800283a 	ret

01081898 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
 1081898:	defff504 	addi	sp,sp,-44
 108189c:	dfc00a15 	stw	ra,40(sp)
 10818a0:	df000915 	stw	fp,36(sp)
 10818a4:	df000904 	addi	fp,sp,36
 10818a8:	e13ffe15 	stw	r4,-8(fp)
 10818ac:	e17fff15 	stw	r5,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 10818b0:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 10818b4:	e0bffe17 	ldw	r2,-8(fp)
 10818b8:	e0bff915 	stw	r2,-28(fp)

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
 10818bc:	e03ff815 	stw	zero,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 10818c0:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 10818c4:	e0bff917 	ldw	r2,-28(fp)
 10818c8:	10800e17 	ldw	r2,56(r2)
 10818cc:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 10818d0:	e0bffa17 	ldw	r2,-24(fp)
 10818d4:	10001726 	beq	r2,zero,1081934 <xQueueSemaphoreTake+0x9c>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 10818d8:	e0bffa17 	ldw	r2,-24(fp)
 10818dc:	10ffffc4 	addi	r3,r2,-1
 10818e0:	e0bff917 	ldw	r2,-28(fp)
 10818e4:	10c00e15 	stw	r3,56(r2)

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 10818e8:	e0bff917 	ldw	r2,-28(fp)
 10818ec:	10800017 	ldw	r2,0(r2)
 10818f0:	1000041e 	bne	r2,zero,1081904 <xQueueSemaphoreTake+0x6c>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 10818f4:	1084e980 	call	1084e98 <pvTaskIncrementMutexHeldCount>
 10818f8:	1007883a 	mov	r3,r2
 10818fc:	e0bff917 	ldw	r2,-28(fp)
 1081900:	10c00215 	stw	r3,8(r2)
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1081904:	e0bff917 	ldw	r2,-28(fp)
 1081908:	10800417 	ldw	r2,16(r2)
 108190c:	10000626 	beq	r2,zero,1081928 <xQueueSemaphoreTake+0x90>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1081910:	e0bff917 	ldw	r2,-28(fp)
 1081914:	10800404 	addi	r2,r2,16
 1081918:	1009883a 	mov	r4,r2
 108191c:	10844000 	call	1084400 <xTaskRemoveFromEventList>
 1081920:	10000126 	beq	r2,zero,1081928 <xQueueSemaphoreTake+0x90>
					{
						queueYIELD_IF_USING_PREEMPTION();
 1081924:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 1081928:	1084df40 	call	1084df4 <vTaskExitCritical>
				return pdPASS;
 108192c:	00800044 	movi	r2,1
 1081930:	00005806 	br	1081a94 <xQueueSemaphoreTake+0x1fc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 1081934:	e0bfff17 	ldw	r2,-4(fp)
 1081938:	1000031e 	bne	r2,zero,1081948 <xQueueSemaphoreTake+0xb0>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
 108193c:	1084df40 	call	1084df4 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 1081940:	0005883a 	mov	r2,zero
 1081944:	00005306 	br	1081a94 <xQueueSemaphoreTake+0x1fc>
				}
				else if( xEntryTimeSet == pdFALSE )
 1081948:	e0bff717 	ldw	r2,-36(fp)
 108194c:	1000051e 	bne	r2,zero,1081964 <xQueueSemaphoreTake+0xcc>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 1081950:	e0bffc04 	addi	r2,fp,-16
 1081954:	1009883a 	mov	r4,r2
 1081958:	10846080 	call	1084608 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 108195c:	00800044 	movi	r2,1
 1081960:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 1081964:	1084df40 	call	1084df4 <vTaskExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
 1081968:	1083e400 	call	1083e40 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 108196c:	1084da00 	call	1084da0 <vTaskEnterCritical>
 1081970:	e0bff917 	ldw	r2,-28(fp)
 1081974:	10801103 	ldbu	r2,68(r2)
 1081978:	10803fcc 	andi	r2,r2,255
 108197c:	1080201c 	xori	r2,r2,128
 1081980:	10bfe004 	addi	r2,r2,-128
 1081984:	10bfffd8 	cmpnei	r2,r2,-1
 1081988:	1000021e 	bne	r2,zero,1081994 <xQueueSemaphoreTake+0xfc>
 108198c:	e0bff917 	ldw	r2,-28(fp)
 1081990:	10001105 	stb	zero,68(r2)
 1081994:	e0bff917 	ldw	r2,-28(fp)
 1081998:	10801143 	ldbu	r2,69(r2)
 108199c:	10803fcc 	andi	r2,r2,255
 10819a0:	1080201c 	xori	r2,r2,128
 10819a4:	10bfe004 	addi	r2,r2,-128
 10819a8:	10bfffd8 	cmpnei	r2,r2,-1
 10819ac:	1000021e 	bne	r2,zero,10819b8 <xQueueSemaphoreTake+0x120>
 10819b0:	e0bff917 	ldw	r2,-28(fp)
 10819b4:	10001145 	stb	zero,69(r2)
 10819b8:	1084df40 	call	1084df4 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 10819bc:	e0ffff04 	addi	r3,fp,-4
 10819c0:	e0bffc04 	addi	r2,fp,-16
 10819c4:	180b883a 	mov	r5,r3
 10819c8:	1009883a 	mov	r4,r2
 10819cc:	10846440 	call	1084644 <xTaskCheckForTimeOut>
 10819d0:	10001d1e 	bne	r2,zero,1081a48 <xQueueSemaphoreTake+0x1b0>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 10819d4:	e13ff917 	ldw	r4,-28(fp)
 10819d8:	108222c0 	call	108222c <prvIsQueueEmpty>
 10819dc:	10001626 	beq	r2,zero,1081a38 <xQueueSemaphoreTake+0x1a0>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 10819e0:	e0bff917 	ldw	r2,-28(fp)
 10819e4:	10800017 	ldw	r2,0(r2)
 10819e8:	1000071e 	bne	r2,zero,1081a08 <xQueueSemaphoreTake+0x170>
					{
						taskENTER_CRITICAL();
 10819ec:	1084da00 	call	1084da0 <vTaskEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 10819f0:	e0bff917 	ldw	r2,-28(fp)
 10819f4:	10800217 	ldw	r2,8(r2)
 10819f8:	1009883a 	mov	r4,r2
 10819fc:	1084a240 	call	1084a24 <xTaskPriorityInherit>
 1081a00:	e0bff815 	stw	r2,-32(fp)
						}
						taskEXIT_CRITICAL();
 1081a04:	1084df40 	call	1084df4 <vTaskExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1081a08:	e0bff917 	ldw	r2,-28(fp)
 1081a0c:	10800904 	addi	r2,r2,36
 1081a10:	e0ffff17 	ldw	r3,-4(fp)
 1081a14:	180b883a 	mov	r5,r3
 1081a18:	1009883a 	mov	r4,r2
 1081a1c:	108434c0 	call	108434c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 1081a20:	e13ff917 	ldw	r4,-28(fp)
 1081a24:	10821380 	call	1082138 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 1081a28:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 1081a2c:	103fa41e 	bne	r2,zero,10818c0 <__alt_data_end+0xfffac190>
				{
					portYIELD_WITHIN_API();
 1081a30:	003b683a 	trap	0
 1081a34:	003fa206 	br	10818c0 <__alt_data_end+0xfffac190>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
 1081a38:	e13ff917 	ldw	r4,-28(fp)
 1081a3c:	10821380 	call	1082138 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 1081a40:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 1081a44:	003f9e06 	br	10818c0 <__alt_data_end+0xfffac190>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
 1081a48:	e13ff917 	ldw	r4,-28(fp)
 1081a4c:	10821380 	call	1082138 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 1081a50:	1083e6c0 	call	1083e6c <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1081a54:	e13ff917 	ldw	r4,-28(fp)
 1081a58:	108222c0 	call	108222c <prvIsQueueEmpty>
 1081a5c:	103f9826 	beq	r2,zero,10818c0 <__alt_data_end+0xfffac190>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
 1081a60:	e0bff817 	ldw	r2,-32(fp)
 1081a64:	10000a26 	beq	r2,zero,1081a90 <xQueueSemaphoreTake+0x1f8>
					{
						taskENTER_CRITICAL();
 1081a68:	1084da00 	call	1084da0 <vTaskEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 1081a6c:	e13ff917 	ldw	r4,-28(fp)
 1081a70:	1081ec00 	call	1081ec0 <prvGetDisinheritPriorityAfterTimeout>
 1081a74:	e0bffb15 	stw	r2,-20(fp)
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 1081a78:	e0bff917 	ldw	r2,-28(fp)
 1081a7c:	10800217 	ldw	r2,8(r2)
 1081a80:	e17ffb17 	ldw	r5,-20(fp)
 1081a84:	1009883a 	mov	r4,r2
 1081a88:	1084c600 	call	1084c60 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
 1081a8c:	1084df40 	call	1084df4 <vTaskExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 1081a90:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 1081a94:	e037883a 	mov	sp,fp
 1081a98:	dfc00117 	ldw	ra,4(sp)
 1081a9c:	df000017 	ldw	fp,0(sp)
 1081aa0:	dec00204 	addi	sp,sp,8
 1081aa4:	f800283a 	ret

01081aa8 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 1081aa8:	defff504 	addi	sp,sp,-44
 1081aac:	dfc00a15 	stw	ra,40(sp)
 1081ab0:	df000915 	stw	fp,36(sp)
 1081ab4:	df000904 	addi	fp,sp,36
 1081ab8:	e13ffd15 	stw	r4,-12(fp)
 1081abc:	e17ffe15 	stw	r5,-8(fp)
 1081ac0:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 1081ac4:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
 1081ac8:	e0bffd17 	ldw	r2,-12(fp)
 1081acc:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 1081ad0:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1081ad4:	e0bff817 	ldw	r2,-32(fp)
 1081ad8:	10800e17 	ldw	r2,56(r2)
 1081adc:	e0bff915 	stw	r2,-28(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1081ae0:	e0bff917 	ldw	r2,-28(fp)
 1081ae4:	10001526 	beq	r2,zero,1081b3c <xQueuePeek+0x94>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 1081ae8:	e0bff817 	ldw	r2,-32(fp)
 1081aec:	10800317 	ldw	r2,12(r2)
 1081af0:	e0bffa15 	stw	r2,-24(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1081af4:	e17ffe17 	ldw	r5,-8(fp)
 1081af8:	e13ff817 	ldw	r4,-32(fp)
 1081afc:	108209c0 	call	108209c <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 1081b00:	e0bff817 	ldw	r2,-32(fp)
 1081b04:	e0fffa17 	ldw	r3,-24(fp)
 1081b08:	10c00315 	stw	r3,12(r2)

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1081b0c:	e0bff817 	ldw	r2,-32(fp)
 1081b10:	10800917 	ldw	r2,36(r2)
 1081b14:	10000626 	beq	r2,zero,1081b30 <xQueuePeek+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1081b18:	e0bff817 	ldw	r2,-32(fp)
 1081b1c:	10800904 	addi	r2,r2,36
 1081b20:	1009883a 	mov	r4,r2
 1081b24:	10844000 	call	1084400 <xTaskRemoveFromEventList>
 1081b28:	10000126 	beq	r2,zero,1081b30 <xQueuePeek+0x88>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
 1081b2c:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 1081b30:	1084df40 	call	1084df4 <vTaskExitCritical>
				return pdPASS;
 1081b34:	00800044 	movi	r2,1
 1081b38:	00004206 	br	1081c44 <xQueuePeek+0x19c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 1081b3c:	e0bfff17 	ldw	r2,-4(fp)
 1081b40:	1000031e 	bne	r2,zero,1081b50 <xQueuePeek+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 1081b44:	1084df40 	call	1084df4 <vTaskExitCritical>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 1081b48:	0005883a 	mov	r2,zero
 1081b4c:	00003d06 	br	1081c44 <xQueuePeek+0x19c>
				}
				else if( xEntryTimeSet == pdFALSE )
 1081b50:	e0bff717 	ldw	r2,-36(fp)
 1081b54:	1000051e 	bne	r2,zero,1081b6c <xQueuePeek+0xc4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 1081b58:	e0bffb04 	addi	r2,fp,-20
 1081b5c:	1009883a 	mov	r4,r2
 1081b60:	10846080 	call	1084608 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 1081b64:	00800044 	movi	r2,1
 1081b68:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 1081b6c:	1084df40 	call	1084df4 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 1081b70:	1083e400 	call	1083e40 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 1081b74:	1084da00 	call	1084da0 <vTaskEnterCritical>
 1081b78:	e0bff817 	ldw	r2,-32(fp)
 1081b7c:	10801103 	ldbu	r2,68(r2)
 1081b80:	10803fcc 	andi	r2,r2,255
 1081b84:	1080201c 	xori	r2,r2,128
 1081b88:	10bfe004 	addi	r2,r2,-128
 1081b8c:	10bfffd8 	cmpnei	r2,r2,-1
 1081b90:	1000021e 	bne	r2,zero,1081b9c <xQueuePeek+0xf4>
 1081b94:	e0bff817 	ldw	r2,-32(fp)
 1081b98:	10001105 	stb	zero,68(r2)
 1081b9c:	e0bff817 	ldw	r2,-32(fp)
 1081ba0:	10801143 	ldbu	r2,69(r2)
 1081ba4:	10803fcc 	andi	r2,r2,255
 1081ba8:	1080201c 	xori	r2,r2,128
 1081bac:	10bfe004 	addi	r2,r2,-128
 1081bb0:	10bfffd8 	cmpnei	r2,r2,-1
 1081bb4:	1000021e 	bne	r2,zero,1081bc0 <xQueuePeek+0x118>
 1081bb8:	e0bff817 	ldw	r2,-32(fp)
 1081bbc:	10001145 	stb	zero,69(r2)
 1081bc0:	1084df40 	call	1084df4 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1081bc4:	e0ffff04 	addi	r3,fp,-4
 1081bc8:	e0bffb04 	addi	r2,fp,-20
 1081bcc:	180b883a 	mov	r5,r3
 1081bd0:	1009883a 	mov	r4,r2
 1081bd4:	10846440 	call	1084644 <xTaskCheckForTimeOut>
 1081bd8:	1000131e 	bne	r2,zero,1081c28 <xQueuePeek+0x180>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1081bdc:	e13ff817 	ldw	r4,-32(fp)
 1081be0:	108222c0 	call	108222c <prvIsQueueEmpty>
 1081be4:	10000c26 	beq	r2,zero,1081c18 <xQueuePeek+0x170>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1081be8:	e0bff817 	ldw	r2,-32(fp)
 1081bec:	10800904 	addi	r2,r2,36
 1081bf0:	e0ffff17 	ldw	r3,-4(fp)
 1081bf4:	180b883a 	mov	r5,r3
 1081bf8:	1009883a 	mov	r4,r2
 1081bfc:	108434c0 	call	108434c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 1081c00:	e13ff817 	ldw	r4,-32(fp)
 1081c04:	10821380 	call	1082138 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 1081c08:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 1081c0c:	103fb01e 	bne	r2,zero,1081ad0 <__alt_data_end+0xfffac3a0>
				{
					portYIELD_WITHIN_API();
 1081c10:	003b683a 	trap	0
 1081c14:	003fae06 	br	1081ad0 <__alt_data_end+0xfffac3a0>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
 1081c18:	e13ff817 	ldw	r4,-32(fp)
 1081c1c:	10821380 	call	1082138 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 1081c20:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 1081c24:	003faa06 	br	1081ad0 <__alt_data_end+0xfffac3a0>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
 1081c28:	e13ff817 	ldw	r4,-32(fp)
 1081c2c:	10821380 	call	1082138 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 1081c30:	1083e6c0 	call	1083e6c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1081c34:	e13ff817 	ldw	r4,-32(fp)
 1081c38:	108222c0 	call	108222c <prvIsQueueEmpty>
 1081c3c:	103fa426 	beq	r2,zero,1081ad0 <__alt_data_end+0xfffac3a0>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 1081c40:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 1081c44:	e037883a 	mov	sp,fp
 1081c48:	dfc00117 	ldw	ra,4(sp)
 1081c4c:	df000017 	ldw	fp,0(sp)
 1081c50:	dec00204 	addi	sp,sp,8
 1081c54:	f800283a 	ret

01081c58 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
 1081c58:	defff604 	addi	sp,sp,-40
 1081c5c:	dfc00915 	stw	ra,36(sp)
 1081c60:	df000815 	stw	fp,32(sp)
 1081c64:	df000804 	addi	fp,sp,32
 1081c68:	e13ffd15 	stw	r4,-12(fp)
 1081c6c:	e17ffe15 	stw	r5,-8(fp)
 1081c70:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 1081c74:	e0bffd17 	ldw	r2,-12(fp)
 1081c78:	e0bff915 	stw	r2,-28(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1081c7c:	e03ffa15 	stw	zero,-24(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1081c80:	e0bff917 	ldw	r2,-28(fp)
 1081c84:	10800e17 	ldw	r2,56(r2)
 1081c88:	e0bffb15 	stw	r2,-20(fp)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1081c8c:	e0bffb17 	ldw	r2,-20(fp)
 1081c90:	10002326 	beq	r2,zero,1081d20 <xQueueReceiveFromISR+0xc8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
 1081c94:	e0bff917 	ldw	r2,-28(fp)
 1081c98:	10801103 	ldbu	r2,68(r2)
 1081c9c:	e0bffc05 	stb	r2,-16(fp)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1081ca0:	e17ffe17 	ldw	r5,-8(fp)
 1081ca4:	e13ff917 	ldw	r4,-28(fp)
 1081ca8:	108209c0 	call	108209c <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1081cac:	e0bffb17 	ldw	r2,-20(fp)
 1081cb0:	10ffffc4 	addi	r3,r2,-1
 1081cb4:	e0bff917 	ldw	r2,-28(fp)
 1081cb8:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
 1081cbc:	e0bffc07 	ldb	r2,-16(fp)
 1081cc0:	10bfffd8 	cmpnei	r2,r2,-1
 1081cc4:	10000e1e 	bne	r2,zero,1081d00 <xQueueReceiveFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1081cc8:	e0bff917 	ldw	r2,-28(fp)
 1081ccc:	10800417 	ldw	r2,16(r2)
 1081cd0:	10001026 	beq	r2,zero,1081d14 <xQueueReceiveFromISR+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1081cd4:	e0bff917 	ldw	r2,-28(fp)
 1081cd8:	10800404 	addi	r2,r2,16
 1081cdc:	1009883a 	mov	r4,r2
 1081ce0:	10844000 	call	1084400 <xTaskRemoveFromEventList>
 1081ce4:	10000b26 	beq	r2,zero,1081d14 <xQueueReceiveFromISR+0xbc>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 1081ce8:	e0bfff17 	ldw	r2,-4(fp)
 1081cec:	10000926 	beq	r2,zero,1081d14 <xQueueReceiveFromISR+0xbc>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 1081cf0:	e0bfff17 	ldw	r2,-4(fp)
 1081cf4:	00c00044 	movi	r3,1
 1081cf8:	10c00015 	stw	r3,0(r2)
 1081cfc:	00000506 	br	1081d14 <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 1081d00:	e0bffc03 	ldbu	r2,-16(fp)
 1081d04:	10800044 	addi	r2,r2,1
 1081d08:	1007883a 	mov	r3,r2
 1081d0c:	e0bff917 	ldw	r2,-28(fp)
 1081d10:	10c01105 	stb	r3,68(r2)
			}

			xReturn = pdPASS;
 1081d14:	00800044 	movi	r2,1
 1081d18:	e0bff815 	stw	r2,-32(fp)
 1081d1c:	00000106 	br	1081d24 <xQueueReceiveFromISR+0xcc>
		}
		else
		{
			xReturn = pdFAIL;
 1081d20:	e03ff815 	stw	zero,-32(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1081d24:	e0bff817 	ldw	r2,-32(fp)
}
 1081d28:	e037883a 	mov	sp,fp
 1081d2c:	dfc00117 	ldw	ra,4(sp)
 1081d30:	df000017 	ldw	fp,0(sp)
 1081d34:	dec00204 	addi	sp,sp,8
 1081d38:	f800283a 	ret

01081d3c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
 1081d3c:	defff804 	addi	sp,sp,-32
 1081d40:	dfc00715 	stw	ra,28(sp)
 1081d44:	df000615 	stw	fp,24(sp)
 1081d48:	df000604 	addi	fp,sp,24
 1081d4c:	e13ffe15 	stw	r4,-8(fp)
 1081d50:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
 1081d54:	e0bffe17 	ldw	r2,-8(fp)
 1081d58:	e0bffb15 	stw	r2,-20(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1081d5c:	e03ffc15 	stw	zero,-16(fp)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1081d60:	e0bffb17 	ldw	r2,-20(fp)
 1081d64:	10800e17 	ldw	r2,56(r2)
 1081d68:	10000c26 	beq	r2,zero,1081d9c <xQueuePeekFromISR+0x60>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 1081d6c:	e0bffb17 	ldw	r2,-20(fp)
 1081d70:	10800317 	ldw	r2,12(r2)
 1081d74:	e0bffd15 	stw	r2,-12(fp)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1081d78:	e17fff17 	ldw	r5,-4(fp)
 1081d7c:	e13ffb17 	ldw	r4,-20(fp)
 1081d80:	108209c0 	call	108209c <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 1081d84:	e0bffb17 	ldw	r2,-20(fp)
 1081d88:	e0fffd17 	ldw	r3,-12(fp)
 1081d8c:	10c00315 	stw	r3,12(r2)

			xReturn = pdPASS;
 1081d90:	00800044 	movi	r2,1
 1081d94:	e0bffa15 	stw	r2,-24(fp)
 1081d98:	00000106 	br	1081da0 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
 1081d9c:	e03ffa15 	stw	zero,-24(fp)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1081da0:	e0bffa17 	ldw	r2,-24(fp)
}
 1081da4:	e037883a 	mov	sp,fp
 1081da8:	dfc00117 	ldw	ra,4(sp)
 1081dac:	df000017 	ldw	fp,0(sp)
 1081db0:	dec00204 	addi	sp,sp,8
 1081db4:	f800283a 	ret

01081db8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 1081db8:	defffc04 	addi	sp,sp,-16
 1081dbc:	dfc00315 	stw	ra,12(sp)
 1081dc0:	df000215 	stw	fp,8(sp)
 1081dc4:	df000204 	addi	fp,sp,8
 1081dc8:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
 1081dcc:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1081dd0:	e0bfff17 	ldw	r2,-4(fp)
 1081dd4:	10800e17 	ldw	r2,56(r2)
 1081dd8:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 1081ddc:	1084df40 	call	1084df4 <vTaskExitCritical>

	return uxReturn;
 1081de0:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1081de4:	e037883a 	mov	sp,fp
 1081de8:	dfc00117 	ldw	ra,4(sp)
 1081dec:	df000017 	ldw	fp,0(sp)
 1081df0:	dec00204 	addi	sp,sp,8
 1081df4:	f800283a 	ret

01081df8 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 1081df8:	defffb04 	addi	sp,sp,-20
 1081dfc:	dfc00415 	stw	ra,16(sp)
 1081e00:	df000315 	stw	fp,12(sp)
 1081e04:	df000304 	addi	fp,sp,12
 1081e08:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
 1081e0c:	e0bfff17 	ldw	r2,-4(fp)
 1081e10:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 1081e14:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1081e18:	e0bffd17 	ldw	r2,-12(fp)
 1081e1c:	10c00f17 	ldw	r3,60(r2)
 1081e20:	e0bffd17 	ldw	r2,-12(fp)
 1081e24:	10800e17 	ldw	r2,56(r2)
 1081e28:	1885c83a 	sub	r2,r3,r2
 1081e2c:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 1081e30:	1084df40 	call	1084df4 <vTaskExitCritical>

	return uxReturn;
 1081e34:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1081e38:	e037883a 	mov	sp,fp
 1081e3c:	dfc00117 	ldw	ra,4(sp)
 1081e40:	df000017 	ldw	fp,0(sp)
 1081e44:	dec00204 	addi	sp,sp,8
 1081e48:	f800283a 	ret

01081e4c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 1081e4c:	defffc04 	addi	sp,sp,-16
 1081e50:	df000315 	stw	fp,12(sp)
 1081e54:	df000304 	addi	fp,sp,12
 1081e58:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
 1081e5c:	e0bfff17 	ldw	r2,-4(fp)
 1081e60:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
 1081e64:	e0bffd17 	ldw	r2,-12(fp)
 1081e68:	10800e17 	ldw	r2,56(r2)
 1081e6c:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
 1081e70:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1081e74:	e037883a 	mov	sp,fp
 1081e78:	df000017 	ldw	fp,0(sp)
 1081e7c:	dec00104 	addi	sp,sp,4
 1081e80:	f800283a 	ret

01081e84 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 1081e84:	defffc04 	addi	sp,sp,-16
 1081e88:	dfc00315 	stw	ra,12(sp)
 1081e8c:	df000215 	stw	fp,8(sp)
 1081e90:	df000204 	addi	fp,sp,8
 1081e94:	e13fff15 	stw	r4,-4(fp)
Queue_t * const pxQueue = xQueue;
 1081e98:	e0bfff17 	ldw	r2,-4(fp)
 1081e9c:	e0bffe15 	stw	r2,-8(fp)

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
 1081ea0:	e13ffe17 	ldw	r4,-8(fp)
 1081ea4:	1080e880 	call	1080e88 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 1081ea8:	0001883a 	nop
 1081eac:	e037883a 	mov	sp,fp
 1081eb0:	dfc00117 	ldw	ra,4(sp)
 1081eb4:	df000017 	ldw	fp,0(sp)
 1081eb8:	dec00204 	addi	sp,sp,8
 1081ebc:	f800283a 	ret

01081ec0 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 1081ec0:	defffd04 	addi	sp,sp,-12
 1081ec4:	df000215 	stw	fp,8(sp)
 1081ec8:	df000204 	addi	fp,sp,8
 1081ecc:	e13fff15 	stw	r4,-4(fp)
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 1081ed0:	e0bfff17 	ldw	r2,-4(fp)
 1081ed4:	10800917 	ldw	r2,36(r2)
 1081ed8:	10000726 	beq	r2,zero,1081ef8 <prvGetDisinheritPriorityAfterTimeout+0x38>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 1081edc:	e0bfff17 	ldw	r2,-4(fp)
 1081ee0:	10800c17 	ldw	r2,48(r2)
 1081ee4:	10800017 	ldw	r2,0(r2)
 1081ee8:	00c00144 	movi	r3,5
 1081eec:	1885c83a 	sub	r2,r3,r2
 1081ef0:	e0bffe15 	stw	r2,-8(fp)
 1081ef4:	00000106 	br	1081efc <prvGetDisinheritPriorityAfterTimeout+0x3c>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 1081ef8:	e03ffe15 	stw	zero,-8(fp)
		}

		return uxHighestPriorityOfWaitingTasks;
 1081efc:	e0bffe17 	ldw	r2,-8(fp)
	}
 1081f00:	e037883a 	mov	sp,fp
 1081f04:	df000017 	ldw	fp,0(sp)
 1081f08:	dec00104 	addi	sp,sp,4
 1081f0c:	f800283a 	ret

01081f10 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 1081f10:	defff904 	addi	sp,sp,-28
 1081f14:	dfc00615 	stw	ra,24(sp)
 1081f18:	df000515 	stw	fp,20(sp)
 1081f1c:	df000504 	addi	fp,sp,20
 1081f20:	e13ffd15 	stw	r4,-12(fp)
 1081f24:	e17ffe15 	stw	r5,-8(fp)
 1081f28:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn = pdFALSE;
 1081f2c:	e03ffb15 	stw	zero,-20(fp)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1081f30:	e0bffd17 	ldw	r2,-12(fp)
 1081f34:	10800e17 	ldw	r2,56(r2)
 1081f38:	e0bffc15 	stw	r2,-16(fp)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 1081f3c:	e0bffd17 	ldw	r2,-12(fp)
 1081f40:	10801017 	ldw	r2,64(r2)
 1081f44:	10000b1e 	bne	r2,zero,1081f74 <prvCopyDataToQueue+0x64>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1081f48:	e0bffd17 	ldw	r2,-12(fp)
 1081f4c:	10800017 	ldw	r2,0(r2)
 1081f50:	1000481e 	bne	r2,zero,1082074 <prvCopyDataToQueue+0x164>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 1081f54:	e0bffd17 	ldw	r2,-12(fp)
 1081f58:	10800217 	ldw	r2,8(r2)
 1081f5c:	1009883a 	mov	r4,r2
 1081f60:	1084b640 	call	1084b64 <xTaskPriorityDisinherit>
 1081f64:	e0bffb15 	stw	r2,-20(fp)
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 1081f68:	e0bffd17 	ldw	r2,-12(fp)
 1081f6c:	10000215 	stw	zero,8(r2)
 1081f70:	00004006 	br	1082074 <prvCopyDataToQueue+0x164>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 1081f74:	e0bfff17 	ldw	r2,-4(fp)
 1081f78:	1000191e 	bne	r2,zero,1081fe0 <prvCopyDataToQueue+0xd0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 1081f7c:	e0bffd17 	ldw	r2,-12(fp)
 1081f80:	10c00117 	ldw	r3,4(r2)
 1081f84:	e0bffd17 	ldw	r2,-12(fp)
 1081f88:	10801017 	ldw	r2,64(r2)
 1081f8c:	100d883a 	mov	r6,r2
 1081f90:	e17ffe17 	ldw	r5,-8(fp)
 1081f94:	1809883a 	mov	r4,r3
 1081f98:	108633c0 	call	108633c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 1081f9c:	e0bffd17 	ldw	r2,-12(fp)
 1081fa0:	10c00117 	ldw	r3,4(r2)
 1081fa4:	e0bffd17 	ldw	r2,-12(fp)
 1081fa8:	10801017 	ldw	r2,64(r2)
 1081fac:	1887883a 	add	r3,r3,r2
 1081fb0:	e0bffd17 	ldw	r2,-12(fp)
 1081fb4:	10c00115 	stw	r3,4(r2)
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 1081fb8:	e0bffd17 	ldw	r2,-12(fp)
 1081fbc:	10c00117 	ldw	r3,4(r2)
 1081fc0:	e0bffd17 	ldw	r2,-12(fp)
 1081fc4:	10800217 	ldw	r2,8(r2)
 1081fc8:	18802a36 	bltu	r3,r2,1082074 <prvCopyDataToQueue+0x164>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 1081fcc:	e0bffd17 	ldw	r2,-12(fp)
 1081fd0:	10c00017 	ldw	r3,0(r2)
 1081fd4:	e0bffd17 	ldw	r2,-12(fp)
 1081fd8:	10c00115 	stw	r3,4(r2)
 1081fdc:	00002506 	br	1082074 <prvCopyDataToQueue+0x164>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 1081fe0:	e0bffd17 	ldw	r2,-12(fp)
 1081fe4:	10c00317 	ldw	r3,12(r2)
 1081fe8:	e0bffd17 	ldw	r2,-12(fp)
 1081fec:	10801017 	ldw	r2,64(r2)
 1081ff0:	100d883a 	mov	r6,r2
 1081ff4:	e17ffe17 	ldw	r5,-8(fp)
 1081ff8:	1809883a 	mov	r4,r3
 1081ffc:	108633c0 	call	108633c <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 1082000:	e0bffd17 	ldw	r2,-12(fp)
 1082004:	10c00317 	ldw	r3,12(r2)
 1082008:	e0bffd17 	ldw	r2,-12(fp)
 108200c:	10801017 	ldw	r2,64(r2)
 1082010:	0085c83a 	sub	r2,zero,r2
 1082014:	1887883a 	add	r3,r3,r2
 1082018:	e0bffd17 	ldw	r2,-12(fp)
 108201c:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 1082020:	e0bffd17 	ldw	r2,-12(fp)
 1082024:	10c00317 	ldw	r3,12(r2)
 1082028:	e0bffd17 	ldw	r2,-12(fp)
 108202c:	10800017 	ldw	r2,0(r2)
 1082030:	1880082e 	bgeu	r3,r2,1082054 <prvCopyDataToQueue+0x144>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 1082034:	e0bffd17 	ldw	r2,-12(fp)
 1082038:	10c00217 	ldw	r3,8(r2)
 108203c:	e0bffd17 	ldw	r2,-12(fp)
 1082040:	10801017 	ldw	r2,64(r2)
 1082044:	0085c83a 	sub	r2,zero,r2
 1082048:	1887883a 	add	r3,r3,r2
 108204c:	e0bffd17 	ldw	r2,-12(fp)
 1082050:	10c00315 	stw	r3,12(r2)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 1082054:	e0bfff17 	ldw	r2,-4(fp)
 1082058:	10800098 	cmpnei	r2,r2,2
 108205c:	1000051e 	bne	r2,zero,1082074 <prvCopyDataToQueue+0x164>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1082060:	e0bffc17 	ldw	r2,-16(fp)
 1082064:	10000326 	beq	r2,zero,1082074 <prvCopyDataToQueue+0x164>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 1082068:	e0bffc17 	ldw	r2,-16(fp)
 108206c:	10bfffc4 	addi	r2,r2,-1
 1082070:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1082074:	e0bffc17 	ldw	r2,-16(fp)
 1082078:	10c00044 	addi	r3,r2,1
 108207c:	e0bffd17 	ldw	r2,-12(fp)
 1082080:	10c00e15 	stw	r3,56(r2)

	return xReturn;
 1082084:	e0bffb17 	ldw	r2,-20(fp)
}
 1082088:	e037883a 	mov	sp,fp
 108208c:	dfc00117 	ldw	ra,4(sp)
 1082090:	df000017 	ldw	fp,0(sp)
 1082094:	dec00204 	addi	sp,sp,8
 1082098:	f800283a 	ret

0108209c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 108209c:	defffc04 	addi	sp,sp,-16
 10820a0:	dfc00315 	stw	ra,12(sp)
 10820a4:	df000215 	stw	fp,8(sp)
 10820a8:	df000204 	addi	fp,sp,8
 10820ac:	e13ffe15 	stw	r4,-8(fp)
 10820b0:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 10820b4:	e0bffe17 	ldw	r2,-8(fp)
 10820b8:	10801017 	ldw	r2,64(r2)
 10820bc:	10001826 	beq	r2,zero,1082120 <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 10820c0:	e0bffe17 	ldw	r2,-8(fp)
 10820c4:	10c00317 	ldw	r3,12(r2)
 10820c8:	e0bffe17 	ldw	r2,-8(fp)
 10820cc:	10801017 	ldw	r2,64(r2)
 10820d0:	1887883a 	add	r3,r3,r2
 10820d4:	e0bffe17 	ldw	r2,-8(fp)
 10820d8:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 10820dc:	e0bffe17 	ldw	r2,-8(fp)
 10820e0:	10c00317 	ldw	r3,12(r2)
 10820e4:	e0bffe17 	ldw	r2,-8(fp)
 10820e8:	10800217 	ldw	r2,8(r2)
 10820ec:	18800436 	bltu	r3,r2,1082100 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 10820f0:	e0bffe17 	ldw	r2,-8(fp)
 10820f4:	10c00017 	ldw	r3,0(r2)
 10820f8:	e0bffe17 	ldw	r2,-8(fp)
 10820fc:	10c00315 	stw	r3,12(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 1082100:	e0bffe17 	ldw	r2,-8(fp)
 1082104:	10c00317 	ldw	r3,12(r2)
 1082108:	e0bffe17 	ldw	r2,-8(fp)
 108210c:	10801017 	ldw	r2,64(r2)
 1082110:	100d883a 	mov	r6,r2
 1082114:	180b883a 	mov	r5,r3
 1082118:	e13fff17 	ldw	r4,-4(fp)
 108211c:	108633c0 	call	108633c <memcpy>
	}
}
 1082120:	0001883a 	nop
 1082124:	e037883a 	mov	sp,fp
 1082128:	dfc00117 	ldw	ra,4(sp)
 108212c:	df000017 	ldw	fp,0(sp)
 1082130:	dec00204 	addi	sp,sp,8
 1082134:	f800283a 	ret

01082138 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 1082138:	defffc04 	addi	sp,sp,-16
 108213c:	dfc00315 	stw	ra,12(sp)
 1082140:	df000215 	stw	fp,8(sp)
 1082144:	df000204 	addi	fp,sp,8
 1082148:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 108214c:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 1082150:	e0bfff17 	ldw	r2,-4(fp)
 1082154:	10801143 	ldbu	r2,69(r2)
 1082158:	e0bffe05 	stb	r2,-8(fp)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 108215c:	00000c06 	br	1082190 <prvUnlockQueue+0x58>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1082160:	e0bfff17 	ldw	r2,-4(fp)
 1082164:	10800917 	ldw	r2,36(r2)
 1082168:	10000c26 	beq	r2,zero,108219c <prvUnlockQueue+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 108216c:	e0bfff17 	ldw	r2,-4(fp)
 1082170:	10800904 	addi	r2,r2,36
 1082174:	1009883a 	mov	r4,r2
 1082178:	10844000 	call	1084400 <xTaskRemoveFromEventList>
 108217c:	10000126 	beq	r2,zero,1082184 <prvUnlockQueue+0x4c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 1082180:	10847240 	call	1084724 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 1082184:	e0bffe03 	ldbu	r2,-8(fp)
 1082188:	10bfffc4 	addi	r2,r2,-1
 108218c:	e0bffe05 	stb	r2,-8(fp)
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 1082190:	e0bffe07 	ldb	r2,-8(fp)
 1082194:	00bff216 	blt	zero,r2,1082160 <__alt_data_end+0xfffaca30>
 1082198:	00000106 	br	10821a0 <prvUnlockQueue+0x68>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
 108219c:	0001883a 	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 10821a0:	e0bfff17 	ldw	r2,-4(fp)
 10821a4:	00ffffc4 	movi	r3,-1
 10821a8:	10c01145 	stb	r3,69(r2)
	}
	taskEXIT_CRITICAL();
 10821ac:	1084df40 	call	1084df4 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 10821b0:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 10821b4:	e0bfff17 	ldw	r2,-4(fp)
 10821b8:	10801103 	ldbu	r2,68(r2)
 10821bc:	e0bffe45 	stb	r2,-7(fp)

		while( cRxLock > queueLOCKED_UNMODIFIED )
 10821c0:	00000c06 	br	10821f4 <prvUnlockQueue+0xbc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 10821c4:	e0bfff17 	ldw	r2,-4(fp)
 10821c8:	10800417 	ldw	r2,16(r2)
 10821cc:	10000c26 	beq	r2,zero,1082200 <prvUnlockQueue+0xc8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 10821d0:	e0bfff17 	ldw	r2,-4(fp)
 10821d4:	10800404 	addi	r2,r2,16
 10821d8:	1009883a 	mov	r4,r2
 10821dc:	10844000 	call	1084400 <xTaskRemoveFromEventList>
 10821e0:	10000126 	beq	r2,zero,10821e8 <prvUnlockQueue+0xb0>
				{
					vTaskMissedYield();
 10821e4:	10847240 	call	1084724 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 10821e8:	e0bffe43 	ldbu	r2,-7(fp)
 10821ec:	10bfffc4 	addi	r2,r2,-1
 10821f0:	e0bffe45 	stb	r2,-7(fp)
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
 10821f4:	e0bffe47 	ldb	r2,-7(fp)
 10821f8:	00bff216 	blt	zero,r2,10821c4 <__alt_data_end+0xfffaca94>
 10821fc:	00000106 	br	1082204 <prvUnlockQueue+0xcc>

				--cRxLock;
			}
			else
			{
				break;
 1082200:	0001883a 	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 1082204:	e0bfff17 	ldw	r2,-4(fp)
 1082208:	00ffffc4 	movi	r3,-1
 108220c:	10c01105 	stb	r3,68(r2)
	}
	taskEXIT_CRITICAL();
 1082210:	1084df40 	call	1084df4 <vTaskExitCritical>
}
 1082214:	0001883a 	nop
 1082218:	e037883a 	mov	sp,fp
 108221c:	dfc00117 	ldw	ra,4(sp)
 1082220:	df000017 	ldw	fp,0(sp)
 1082224:	dec00204 	addi	sp,sp,8
 1082228:	f800283a 	ret

0108222c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 108222c:	defffc04 	addi	sp,sp,-16
 1082230:	dfc00315 	stw	ra,12(sp)
 1082234:	df000215 	stw	fp,8(sp)
 1082238:	df000204 	addi	fp,sp,8
 108223c:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 1082240:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 1082244:	e0bfff17 	ldw	r2,-4(fp)
 1082248:	10800e17 	ldw	r2,56(r2)
 108224c:	1000031e 	bne	r2,zero,108225c <prvIsQueueEmpty+0x30>
		{
			xReturn = pdTRUE;
 1082250:	00800044 	movi	r2,1
 1082254:	e0bffe15 	stw	r2,-8(fp)
 1082258:	00000106 	br	1082260 <prvIsQueueEmpty+0x34>
		}
		else
		{
			xReturn = pdFALSE;
 108225c:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 1082260:	1084df40 	call	1084df4 <vTaskExitCritical>

	return xReturn;
 1082264:	e0bffe17 	ldw	r2,-8(fp)
}
 1082268:	e037883a 	mov	sp,fp
 108226c:	dfc00117 	ldw	ra,4(sp)
 1082270:	df000017 	ldw	fp,0(sp)
 1082274:	dec00204 	addi	sp,sp,8
 1082278:	f800283a 	ret

0108227c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 108227c:	defffc04 	addi	sp,sp,-16
 1082280:	df000315 	stw	fp,12(sp)
 1082284:	df000304 	addi	fp,sp,12
 1082288:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
 108228c:	e0bfff17 	ldw	r2,-4(fp)
 1082290:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 1082294:	e0bffe17 	ldw	r2,-8(fp)
 1082298:	10800e17 	ldw	r2,56(r2)
 108229c:	1000031e 	bne	r2,zero,10822ac <xQueueIsQueueEmptyFromISR+0x30>
	{
		xReturn = pdTRUE;
 10822a0:	00800044 	movi	r2,1
 10822a4:	e0bffd15 	stw	r2,-12(fp)
 10822a8:	00000106 	br	10822b0 <xQueueIsQueueEmptyFromISR+0x34>
	}
	else
	{
		xReturn = pdFALSE;
 10822ac:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 10822b0:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 10822b4:	e037883a 	mov	sp,fp
 10822b8:	df000017 	ldw	fp,0(sp)
 10822bc:	dec00104 	addi	sp,sp,4
 10822c0:	f800283a 	ret

010822c4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 10822c4:	defffc04 	addi	sp,sp,-16
 10822c8:	dfc00315 	stw	ra,12(sp)
 10822cc:	df000215 	stw	fp,8(sp)
 10822d0:	df000204 	addi	fp,sp,8
 10822d4:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 10822d8:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 10822dc:	e0bfff17 	ldw	r2,-4(fp)
 10822e0:	10c00e17 	ldw	r3,56(r2)
 10822e4:	e0bfff17 	ldw	r2,-4(fp)
 10822e8:	10800f17 	ldw	r2,60(r2)
 10822ec:	1880031e 	bne	r3,r2,10822fc <prvIsQueueFull+0x38>
		{
			xReturn = pdTRUE;
 10822f0:	00800044 	movi	r2,1
 10822f4:	e0bffe15 	stw	r2,-8(fp)
 10822f8:	00000106 	br	1082300 <prvIsQueueFull+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
 10822fc:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 1082300:	1084df40 	call	1084df4 <vTaskExitCritical>

	return xReturn;
 1082304:	e0bffe17 	ldw	r2,-8(fp)
}
 1082308:	e037883a 	mov	sp,fp
 108230c:	dfc00117 	ldw	ra,4(sp)
 1082310:	df000017 	ldw	fp,0(sp)
 1082314:	dec00204 	addi	sp,sp,8
 1082318:	f800283a 	ret

0108231c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 108231c:	defffc04 	addi	sp,sp,-16
 1082320:	df000315 	stw	fp,12(sp)
 1082324:	df000304 	addi	fp,sp,12
 1082328:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
 108232c:	e0bfff17 	ldw	r2,-4(fp)
 1082330:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 1082334:	e0bffe17 	ldw	r2,-8(fp)
 1082338:	10c00e17 	ldw	r3,56(r2)
 108233c:	e0bffe17 	ldw	r2,-8(fp)
 1082340:	10800f17 	ldw	r2,60(r2)
 1082344:	1880031e 	bne	r3,r2,1082354 <xQueueIsQueueFullFromISR+0x38>
	{
		xReturn = pdTRUE;
 1082348:	00800044 	movi	r2,1
 108234c:	e0bffd15 	stw	r2,-12(fp)
 1082350:	00000106 	br	1082358 <xQueueIsQueueFullFromISR+0x3c>
	}
	else
	{
		xReturn = pdFALSE;
 1082354:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 1082358:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 108235c:	e037883a 	mov	sp,fp
 1082360:	df000017 	ldw	fp,0(sp)
 1082364:	dec00104 	addi	sp,sp,4
 1082368:	f800283a 	ret

0108236c <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
 108236c:	defff804 	addi	sp,sp,-32
 1082370:	dfc00715 	stw	ra,28(sp)
 1082374:	df000615 	stw	fp,24(sp)
 1082378:	df000604 	addi	fp,sp,24
 108237c:	e13ffd15 	stw	r4,-12(fp)
 1082380:	e17ffe15 	stw	r5,-8(fp)
 1082384:	e1bfff15 	stw	r6,-4(fp)

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
 1082388:	e0bfff17 	ldw	r2,-4(fp)
 108238c:	10800058 	cmpnei	r2,r2,1
 1082390:	1000031e 	bne	r2,zero,10823a0 <xStreamBufferGenericCreate+0x34>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
 1082394:	00800044 	movi	r2,1
 1082398:	e0bffb05 	stb	r2,-20(fp)
 108239c:	00000106 	br	10823a4 <xStreamBufferGenericCreate+0x38>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
 10823a0:	e03ffb05 	stb	zero,-20(fp)
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
 10823a4:	e0bffe17 	ldw	r2,-8(fp)
 10823a8:	1000021e 	bne	r2,zero,10823b4 <xStreamBufferGenericCreate+0x48>
		{
			xTriggerLevelBytes = ( size_t ) 1;
 10823ac:	00800044 	movi	r2,1
 10823b0:	e0bffe15 	stw	r2,-8(fp)
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
 10823b4:	e0bffd17 	ldw	r2,-12(fp)
 10823b8:	10800044 	addi	r2,r2,1
 10823bc:	e0bffd15 	stw	r2,-12(fp)
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
 10823c0:	e0bffd17 	ldw	r2,-12(fp)
 10823c4:	10800804 	addi	r2,r2,32
 10823c8:	1009883a 	mov	r4,r2
 10823cc:	1080dc80 	call	1080dc8 <pvPortMalloc>
 10823d0:	e0bffc15 	stw	r2,-16(fp)

		if( pucAllocatedMemory != NULL )
 10823d4:	e0bffc17 	ldw	r2,-16(fp)
 10823d8:	10000926 	beq	r2,zero,1082400 <xStreamBufferGenericCreate+0x94>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
 10823dc:	e0bffc17 	ldw	r2,-16(fp)
 10823e0:	10c00804 	addi	r3,r2,32
 10823e4:	e0bffb03 	ldbu	r2,-20(fp)
 10823e8:	d8800015 	stw	r2,0(sp)
 10823ec:	e1fffe17 	ldw	r7,-8(fp)
 10823f0:	e1bffd17 	ldw	r6,-12(fp)
 10823f4:	180b883a 	mov	r5,r3
 10823f8:	e13ffc17 	ldw	r4,-16(fp)
 10823fc:	10831900 	call	1083190 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
 1082400:	e0bffc17 	ldw	r2,-16(fp)
	}
 1082404:	e037883a 	mov	sp,fp
 1082408:	dfc00117 	ldw	ra,4(sp)
 108240c:	df000017 	ldw	fp,0(sp)
 1082410:	dec00204 	addi	sp,sp,8
 1082414:	f800283a 	ret

01082418 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
 1082418:	defffc04 	addi	sp,sp,-16
 108241c:	dfc00315 	stw	ra,12(sp)
 1082420:	df000215 	stw	fp,8(sp)
 1082424:	df000204 	addi	fp,sp,8
 1082428:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
 108242c:	e0bfff17 	ldw	r2,-4(fp)
 1082430:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 1082434:	e0bffe17 	ldw	r2,-8(fp)
 1082438:	10800703 	ldbu	r2,28(r2)
 108243c:	10803fcc 	andi	r2,r2,255
 1082440:	1080008c 	andi	r2,r2,2
 1082444:	1000031e 	bne	r2,zero,1082454 <vStreamBufferDelete+0x3c>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
 1082448:	e13ffe17 	ldw	r4,-8(fp)
 108244c:	1080e880 	call	1080e88 <vPortFree>
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
	}
}
 1082450:	00000406 	br	1082464 <vStreamBufferDelete+0x4c>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 1082454:	01800804 	movi	r6,32
 1082458:	000b883a 	mov	r5,zero
 108245c:	e13ffe17 	ldw	r4,-8(fp)
 1082460:	10863640 	call	1086364 <memset>
	}
}
 1082464:	0001883a 	nop
 1082468:	e037883a 	mov	sp,fp
 108246c:	dfc00117 	ldw	ra,4(sp)
 1082470:	df000017 	ldw	fp,0(sp)
 1082474:	dec00204 	addi	sp,sp,8
 1082478:	f800283a 	ret

0108247c <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
 108247c:	defffa04 	addi	sp,sp,-24
 1082480:	dfc00515 	stw	ra,20(sp)
 1082484:	df000415 	stw	fp,16(sp)
 1082488:	df000404 	addi	fp,sp,16
 108248c:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1082490:	e0bfff17 	ldw	r2,-4(fp)
 1082494:	e0bffe15 	stw	r2,-8(fp)
BaseType_t xReturn = pdFAIL;
 1082498:	e03ffd15 	stw	zero,-12(fp)
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
 108249c:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
 10824a0:	e0bffe17 	ldw	r2,-8(fp)
 10824a4:	10800417 	ldw	r2,16(r2)
 10824a8:	1000141e 	bne	r2,zero,10824fc <xStreamBufferReset+0x80>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
 10824ac:	e0bffe17 	ldw	r2,-8(fp)
 10824b0:	10800517 	ldw	r2,20(r2)
 10824b4:	1000111e 	bne	r2,zero,10824fc <xStreamBufferReset+0x80>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
 10824b8:	e0bffe17 	ldw	r2,-8(fp)
 10824bc:	10c00617 	ldw	r3,24(r2)
 10824c0:	e0bffe17 	ldw	r2,-8(fp)
 10824c4:	11000217 	ldw	r4,8(r2)
 10824c8:	e0bffe17 	ldw	r2,-8(fp)
 10824cc:	11400317 	ldw	r5,12(r2)
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
 10824d0:	e0bffe17 	ldw	r2,-8(fp)
 10824d4:	10800703 	ldbu	r2,28(r2)
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
 10824d8:	10803fcc 	andi	r2,r2,255
 10824dc:	d8800015 	stw	r2,0(sp)
 10824e0:	280f883a 	mov	r7,r5
 10824e4:	200d883a 	mov	r6,r4
 10824e8:	180b883a 	mov	r5,r3
 10824ec:	e13ffe17 	ldw	r4,-8(fp)
 10824f0:	10831900 	call	1083190 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
 10824f4:	00800044 	movi	r2,1
 10824f8:	e0bffd15 	stw	r2,-12(fp)

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
 10824fc:	1084df40 	call	1084df4 <vTaskExitCritical>

	return xReturn;
 1082500:	e0bffd17 	ldw	r2,-12(fp)
}
 1082504:	e037883a 	mov	sp,fp
 1082508:	dfc00117 	ldw	ra,4(sp)
 108250c:	df000017 	ldw	fp,0(sp)
 1082510:	dec00204 	addi	sp,sp,8
 1082514:	f800283a 	ret

01082518 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
 1082518:	defffb04 	addi	sp,sp,-20
 108251c:	df000415 	stw	fp,16(sp)
 1082520:	df000404 	addi	fp,sp,16
 1082524:	e13ffe15 	stw	r4,-8(fp)
 1082528:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 108252c:	e0bffe17 	ldw	r2,-8(fp)
 1082530:	e0bffd15 	stw	r2,-12(fp)
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
 1082534:	e0bfff17 	ldw	r2,-4(fp)
 1082538:	1000021e 	bne	r2,zero,1082544 <xStreamBufferSetTriggerLevel+0x2c>
	{
		xTriggerLevel = ( size_t ) 1;
 108253c:	00800044 	movi	r2,1
 1082540:	e0bfff15 	stw	r2,-4(fp)
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
 1082544:	e0bffd17 	ldw	r2,-12(fp)
 1082548:	10c00217 	ldw	r3,8(r2)
 108254c:	e0bfff17 	ldw	r2,-4(fp)
 1082550:	18800636 	bltu	r3,r2,108256c <xStreamBufferSetTriggerLevel+0x54>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 1082554:	e0bffd17 	ldw	r2,-12(fp)
 1082558:	e0ffff17 	ldw	r3,-4(fp)
 108255c:	10c00315 	stw	r3,12(r2)
		xReturn = pdPASS;
 1082560:	00800044 	movi	r2,1
 1082564:	e0bffc15 	stw	r2,-16(fp)
 1082568:	00000106 	br	1082570 <xStreamBufferSetTriggerLevel+0x58>
	}
	else
	{
		xReturn = pdFALSE;
 108256c:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
 1082570:	e0bffc17 	ldw	r2,-16(fp)
}
 1082574:	e037883a 	mov	sp,fp
 1082578:	df000017 	ldw	fp,0(sp)
 108257c:	dec00104 	addi	sp,sp,4
 1082580:	f800283a 	ret

01082584 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 1082584:	defffc04 	addi	sp,sp,-16
 1082588:	df000315 	stw	fp,12(sp)
 108258c:	df000304 	addi	fp,sp,12
 1082590:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1082594:	e0bfff17 	ldw	r2,-4(fp)
 1082598:	e0bffe15 	stw	r2,-8(fp)
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 108259c:	e0bffe17 	ldw	r2,-8(fp)
 10825a0:	10c00217 	ldw	r3,8(r2)
 10825a4:	e0bffe17 	ldw	r2,-8(fp)
 10825a8:	10800017 	ldw	r2,0(r2)
 10825ac:	1885883a 	add	r2,r3,r2
 10825b0:	e0bffd15 	stw	r2,-12(fp)
	xSpace -= pxStreamBuffer->xHead;
 10825b4:	e0bffe17 	ldw	r2,-8(fp)
 10825b8:	10800117 	ldw	r2,4(r2)
 10825bc:	e0fffd17 	ldw	r3,-12(fp)
 10825c0:	1885c83a 	sub	r2,r3,r2
 10825c4:	e0bffd15 	stw	r2,-12(fp)
	xSpace -= ( size_t ) 1;
 10825c8:	e0bffd17 	ldw	r2,-12(fp)
 10825cc:	10bfffc4 	addi	r2,r2,-1
 10825d0:	e0bffd15 	stw	r2,-12(fp)

	if( xSpace >= pxStreamBuffer->xLength )
 10825d4:	e0bffe17 	ldw	r2,-8(fp)
 10825d8:	10800217 	ldw	r2,8(r2)
 10825dc:	e0fffd17 	ldw	r3,-12(fp)
 10825e0:	18800536 	bltu	r3,r2,10825f8 <xStreamBufferSpacesAvailable+0x74>
	{
		xSpace -= pxStreamBuffer->xLength;
 10825e4:	e0bffe17 	ldw	r2,-8(fp)
 10825e8:	10800217 	ldw	r2,8(r2)
 10825ec:	e0fffd17 	ldw	r3,-12(fp)
 10825f0:	1885c83a 	sub	r2,r3,r2
 10825f4:	e0bffd15 	stw	r2,-12(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
 10825f8:	e0bffd17 	ldw	r2,-12(fp)
}
 10825fc:	e037883a 	mov	sp,fp
 1082600:	df000017 	ldw	fp,0(sp)
 1082604:	dec00104 	addi	sp,sp,4
 1082608:	f800283a 	ret

0108260c <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 108260c:	defffb04 	addi	sp,sp,-20
 1082610:	dfc00415 	stw	ra,16(sp)
 1082614:	df000315 	stw	fp,12(sp)
 1082618:	df000304 	addi	fp,sp,12
 108261c:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1082620:	e0bfff17 	ldw	r2,-4(fp)
 1082624:	e0bffd15 	stw	r2,-12(fp)
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
 1082628:	e13ffd17 	ldw	r4,-12(fp)
 108262c:	108311c0 	call	108311c <prvBytesInBuffer>
 1082630:	e0bffe15 	stw	r2,-8(fp)
	return xReturn;
 1082634:	e0bffe17 	ldw	r2,-8(fp)
}
 1082638:	e037883a 	mov	sp,fp
 108263c:	dfc00117 	ldw	ra,4(sp)
 1082640:	df000017 	ldw	fp,0(sp)
 1082644:	dec00204 	addi	sp,sp,8
 1082648:	f800283a 	ret

0108264c <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
 108264c:	defff304 	addi	sp,sp,-52
 1082650:	dfc00c15 	stw	ra,48(sp)
 1082654:	df000b15 	stw	fp,44(sp)
 1082658:	df000b04 	addi	fp,sp,44
 108265c:	e13ffc15 	stw	r4,-16(fp)
 1082660:	e17ffd15 	stw	r5,-12(fp)
 1082664:	e1bffe15 	stw	r6,-8(fp)
 1082668:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 108266c:	e0bffc17 	ldw	r2,-16(fp)
 1082670:	e0bff815 	stw	r2,-32(fp)
size_t xReturn, xSpace = 0;
 1082674:	e03ff615 	stw	zero,-40(fp)
size_t xRequiredSpace = xDataLengthBytes;
 1082678:	e0bffe17 	ldw	r2,-8(fp)
 108267c:	e0bff715 	stw	r2,-36(fp)

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 1082680:	e0bff817 	ldw	r2,-32(fp)
 1082684:	10800703 	ldbu	r2,28(r2)
 1082688:	10803fcc 	andi	r2,r2,255
 108268c:	1080004c 	andi	r2,r2,1
 1082690:	10000326 	beq	r2,zero,10826a0 <xStreamBufferSend+0x54>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 1082694:	e0bff717 	ldw	r2,-36(fp)
 1082698:	10800104 	addi	r2,r2,4
 108269c:	e0bff715 	stw	r2,-36(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
 10826a0:	e0bfff17 	ldw	r2,-4(fp)
 10826a4:	10002226 	beq	r2,zero,1082730 <xStreamBufferSend+0xe4>
	{
		vTaskSetTimeOutState( &xTimeOut );
 10826a8:	e0bffa04 	addi	r2,fp,-24
 10826ac:	1009883a 	mov	r4,r2
 10826b0:	10845bc0 	call	10845bc <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
 10826b4:	1084da00 	call	1084da0 <vTaskEnterCritical>
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 10826b8:	e13ff817 	ldw	r4,-32(fp)
 10826bc:	10825840 	call	1082584 <xStreamBufferSpacesAvailable>
 10826c0:	e0bff615 	stw	r2,-40(fp)

				if( xSpace < xRequiredSpace )
 10826c4:	e0fff617 	ldw	r3,-40(fp)
 10826c8:	e0bff717 	ldw	r2,-36(fp)
 10826cc:	1880072e 	bgeu	r3,r2,10826ec <xStreamBufferSend+0xa0>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
 10826d0:	0009883a 	mov	r4,zero
 10826d4:	10855240 	call	1085524 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 10826d8:	10849fc0 	call	10849fc <xTaskGetCurrentTaskHandle>
 10826dc:	1007883a 	mov	r3,r2
 10826e0:	e0bff817 	ldw	r2,-32(fp)
 10826e4:	10c00515 	stw	r3,20(r2)
 10826e8:	00000206 	br	10826f4 <xStreamBufferSend+0xa8>
				}
				else
				{
					taskEXIT_CRITICAL();
 10826ec:	1084df40 	call	1084df4 <vTaskExitCritical>
					break;
 10826f0:	00000f06 	br	1082730 <xStreamBufferSend+0xe4>
				}
			}
			taskEXIT_CRITICAL();
 10826f4:	1084df40 	call	1084df4 <vTaskExitCritical>

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 10826f8:	e0bfff17 	ldw	r2,-4(fp)
 10826fc:	100f883a 	mov	r7,r2
 1082700:	000d883a 	mov	r6,zero
 1082704:	000b883a 	mov	r5,zero
 1082708:	0009883a 	mov	r4,zero
 108270c:	1084f800 	call	1084f80 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
 1082710:	e0bff817 	ldw	r2,-32(fp)
 1082714:	10000515 	stw	zero,20(r2)

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 1082718:	e0ffff04 	addi	r3,fp,-4
 108271c:	e0bffa04 	addi	r2,fp,-24
 1082720:	180b883a 	mov	r5,r3
 1082724:	1009883a 	mov	r4,r2
 1082728:	10846440 	call	1084644 <xTaskCheckForTimeOut>
 108272c:	103fe126 	beq	r2,zero,10826b4 <__alt_data_end+0xfffacf84>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
 1082730:	e0bff617 	ldw	r2,-40(fp)
 1082734:	1000031e 	bne	r2,zero,1082744 <xStreamBufferSend+0xf8>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 1082738:	e13ff817 	ldw	r4,-32(fp)
 108273c:	10825840 	call	1082584 <xStreamBufferSpacesAvailable>
 1082740:	e0bff615 	stw	r2,-40(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 1082744:	e0bff717 	ldw	r2,-36(fp)
 1082748:	d8800015 	stw	r2,0(sp)
 108274c:	e1fff617 	ldw	r7,-40(fp)
 1082750:	e1bffe17 	ldw	r6,-8(fp)
 1082754:	e17ffd17 	ldw	r5,-12(fp)
 1082758:	e13ff817 	ldw	r4,-32(fp)
 108275c:	10828c40 	call	10828c4 <prvWriteMessageToBuffer>
 1082760:	e0bff915 	stw	r2,-28(fp)

	if( xReturn > ( size_t ) 0 )
 1082764:	e0bff917 	ldw	r2,-28(fp)
 1082768:	10001426 	beq	r2,zero,10827bc <xStreamBufferSend+0x170>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 108276c:	e13ff817 	ldw	r4,-32(fp)
 1082770:	108311c0 	call	108311c <prvBytesInBuffer>
 1082774:	1007883a 	mov	r3,r2
 1082778:	e0bff817 	ldw	r2,-32(fp)
 108277c:	10800317 	ldw	r2,12(r2)
 1082780:	18800e36 	bltu	r3,r2,10827bc <xStreamBufferSend+0x170>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
 1082784:	1083e400 	call	1083e40 <vTaskSuspendAll>
 1082788:	e0bff817 	ldw	r2,-32(fp)
 108278c:	10800417 	ldw	r2,16(r2)
 1082790:	10000926 	beq	r2,zero,10827b8 <xStreamBufferSend+0x16c>
 1082794:	e0bff817 	ldw	r2,-32(fp)
 1082798:	10800417 	ldw	r2,16(r2)
 108279c:	000f883a 	mov	r7,zero
 10827a0:	000d883a 	mov	r6,zero
 10827a4:	000b883a 	mov	r5,zero
 10827a8:	1009883a 	mov	r4,r2
 10827ac:	10850740 	call	1085074 <xTaskGenericNotify>
 10827b0:	e0bff817 	ldw	r2,-32(fp)
 10827b4:	10000415 	stw	zero,16(r2)
 10827b8:	1083e6c0 	call	1083e6c <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
 10827bc:	e0bff917 	ldw	r2,-28(fp)
}
 10827c0:	e037883a 	mov	sp,fp
 10827c4:	dfc00117 	ldw	ra,4(sp)
 10827c8:	df000017 	ldw	fp,0(sp)
 10827cc:	dec00204 	addi	sp,sp,8
 10827d0:	f800283a 	ret

010827d4 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
 10827d4:	defff404 	addi	sp,sp,-48
 10827d8:	dfc00b15 	stw	ra,44(sp)
 10827dc:	df000a15 	stw	fp,40(sp)
 10827e0:	df000a04 	addi	fp,sp,40
 10827e4:	e13ffc15 	stw	r4,-16(fp)
 10827e8:	e17ffd15 	stw	r5,-12(fp)
 10827ec:	e1bffe15 	stw	r6,-8(fp)
 10827f0:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 10827f4:	e0bffc17 	ldw	r2,-16(fp)
 10827f8:	e0bff815 	stw	r2,-32(fp)
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
 10827fc:	e0bffe17 	ldw	r2,-8(fp)
 1082800:	e0bff715 	stw	r2,-36(fp)

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 1082804:	e0bff817 	ldw	r2,-32(fp)
 1082808:	10800703 	ldbu	r2,28(r2)
 108280c:	10803fcc 	andi	r2,r2,255
 1082810:	1080004c 	andi	r2,r2,1
 1082814:	10000326 	beq	r2,zero,1082824 <xStreamBufferSendFromISR+0x50>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 1082818:	e0bff717 	ldw	r2,-36(fp)
 108281c:	10800104 	addi	r2,r2,4
 1082820:	e0bff715 	stw	r2,-36(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 1082824:	e13ff817 	ldw	r4,-32(fp)
 1082828:	10825840 	call	1082584 <xStreamBufferSpacesAvailable>
 108282c:	e0bff915 	stw	r2,-28(fp)
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 1082830:	e0bff717 	ldw	r2,-36(fp)
 1082834:	d8800015 	stw	r2,0(sp)
 1082838:	e1fff917 	ldw	r7,-28(fp)
 108283c:	e1bffe17 	ldw	r6,-8(fp)
 1082840:	e17ffd17 	ldw	r5,-12(fp)
 1082844:	e13ff817 	ldw	r4,-32(fp)
 1082848:	10828c40 	call	10828c4 <prvWriteMessageToBuffer>
 108284c:	e0bffa15 	stw	r2,-24(fp)

	if( xReturn > ( size_t ) 0 )
 1082850:	e0bffa17 	ldw	r2,-24(fp)
 1082854:	10001526 	beq	r2,zero,10828ac <xStreamBufferSendFromISR+0xd8>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 1082858:	e13ff817 	ldw	r4,-32(fp)
 108285c:	108311c0 	call	108311c <prvBytesInBuffer>
 1082860:	1007883a 	mov	r3,r2
 1082864:	e0bff817 	ldw	r2,-32(fp)
 1082868:	10800317 	ldw	r2,12(r2)
 108286c:	18800f36 	bltu	r3,r2,10828ac <xStreamBufferSendFromISR+0xd8>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 1082870:	e03ffb15 	stw	zero,-20(fp)
 1082874:	e0bff817 	ldw	r2,-32(fp)
 1082878:	10800417 	ldw	r2,16(r2)
 108287c:	10000b26 	beq	r2,zero,10828ac <xStreamBufferSendFromISR+0xd8>
 1082880:	e0bff817 	ldw	r2,-32(fp)
 1082884:	10c00417 	ldw	r3,16(r2)
 1082888:	e0bfff17 	ldw	r2,-4(fp)
 108288c:	d8800015 	stw	r2,0(sp)
 1082890:	000f883a 	mov	r7,zero
 1082894:	000d883a 	mov	r6,zero
 1082898:	000b883a 	mov	r5,zero
 108289c:	1809883a 	mov	r4,r3
 10828a0:	10852200 	call	1085220 <xTaskGenericNotifyFromISR>
 10828a4:	e0bff817 	ldw	r2,-32(fp)
 10828a8:	10000415 	stw	zero,16(r2)
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
 10828ac:	e0bffa17 	ldw	r2,-24(fp)
}
 10828b0:	e037883a 	mov	sp,fp
 10828b4:	dfc00117 	ldw	ra,4(sp)
 10828b8:	df000017 	ldw	fp,0(sp)
 10828bc:	dec00204 	addi	sp,sp,8
 10828c0:	f800283a 	ret

010828c4 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
 10828c4:	defff804 	addi	sp,sp,-32
 10828c8:	dfc00715 	stw	ra,28(sp)
 10828cc:	df000615 	stw	fp,24(sp)
 10828d0:	df000604 	addi	fp,sp,24
 10828d4:	e13ffc15 	stw	r4,-16(fp)
 10828d8:	e17ffd15 	stw	r5,-12(fp)
 10828dc:	e1bffe15 	stw	r6,-8(fp)
 10828e0:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
 10828e4:	e0bfff17 	ldw	r2,-4(fp)
 10828e8:	1000021e 	bne	r2,zero,10828f4 <prvWriteMessageToBuffer+0x30>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
 10828ec:	e03ffa15 	stw	zero,-24(fp)
 10828f0:	00001906 	br	1082958 <prvWriteMessageToBuffer+0x94>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
 10828f4:	e0bffc17 	ldw	r2,-16(fp)
 10828f8:	10800703 	ldbu	r2,28(r2)
 10828fc:	10803fcc 	andi	r2,r2,255
 1082900:	1080004c 	andi	r2,r2,1
 1082904:	1000081e 	bne	r2,zero,1082928 <prvWriteMessageToBuffer+0x64>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
 1082908:	00800044 	movi	r2,1
 108290c:	e0bffa15 	stw	r2,-24(fp)
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 1082910:	e0fffe17 	ldw	r3,-8(fp)
 1082914:	e0bfff17 	ldw	r2,-4(fp)
 1082918:	1880012e 	bgeu	r3,r2,1082920 <prvWriteMessageToBuffer+0x5c>
 108291c:	1805883a 	mov	r2,r3
 1082920:	e0bffe15 	stw	r2,-8(fp)
 1082924:	00000c06 	br	1082958 <prvWriteMessageToBuffer+0x94>
	}
	else if( xSpace >= xRequiredSpace )
 1082928:	e0ffff17 	ldw	r3,-4(fp)
 108292c:	e0800217 	ldw	r2,8(fp)
 1082930:	18800836 	bltu	r3,r2,1082954 <prvWriteMessageToBuffer+0x90>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
 1082934:	00800044 	movi	r2,1
 1082938:	e0bffa15 	stw	r2,-24(fp)
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
 108293c:	e0bffe04 	addi	r2,fp,-8
 1082940:	01800104 	movi	r6,4
 1082944:	100b883a 	mov	r5,r2
 1082948:	e13ffc17 	ldw	r4,-16(fp)
 108294c:	1082f140 	call	1082f14 <prvWriteBytesToBuffer>
 1082950:	00000106 	br	1082958 <prvWriteMessageToBuffer+0x94>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
 1082954:	e03ffa15 	stw	zero,-24(fp)
	}

	if( xShouldWrite != pdFALSE )
 1082958:	e0bffa17 	ldw	r2,-24(fp)
 108295c:	10000726 	beq	r2,zero,108297c <prvWriteMessageToBuffer+0xb8>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
 1082960:	e0bffe17 	ldw	r2,-8(fp)
 1082964:	100d883a 	mov	r6,r2
 1082968:	e17ffd17 	ldw	r5,-12(fp)
 108296c:	e13ffc17 	ldw	r4,-16(fp)
 1082970:	1082f140 	call	1082f14 <prvWriteBytesToBuffer>
 1082974:	e0bffb15 	stw	r2,-20(fp)
 1082978:	00000106 	br	1082980 <prvWriteMessageToBuffer+0xbc>
	}
	else
	{
		xReturn = 0;
 108297c:	e03ffb15 	stw	zero,-20(fp)
	}

	return xReturn;
 1082980:	e0bffb17 	ldw	r2,-20(fp)
}
 1082984:	e037883a 	mov	sp,fp
 1082988:	dfc00117 	ldw	ra,4(sp)
 108298c:	df000017 	ldw	fp,0(sp)
 1082990:	dec00204 	addi	sp,sp,8
 1082994:	f800283a 	ret

01082998 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
 1082998:	defff504 	addi	sp,sp,-44
 108299c:	dfc00a15 	stw	ra,40(sp)
 10829a0:	df000915 	stw	fp,36(sp)
 10829a4:	df000904 	addi	fp,sp,36
 10829a8:	e13ffc15 	stw	r4,-16(fp)
 10829ac:	e17ffd15 	stw	r5,-12(fp)
 10829b0:	e1bffe15 	stw	r6,-8(fp)
 10829b4:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 10829b8:	e0bffc17 	ldw	r2,-16(fp)
 10829bc:	e0bffb15 	stw	r2,-20(fp)
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 10829c0:	e03ff815 	stw	zero,-32(fp)
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 10829c4:	e0bffb17 	ldw	r2,-20(fp)
 10829c8:	10800703 	ldbu	r2,28(r2)
 10829cc:	10803fcc 	andi	r2,r2,255
 10829d0:	1080004c 	andi	r2,r2,1
 10829d4:	10000326 	beq	r2,zero,10829e4 <xStreamBufferReceive+0x4c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 10829d8:	00800104 	movi	r2,4
 10829dc:	e0bffa15 	stw	r2,-24(fp)
 10829e0:	00000106 	br	10829e8 <xStreamBufferReceive+0x50>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
 10829e4:	e03ffa15 	stw	zero,-24(fp)
	}

	if( xTicksToWait != ( TickType_t ) 0 )
 10829e8:	e0bfff17 	ldw	r2,-4(fp)
 10829ec:	10001c26 	beq	r2,zero,1082a60 <xStreamBufferReceive+0xc8>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
 10829f0:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 10829f4:	e13ffb17 	ldw	r4,-20(fp)
 10829f8:	108311c0 	call	108311c <prvBytesInBuffer>
 10829fc:	e0bff915 	stw	r2,-28(fp)
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
 1082a00:	e0bff917 	ldw	r2,-28(fp)
 1082a04:	e0fffa17 	ldw	r3,-24(fp)
 1082a08:	18800636 	bltu	r3,r2,1082a24 <xStreamBufferReceive+0x8c>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
 1082a0c:	0009883a 	mov	r4,zero
 1082a10:	10855240 	call	1085524 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 1082a14:	10849fc0 	call	10849fc <xTaskGetCurrentTaskHandle>
 1082a18:	1007883a 	mov	r3,r2
 1082a1c:	e0bffb17 	ldw	r2,-20(fp)
 1082a20:	10c00415 	stw	r3,16(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 1082a24:	1084df40 	call	1084df4 <vTaskExitCritical>

		if( xBytesAvailable <= xBytesToStoreMessageLength )
 1082a28:	e0bff917 	ldw	r2,-28(fp)
 1082a2c:	e0fffa17 	ldw	r3,-24(fp)
 1082a30:	18800e36 	bltu	r3,r2,1082a6c <xStreamBufferReceive+0xd4>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 1082a34:	e1ffff17 	ldw	r7,-4(fp)
 1082a38:	000d883a 	mov	r6,zero
 1082a3c:	000b883a 	mov	r5,zero
 1082a40:	0009883a 	mov	r4,zero
 1082a44:	1084f800 	call	1084f80 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
 1082a48:	e0bffb17 	ldw	r2,-20(fp)
 1082a4c:	10000415 	stw	zero,16(r2)

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 1082a50:	e13ffb17 	ldw	r4,-20(fp)
 1082a54:	108311c0 	call	108311c <prvBytesInBuffer>
 1082a58:	e0bff915 	stw	r2,-28(fp)
 1082a5c:	00000306 	br	1082a6c <xStreamBufferReceive+0xd4>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 1082a60:	e13ffb17 	ldw	r4,-20(fp)
 1082a64:	108311c0 	call	108311c <prvBytesInBuffer>
 1082a68:	e0bff915 	stw	r2,-28(fp)
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
 1082a6c:	e0bff917 	ldw	r2,-28(fp)
 1082a70:	e0fffa17 	ldw	r3,-24(fp)
 1082a74:	1880182e 	bgeu	r3,r2,1082ad8 <xStreamBufferReceive+0x140>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
 1082a78:	e0bffa17 	ldw	r2,-24(fp)
 1082a7c:	d8800015 	stw	r2,0(sp)
 1082a80:	e1fff917 	ldw	r7,-28(fp)
 1082a84:	e1bffe17 	ldw	r6,-8(fp)
 1082a88:	e17ffd17 	ldw	r5,-12(fp)
 1082a8c:	e13ffb17 	ldw	r4,-20(fp)
 1082a90:	1082c7c0 	call	1082c7c <prvReadMessageFromBuffer>
 1082a94:	e0bff815 	stw	r2,-32(fp)

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
 1082a98:	e0bff817 	ldw	r2,-32(fp)
 1082a9c:	10000e26 	beq	r2,zero,1082ad8 <xStreamBufferReceive+0x140>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
 1082aa0:	1083e400 	call	1083e40 <vTaskSuspendAll>
 1082aa4:	e0bffb17 	ldw	r2,-20(fp)
 1082aa8:	10800517 	ldw	r2,20(r2)
 1082aac:	10000926 	beq	r2,zero,1082ad4 <xStreamBufferReceive+0x13c>
 1082ab0:	e0bffb17 	ldw	r2,-20(fp)
 1082ab4:	10800517 	ldw	r2,20(r2)
 1082ab8:	000f883a 	mov	r7,zero
 1082abc:	000d883a 	mov	r6,zero
 1082ac0:	000b883a 	mov	r5,zero
 1082ac4:	1009883a 	mov	r4,r2
 1082ac8:	10850740 	call	1085074 <xTaskGenericNotify>
 1082acc:	e0bffb17 	ldw	r2,-20(fp)
 1082ad0:	10000515 	stw	zero,20(r2)
 1082ad4:	1083e6c0 	call	1083e6c <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
 1082ad8:	e0bff817 	ldw	r2,-32(fp)
}
 1082adc:	e037883a 	mov	sp,fp
 1082ae0:	dfc00117 	ldw	ra,4(sp)
 1082ae4:	df000017 	ldw	fp,0(sp)
 1082ae8:	dec00204 	addi	sp,sp,8
 1082aec:	f800283a 	ret

01082af0 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
 1082af0:	defff804 	addi	sp,sp,-32
 1082af4:	dfc00715 	stw	ra,28(sp)
 1082af8:	df000615 	stw	fp,24(sp)
 1082afc:	df000604 	addi	fp,sp,24
 1082b00:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1082b04:	e0bfff17 	ldw	r2,-4(fp)
 1082b08:	e0bffb15 	stw	r2,-20(fp)
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 1082b0c:	e0bffb17 	ldw	r2,-20(fp)
 1082b10:	10800703 	ldbu	r2,28(r2)
 1082b14:	10803fcc 	andi	r2,r2,255
 1082b18:	1080004c 	andi	r2,r2,1
 1082b1c:	10001726 	beq	r2,zero,1082b7c <xStreamBufferNextMessageLengthBytes+0x8c>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 1082b20:	e13ffb17 	ldw	r4,-20(fp)
 1082b24:	108311c0 	call	108311c <prvBytesInBuffer>
 1082b28:	e0bffc15 	stw	r2,-16(fp)
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 1082b2c:	e0bffc17 	ldw	r2,-16(fp)
 1082b30:	10800170 	cmpltui	r2,r2,5
 1082b34:	10000f1e 	bne	r2,zero,1082b74 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
 1082b38:	e0bffb17 	ldw	r2,-20(fp)
 1082b3c:	10800017 	ldw	r2,0(r2)
 1082b40:	e0bffd15 	stw	r2,-12(fp)
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
 1082b44:	e0bffe04 	addi	r2,fp,-8
 1082b48:	e1fffc17 	ldw	r7,-16(fp)
 1082b4c:	01800104 	movi	r6,4
 1082b50:	100b883a 	mov	r5,r2
 1082b54:	e13ffb17 	ldw	r4,-20(fp)
 1082b58:	10830080 	call	1083008 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
 1082b5c:	e0bffe17 	ldw	r2,-8(fp)
 1082b60:	e0bffa15 	stw	r2,-24(fp)
			pxStreamBuffer->xTail = xOriginalTail;
 1082b64:	e0bffb17 	ldw	r2,-20(fp)
 1082b68:	e0fffd17 	ldw	r3,-12(fp)
 1082b6c:	10c00015 	stw	r3,0(r2)
 1082b70:	00000306 	br	1082b80 <xStreamBufferNextMessageLengthBytes+0x90>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
 1082b74:	e03ffa15 	stw	zero,-24(fp)
 1082b78:	00000106 	br	1082b80 <xStreamBufferNextMessageLengthBytes+0x90>
		}
	}
	else
	{
		xReturn = 0;
 1082b7c:	e03ffa15 	stw	zero,-24(fp)
	}

	return xReturn;
 1082b80:	e0bffa17 	ldw	r2,-24(fp)
}
 1082b84:	e037883a 	mov	sp,fp
 1082b88:	dfc00117 	ldw	ra,4(sp)
 1082b8c:	df000017 	ldw	fp,0(sp)
 1082b90:	dec00204 	addi	sp,sp,8
 1082b94:	f800283a 	ret

01082b98 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
 1082b98:	defff404 	addi	sp,sp,-48
 1082b9c:	dfc00b15 	stw	ra,44(sp)
 1082ba0:	df000a15 	stw	fp,40(sp)
 1082ba4:	df000a04 	addi	fp,sp,40
 1082ba8:	e13ffc15 	stw	r4,-16(fp)
 1082bac:	e17ffd15 	stw	r5,-12(fp)
 1082bb0:	e1bffe15 	stw	r6,-8(fp)
 1082bb4:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1082bb8:	e0bffc17 	ldw	r2,-16(fp)
 1082bbc:	e0bff915 	stw	r2,-28(fp)
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 1082bc0:	e03ff715 	stw	zero,-36(fp)
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 1082bc4:	e0bff917 	ldw	r2,-28(fp)
 1082bc8:	10800703 	ldbu	r2,28(r2)
 1082bcc:	10803fcc 	andi	r2,r2,255
 1082bd0:	1080004c 	andi	r2,r2,1
 1082bd4:	10000326 	beq	r2,zero,1082be4 <xStreamBufferReceiveFromISR+0x4c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 1082bd8:	00800104 	movi	r2,4
 1082bdc:	e0bff815 	stw	r2,-32(fp)
 1082be0:	00000106 	br	1082be8 <xStreamBufferReceiveFromISR+0x50>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
 1082be4:	e03ff815 	stw	zero,-32(fp)
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 1082be8:	e13ff917 	ldw	r4,-28(fp)
 1082bec:	108311c0 	call	108311c <prvBytesInBuffer>
 1082bf0:	e0bffa15 	stw	r2,-24(fp)
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
 1082bf4:	e0bffa17 	ldw	r2,-24(fp)
 1082bf8:	e0fff817 	ldw	r3,-32(fp)
 1082bfc:	1880192e 	bgeu	r3,r2,1082c64 <xStreamBufferReceiveFromISR+0xcc>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
 1082c00:	e0bff817 	ldw	r2,-32(fp)
 1082c04:	d8800015 	stw	r2,0(sp)
 1082c08:	e1fffa17 	ldw	r7,-24(fp)
 1082c0c:	e1bffe17 	ldw	r6,-8(fp)
 1082c10:	e17ffd17 	ldw	r5,-12(fp)
 1082c14:	e13ff917 	ldw	r4,-28(fp)
 1082c18:	1082c7c0 	call	1082c7c <prvReadMessageFromBuffer>
 1082c1c:	e0bff715 	stw	r2,-36(fp)

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
 1082c20:	e0bff717 	ldw	r2,-36(fp)
 1082c24:	10000f26 	beq	r2,zero,1082c64 <xStreamBufferReceiveFromISR+0xcc>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 1082c28:	e03ffb15 	stw	zero,-20(fp)
 1082c2c:	e0bff917 	ldw	r2,-28(fp)
 1082c30:	10800517 	ldw	r2,20(r2)
 1082c34:	10000b26 	beq	r2,zero,1082c64 <xStreamBufferReceiveFromISR+0xcc>
 1082c38:	e0bff917 	ldw	r2,-28(fp)
 1082c3c:	10c00517 	ldw	r3,20(r2)
 1082c40:	e0bfff17 	ldw	r2,-4(fp)
 1082c44:	d8800015 	stw	r2,0(sp)
 1082c48:	000f883a 	mov	r7,zero
 1082c4c:	000d883a 	mov	r6,zero
 1082c50:	000b883a 	mov	r5,zero
 1082c54:	1809883a 	mov	r4,r3
 1082c58:	10852200 	call	1085220 <xTaskGenericNotifyFromISR>
 1082c5c:	e0bff917 	ldw	r2,-28(fp)
 1082c60:	10000515 	stw	zero,20(r2)
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
 1082c64:	e0bff717 	ldw	r2,-36(fp)
}
 1082c68:	e037883a 	mov	sp,fp
 1082c6c:	dfc00117 	ldw	ra,4(sp)
 1082c70:	df000017 	ldw	fp,0(sp)
 1082c74:	dec00204 	addi	sp,sp,8
 1082c78:	f800283a 	ret

01082c7c <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
 1082c7c:	defff604 	addi	sp,sp,-40
 1082c80:	dfc00915 	stw	ra,36(sp)
 1082c84:	df000815 	stw	fp,32(sp)
 1082c88:	df000804 	addi	fp,sp,32
 1082c8c:	e13ffc15 	stw	r4,-16(fp)
 1082c90:	e17ffd15 	stw	r5,-12(fp)
 1082c94:	e1bffe15 	stw	r6,-8(fp)
 1082c98:	e1ffff15 	stw	r7,-4(fp)
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
 1082c9c:	e0800217 	ldw	r2,8(fp)
 1082ca0:	10001726 	beq	r2,zero,1082d00 <prvReadMessageFromBuffer+0x84>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
 1082ca4:	e0bffc17 	ldw	r2,-16(fp)
 1082ca8:	10800017 	ldw	r2,0(r2)
 1082cac:	e0bff915 	stw	r2,-28(fp)
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
 1082cb0:	e0bffb04 	addi	r2,fp,-20
 1082cb4:	e1ffff17 	ldw	r7,-4(fp)
 1082cb8:	e1800217 	ldw	r6,8(fp)
 1082cbc:	100b883a 	mov	r5,r2
 1082cc0:	e13ffc17 	ldw	r4,-16(fp)
 1082cc4:	10830080 	call	1083008 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
 1082cc8:	e0bffb17 	ldw	r2,-20(fp)
 1082ccc:	e0bff815 	stw	r2,-32(fp)

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
 1082cd0:	e0ffff17 	ldw	r3,-4(fp)
 1082cd4:	e0800217 	ldw	r2,8(fp)
 1082cd8:	1885c83a 	sub	r2,r3,r2
 1082cdc:	e0bfff15 	stw	r2,-4(fp)

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
 1082ce0:	e0bff817 	ldw	r2,-32(fp)
 1082ce4:	e0fffe17 	ldw	r3,-8(fp)
 1082ce8:	1880072e 	bgeu	r3,r2,1082d08 <prvReadMessageFromBuffer+0x8c>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
 1082cec:	e0bffc17 	ldw	r2,-16(fp)
 1082cf0:	e0fff917 	ldw	r3,-28(fp)
 1082cf4:	10c00015 	stw	r3,0(r2)
			xNextMessageLength = 0;
 1082cf8:	e03ff815 	stw	zero,-32(fp)
 1082cfc:	00000206 	br	1082d08 <prvReadMessageFromBuffer+0x8c>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
 1082d00:	e0bffe17 	ldw	r2,-8(fp)
 1082d04:	e0bff815 	stw	r2,-32(fp)
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
 1082d08:	e1ffff17 	ldw	r7,-4(fp)
 1082d0c:	e1bff817 	ldw	r6,-32(fp)
 1082d10:	e17ffd17 	ldw	r5,-12(fp)
 1082d14:	e13ffc17 	ldw	r4,-16(fp)
 1082d18:	10830080 	call	1083008 <prvReadBytesFromBuffer>
 1082d1c:	e0bffa15 	stw	r2,-24(fp)

	return xReceivedLength;
 1082d20:	e0bffa17 	ldw	r2,-24(fp)
}
 1082d24:	e037883a 	mov	sp,fp
 1082d28:	dfc00117 	ldw	ra,4(sp)
 1082d2c:	df000017 	ldw	fp,0(sp)
 1082d30:	dec00204 	addi	sp,sp,8
 1082d34:	f800283a 	ret

01082d38 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
 1082d38:	defffb04 	addi	sp,sp,-20
 1082d3c:	df000415 	stw	fp,16(sp)
 1082d40:	df000404 	addi	fp,sp,16
 1082d44:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1082d48:	e0bfff17 	ldw	r2,-4(fp)
 1082d4c:	e0bffd15 	stw	r2,-12(fp)
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
 1082d50:	e0bffd17 	ldw	r2,-12(fp)
 1082d54:	10800017 	ldw	r2,0(r2)
 1082d58:	e0bffe15 	stw	r2,-8(fp)
	if( pxStreamBuffer->xHead == xTail )
 1082d5c:	e0bffd17 	ldw	r2,-12(fp)
 1082d60:	10c00117 	ldw	r3,4(r2)
 1082d64:	e0bffe17 	ldw	r2,-8(fp)
 1082d68:	1880031e 	bne	r3,r2,1082d78 <xStreamBufferIsEmpty+0x40>
	{
		xReturn = pdTRUE;
 1082d6c:	00800044 	movi	r2,1
 1082d70:	e0bffc15 	stw	r2,-16(fp)
 1082d74:	00000106 	br	1082d7c <xStreamBufferIsEmpty+0x44>
	}
	else
	{
		xReturn = pdFALSE;
 1082d78:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
 1082d7c:	e0bffc17 	ldw	r2,-16(fp)
}
 1082d80:	e037883a 	mov	sp,fp
 1082d84:	df000017 	ldw	fp,0(sp)
 1082d88:	dec00104 	addi	sp,sp,4
 1082d8c:	f800283a 	ret

01082d90 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
 1082d90:	defffa04 	addi	sp,sp,-24
 1082d94:	dfc00515 	stw	ra,20(sp)
 1082d98:	df000415 	stw	fp,16(sp)
 1082d9c:	df000404 	addi	fp,sp,16
 1082da0:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1082da4:	e0bfff17 	ldw	r2,-4(fp)
 1082da8:	e0bffe15 	stw	r2,-8(fp)

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 1082dac:	e0bffe17 	ldw	r2,-8(fp)
 1082db0:	10800703 	ldbu	r2,28(r2)
 1082db4:	10803fcc 	andi	r2,r2,255
 1082db8:	1080004c 	andi	r2,r2,1
 1082dbc:	10000326 	beq	r2,zero,1082dcc <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 1082dc0:	00800104 	movi	r2,4
 1082dc4:	e0bffd15 	stw	r2,-12(fp)
 1082dc8:	00000106 	br	1082dd0 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
 1082dcc:	e03ffd15 	stw	zero,-12(fp)
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
 1082dd0:	e13fff17 	ldw	r4,-4(fp)
 1082dd4:	10825840 	call	1082584 <xStreamBufferSpacesAvailable>
 1082dd8:	1007883a 	mov	r3,r2
 1082ddc:	e0bffd17 	ldw	r2,-12(fp)
 1082de0:	10c00336 	bltu	r2,r3,1082df0 <xStreamBufferIsFull+0x60>
	{
		xReturn = pdTRUE;
 1082de4:	00800044 	movi	r2,1
 1082de8:	e0bffc15 	stw	r2,-16(fp)
 1082dec:	00000106 	br	1082df4 <xStreamBufferIsFull+0x64>
	}
	else
	{
		xReturn = pdFALSE;
 1082df0:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
 1082df4:	e0bffc17 	ldw	r2,-16(fp)
}
 1082df8:	e037883a 	mov	sp,fp
 1082dfc:	dfc00117 	ldw	ra,4(sp)
 1082e00:	df000017 	ldw	fp,0(sp)
 1082e04:	dec00204 	addi	sp,sp,8
 1082e08:	f800283a 	ret

01082e0c <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
 1082e0c:	defff804 	addi	sp,sp,-32
 1082e10:	dfc00715 	stw	ra,28(sp)
 1082e14:	df000615 	stw	fp,24(sp)
 1082e18:	df000604 	addi	fp,sp,24
 1082e1c:	e13ffe15 	stw	r4,-8(fp)
 1082e20:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1082e24:	e0bffe17 	ldw	r2,-8(fp)
 1082e28:	e0bffc15 	stw	r2,-16(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 1082e2c:	e03ffd15 	stw	zero,-12(fp)
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
 1082e30:	e0bffc17 	ldw	r2,-16(fp)
 1082e34:	10800417 	ldw	r2,16(r2)
 1082e38:	10000e26 	beq	r2,zero,1082e74 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
 1082e3c:	e0bffc17 	ldw	r2,-16(fp)
 1082e40:	10c00417 	ldw	r3,16(r2)
 1082e44:	e0bfff17 	ldw	r2,-4(fp)
 1082e48:	d8800015 	stw	r2,0(sp)
 1082e4c:	000f883a 	mov	r7,zero
 1082e50:	000d883a 	mov	r6,zero
 1082e54:	000b883a 	mov	r5,zero
 1082e58:	1809883a 	mov	r4,r3
 1082e5c:	10852200 	call	1085220 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
 1082e60:	e0bffc17 	ldw	r2,-16(fp)
 1082e64:	10000415 	stw	zero,16(r2)
			xReturn = pdTRUE;
 1082e68:	00800044 	movi	r2,1
 1082e6c:	e0bffb15 	stw	r2,-20(fp)
 1082e70:	00000106 	br	1082e78 <xStreamBufferSendCompletedFromISR+0x6c>
		}
		else
		{
			xReturn = pdFALSE;
 1082e74:	e03ffb15 	stw	zero,-20(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1082e78:	e0bffb17 	ldw	r2,-20(fp)
}
 1082e7c:	e037883a 	mov	sp,fp
 1082e80:	dfc00117 	ldw	ra,4(sp)
 1082e84:	df000017 	ldw	fp,0(sp)
 1082e88:	dec00204 	addi	sp,sp,8
 1082e8c:	f800283a 	ret

01082e90 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
 1082e90:	defff804 	addi	sp,sp,-32
 1082e94:	dfc00715 	stw	ra,28(sp)
 1082e98:	df000615 	stw	fp,24(sp)
 1082e9c:	df000604 	addi	fp,sp,24
 1082ea0:	e13ffe15 	stw	r4,-8(fp)
 1082ea4:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1082ea8:	e0bffe17 	ldw	r2,-8(fp)
 1082eac:	e0bffc15 	stw	r2,-16(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 1082eb0:	e03ffd15 	stw	zero,-12(fp)
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
 1082eb4:	e0bffc17 	ldw	r2,-16(fp)
 1082eb8:	10800517 	ldw	r2,20(r2)
 1082ebc:	10000e26 	beq	r2,zero,1082ef8 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
 1082ec0:	e0bffc17 	ldw	r2,-16(fp)
 1082ec4:	10c00517 	ldw	r3,20(r2)
 1082ec8:	e0bfff17 	ldw	r2,-4(fp)
 1082ecc:	d8800015 	stw	r2,0(sp)
 1082ed0:	000f883a 	mov	r7,zero
 1082ed4:	000d883a 	mov	r6,zero
 1082ed8:	000b883a 	mov	r5,zero
 1082edc:	1809883a 	mov	r4,r3
 1082ee0:	10852200 	call	1085220 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
 1082ee4:	e0bffc17 	ldw	r2,-16(fp)
 1082ee8:	10000515 	stw	zero,20(r2)
			xReturn = pdTRUE;
 1082eec:	00800044 	movi	r2,1
 1082ef0:	e0bffb15 	stw	r2,-20(fp)
 1082ef4:	00000106 	br	1082efc <xStreamBufferReceiveCompletedFromISR+0x6c>
		}
		else
		{
			xReturn = pdFALSE;
 1082ef8:	e03ffb15 	stw	zero,-20(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1082efc:	e0bffb17 	ldw	r2,-20(fp)
}
 1082f00:	e037883a 	mov	sp,fp
 1082f04:	dfc00117 	ldw	ra,4(sp)
 1082f08:	df000017 	ldw	fp,0(sp)
 1082f0c:	dec00204 	addi	sp,sp,8
 1082f10:	f800283a 	ret

01082f14 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
 1082f14:	defff904 	addi	sp,sp,-28
 1082f18:	dfc00615 	stw	ra,24(sp)
 1082f1c:	df000515 	stw	fp,20(sp)
 1082f20:	df000504 	addi	fp,sp,20
 1082f24:	e13ffd15 	stw	r4,-12(fp)
 1082f28:	e17ffe15 	stw	r5,-8(fp)
 1082f2c:	e1bfff15 	stw	r6,-4(fp)
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
 1082f30:	e0bffd17 	ldw	r2,-12(fp)
 1082f34:	10800117 	ldw	r2,4(r2)
 1082f38:	e0bffb15 	stw	r2,-20(fp)

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
 1082f3c:	e0bffd17 	ldw	r2,-12(fp)
 1082f40:	10c00217 	ldw	r3,8(r2)
 1082f44:	e0bffb17 	ldw	r2,-20(fp)
 1082f48:	1885c83a 	sub	r2,r3,r2
 1082f4c:	e0ffff17 	ldw	r3,-4(fp)
 1082f50:	1880012e 	bgeu	r3,r2,1082f58 <prvWriteBytesToBuffer+0x44>
 1082f54:	1805883a 	mov	r2,r3
 1082f58:	e0bffc15 	stw	r2,-16(fp)

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 1082f5c:	e0bffd17 	ldw	r2,-12(fp)
 1082f60:	10c00617 	ldw	r3,24(r2)
 1082f64:	e0bffb17 	ldw	r2,-20(fp)
 1082f68:	1885883a 	add	r2,r3,r2
 1082f6c:	e1bffc17 	ldw	r6,-16(fp)
 1082f70:	e17ffe17 	ldw	r5,-8(fp)
 1082f74:	1009883a 	mov	r4,r2
 1082f78:	108633c0 	call	108633c <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
 1082f7c:	e0bfff17 	ldw	r2,-4(fp)
 1082f80:	e0fffc17 	ldw	r3,-16(fp)
 1082f84:	18800a2e 	bgeu	r3,r2,1082fb0 <prvWriteBytesToBuffer+0x9c>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 1082f88:	e0bffd17 	ldw	r2,-12(fp)
 1082f8c:	11000617 	ldw	r4,24(r2)
 1082f90:	e0fffe17 	ldw	r3,-8(fp)
 1082f94:	e0bffc17 	ldw	r2,-16(fp)
 1082f98:	188b883a 	add	r5,r3,r2
 1082f9c:	e0ffff17 	ldw	r3,-4(fp)
 1082fa0:	e0bffc17 	ldw	r2,-16(fp)
 1082fa4:	1885c83a 	sub	r2,r3,r2
 1082fa8:	100d883a 	mov	r6,r2
 1082fac:	108633c0 	call	108633c <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
 1082fb0:	e0fffb17 	ldw	r3,-20(fp)
 1082fb4:	e0bfff17 	ldw	r2,-4(fp)
 1082fb8:	1885883a 	add	r2,r3,r2
 1082fbc:	e0bffb15 	stw	r2,-20(fp)
	if( xNextHead >= pxStreamBuffer->xLength )
 1082fc0:	e0bffd17 	ldw	r2,-12(fp)
 1082fc4:	10800217 	ldw	r2,8(r2)
 1082fc8:	e0fffb17 	ldw	r3,-20(fp)
 1082fcc:	18800536 	bltu	r3,r2,1082fe4 <prvWriteBytesToBuffer+0xd0>
	{
		xNextHead -= pxStreamBuffer->xLength;
 1082fd0:	e0bffd17 	ldw	r2,-12(fp)
 1082fd4:	10800217 	ldw	r2,8(r2)
 1082fd8:	e0fffb17 	ldw	r3,-20(fp)
 1082fdc:	1885c83a 	sub	r2,r3,r2
 1082fe0:	e0bffb15 	stw	r2,-20(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
 1082fe4:	e0bffd17 	ldw	r2,-12(fp)
 1082fe8:	e0fffb17 	ldw	r3,-20(fp)
 1082fec:	10c00115 	stw	r3,4(r2)

	return xCount;
 1082ff0:	e0bfff17 	ldw	r2,-4(fp)
}
 1082ff4:	e037883a 	mov	sp,fp
 1082ff8:	dfc00117 	ldw	ra,4(sp)
 1082ffc:	df000017 	ldw	fp,0(sp)
 1083000:	dec00204 	addi	sp,sp,8
 1083004:	f800283a 	ret

01083008 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
 1083008:	defff704 	addi	sp,sp,-36
 108300c:	dfc00815 	stw	ra,32(sp)
 1083010:	df000715 	stw	fp,28(sp)
 1083014:	df000704 	addi	fp,sp,28
 1083018:	e13ffc15 	stw	r4,-16(fp)
 108301c:	e17ffd15 	stw	r5,-12(fp)
 1083020:	e1bffe15 	stw	r6,-8(fp)
 1083024:	e1ffff15 	stw	r7,-4(fp)
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
 1083028:	e0ffff17 	ldw	r3,-4(fp)
 108302c:	e0bffe17 	ldw	r2,-8(fp)
 1083030:	1880012e 	bgeu	r3,r2,1083038 <prvReadBytesFromBuffer+0x30>
 1083034:	1805883a 	mov	r2,r3
 1083038:	e0bffa15 	stw	r2,-24(fp)

	if( xCount > ( size_t ) 0 )
 108303c:	e0bffa17 	ldw	r2,-24(fp)
 1083040:	10003026 	beq	r2,zero,1083104 <prvReadBytesFromBuffer+0xfc>
	{
		xNextTail = pxStreamBuffer->xTail;
 1083044:	e0bffc17 	ldw	r2,-16(fp)
 1083048:	10800017 	ldw	r2,0(r2)
 108304c:	e0bff915 	stw	r2,-28(fp)

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
 1083050:	e0bffc17 	ldw	r2,-16(fp)
 1083054:	10c00217 	ldw	r3,8(r2)
 1083058:	e0bff917 	ldw	r2,-28(fp)
 108305c:	1885c83a 	sub	r2,r3,r2
 1083060:	e0fffa17 	ldw	r3,-24(fp)
 1083064:	1880012e 	bgeu	r3,r2,108306c <prvReadBytesFromBuffer+0x64>
 1083068:	1805883a 	mov	r2,r3
 108306c:	e0bffb15 	stw	r2,-20(fp)

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 1083070:	e0bffc17 	ldw	r2,-16(fp)
 1083074:	10c00617 	ldw	r3,24(r2)
 1083078:	e0bff917 	ldw	r2,-28(fp)
 108307c:	1885883a 	add	r2,r3,r2
 1083080:	e1bffb17 	ldw	r6,-20(fp)
 1083084:	100b883a 	mov	r5,r2
 1083088:	e13ffd17 	ldw	r4,-12(fp)
 108308c:	108633c0 	call	108633c <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
 1083090:	e0bffa17 	ldw	r2,-24(fp)
 1083094:	e0fffb17 	ldw	r3,-20(fp)
 1083098:	18800a2e 	bgeu	r3,r2,10830c4 <prvReadBytesFromBuffer+0xbc>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 108309c:	e0fffd17 	ldw	r3,-12(fp)
 10830a0:	e0bffb17 	ldw	r2,-20(fp)
 10830a4:	1889883a 	add	r4,r3,r2
 10830a8:	e0bffc17 	ldw	r2,-16(fp)
 10830ac:	11400617 	ldw	r5,24(r2)
 10830b0:	e0fffa17 	ldw	r3,-24(fp)
 10830b4:	e0bffb17 	ldw	r2,-20(fp)
 10830b8:	1885c83a 	sub	r2,r3,r2
 10830bc:	100d883a 	mov	r6,r2
 10830c0:	108633c0 	call	108633c <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
 10830c4:	e0fff917 	ldw	r3,-28(fp)
 10830c8:	e0bffa17 	ldw	r2,-24(fp)
 10830cc:	1885883a 	add	r2,r3,r2
 10830d0:	e0bff915 	stw	r2,-28(fp)

		if( xNextTail >= pxStreamBuffer->xLength )
 10830d4:	e0bffc17 	ldw	r2,-16(fp)
 10830d8:	10800217 	ldw	r2,8(r2)
 10830dc:	e0fff917 	ldw	r3,-28(fp)
 10830e0:	18800536 	bltu	r3,r2,10830f8 <prvReadBytesFromBuffer+0xf0>
		{
			xNextTail -= pxStreamBuffer->xLength;
 10830e4:	e0bffc17 	ldw	r2,-16(fp)
 10830e8:	10800217 	ldw	r2,8(r2)
 10830ec:	e0fff917 	ldw	r3,-28(fp)
 10830f0:	1885c83a 	sub	r2,r3,r2
 10830f4:	e0bff915 	stw	r2,-28(fp)
		}

		pxStreamBuffer->xTail = xNextTail;
 10830f8:	e0bffc17 	ldw	r2,-16(fp)
 10830fc:	e0fff917 	ldw	r3,-28(fp)
 1083100:	10c00015 	stw	r3,0(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
 1083104:	e0bffa17 	ldw	r2,-24(fp)
}
 1083108:	e037883a 	mov	sp,fp
 108310c:	dfc00117 	ldw	ra,4(sp)
 1083110:	df000017 	ldw	fp,0(sp)
 1083114:	dec00204 	addi	sp,sp,8
 1083118:	f800283a 	ret

0108311c <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
 108311c:	defffd04 	addi	sp,sp,-12
 1083120:	df000215 	stw	fp,8(sp)
 1083124:	df000204 	addi	fp,sp,8
 1083128:	e13fff15 	stw	r4,-4(fp)
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 108312c:	e0bfff17 	ldw	r2,-4(fp)
 1083130:	10c00217 	ldw	r3,8(r2)
 1083134:	e0bfff17 	ldw	r2,-4(fp)
 1083138:	10800117 	ldw	r2,4(r2)
 108313c:	1885883a 	add	r2,r3,r2
 1083140:	e0bffe15 	stw	r2,-8(fp)
	xCount -= pxStreamBuffer->xTail;
 1083144:	e0bfff17 	ldw	r2,-4(fp)
 1083148:	10800017 	ldw	r2,0(r2)
 108314c:	e0fffe17 	ldw	r3,-8(fp)
 1083150:	1885c83a 	sub	r2,r3,r2
 1083154:	e0bffe15 	stw	r2,-8(fp)
	if ( xCount >= pxStreamBuffer->xLength )
 1083158:	e0bfff17 	ldw	r2,-4(fp)
 108315c:	10800217 	ldw	r2,8(r2)
 1083160:	e0fffe17 	ldw	r3,-8(fp)
 1083164:	18800536 	bltu	r3,r2,108317c <prvBytesInBuffer+0x60>
	{
		xCount -= pxStreamBuffer->xLength;
 1083168:	e0bfff17 	ldw	r2,-4(fp)
 108316c:	10800217 	ldw	r2,8(r2)
 1083170:	e0fffe17 	ldw	r3,-8(fp)
 1083174:	1885c83a 	sub	r2,r3,r2
 1083178:	e0bffe15 	stw	r2,-8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
 108317c:	e0bffe17 	ldw	r2,-8(fp)
}
 1083180:	e037883a 	mov	sp,fp
 1083184:	df000017 	ldw	fp,0(sp)
 1083188:	dec00104 	addi	sp,sp,4
 108318c:	f800283a 	ret

01083190 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
 1083190:	defff904 	addi	sp,sp,-28
 1083194:	dfc00615 	stw	ra,24(sp)
 1083198:	df000515 	stw	fp,20(sp)
 108319c:	df000504 	addi	fp,sp,20
 10831a0:	e13ffb15 	stw	r4,-20(fp)
 10831a4:	e17ffc15 	stw	r5,-16(fp)
 10831a8:	e1bffd15 	stw	r6,-12(fp)
 10831ac:	e1fffe15 	stw	r7,-8(fp)
 10831b0:	e0800217 	ldw	r2,8(fp)
 10831b4:	e0bfff05 	stb	r2,-4(fp)
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 10831b8:	01800804 	movi	r6,32
 10831bc:	000b883a 	mov	r5,zero
 10831c0:	e13ffb17 	ldw	r4,-20(fp)
 10831c4:	10863640 	call	1086364 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
 10831c8:	e0bffb17 	ldw	r2,-20(fp)
 10831cc:	e0fffc17 	ldw	r3,-16(fp)
 10831d0:	10c00615 	stw	r3,24(r2)
	pxStreamBuffer->xLength = xBufferSizeBytes;
 10831d4:	e0bffb17 	ldw	r2,-20(fp)
 10831d8:	e0fffd17 	ldw	r3,-12(fp)
 10831dc:	10c00215 	stw	r3,8(r2)
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 10831e0:	e0bffb17 	ldw	r2,-20(fp)
 10831e4:	e0fffe17 	ldw	r3,-8(fp)
 10831e8:	10c00315 	stw	r3,12(r2)
	pxStreamBuffer->ucFlags = ucFlags;
 10831ec:	e0bffb17 	ldw	r2,-20(fp)
 10831f0:	e0ffff03 	ldbu	r3,-4(fp)
 10831f4:	10c00705 	stb	r3,28(r2)
}
 10831f8:	0001883a 	nop
 10831fc:	e037883a 	mov	sp,fp
 1083200:	dfc00117 	ldw	ra,4(sp)
 1083204:	df000017 	ldw	fp,0(sp)
 1083208:	dec00204 	addi	sp,sp,8
 108320c:	f800283a 	ret

01083210 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
 1083210:	defff304 	addi	sp,sp,-52
 1083214:	dfc00c15 	stw	ra,48(sp)
 1083218:	df000b15 	stw	fp,44(sp)
 108321c:	df000b04 	addi	fp,sp,44
 1083220:	e13ffc15 	stw	r4,-16(fp)
 1083224:	e17ffd15 	stw	r5,-12(fp)
 1083228:	3005883a 	mov	r2,r6
 108322c:	e1ffff15 	stw	r7,-4(fp)
 1083230:	e0bffe0d 	sth	r2,-8(fp)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 1083234:	e0bffe0b 	ldhu	r2,-8(fp)
 1083238:	1085883a 	add	r2,r2,r2
 108323c:	1085883a 	add	r2,r2,r2
 1083240:	1009883a 	mov	r4,r2
 1083244:	1080dc80 	call	1080dc8 <pvPortMalloc>
 1083248:	e0bffb15 	stw	r2,-20(fp)

			if( pxStack != NULL )
 108324c:	e0bffb17 	ldw	r2,-20(fp)
 1083250:	10000c26 	beq	r2,zero,1083284 <xTaskCreate+0x74>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 1083254:	01001404 	movi	r4,80
 1083258:	1080dc80 	call	1080dc8 <pvPortMalloc>
 108325c:	e0bff915 	stw	r2,-28(fp)

				if( pxNewTCB != NULL )
 1083260:	e0bff917 	ldw	r2,-28(fp)
 1083264:	10000426 	beq	r2,zero,1083278 <xTaskCreate+0x68>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 1083268:	e0bff917 	ldw	r2,-28(fp)
 108326c:	e0fffb17 	ldw	r3,-20(fp)
 1083270:	10c00c15 	stw	r3,48(r2)
 1083274:	00000406 	br	1083288 <xTaskCreate+0x78>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 1083278:	e13ffb17 	ldw	r4,-20(fp)
 108327c:	1080e880 	call	1080e88 <vPortFree>
 1083280:	00000106 	br	1083288 <xTaskCreate+0x78>
				}
			}
			else
			{
				pxNewTCB = NULL;
 1083284:	e03ff915 	stw	zero,-28(fp)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 1083288:	e0bff917 	ldw	r2,-28(fp)
 108328c:	10001226 	beq	r2,zero,10832d8 <xTaskCreate+0xc8>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 1083290:	e0fffe0b 	ldhu	r3,-8(fp)
 1083294:	d8000315 	stw	zero,12(sp)
 1083298:	e0bff917 	ldw	r2,-28(fp)
 108329c:	d8800215 	stw	r2,8(sp)
 10832a0:	e0800317 	ldw	r2,12(fp)
 10832a4:	d8800115 	stw	r2,4(sp)
 10832a8:	e0800217 	ldw	r2,8(fp)
 10832ac:	d8800015 	stw	r2,0(sp)
 10832b0:	e1ffff17 	ldw	r7,-4(fp)
 10832b4:	180d883a 	mov	r6,r3
 10832b8:	e17ffd17 	ldw	r5,-12(fp)
 10832bc:	e13ffc17 	ldw	r4,-16(fp)
 10832c0:	10832f80 	call	10832f8 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 10832c4:	e13ff917 	ldw	r4,-28(fp)
 10832c8:	10834dc0 	call	10834dc <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 10832cc:	00800044 	movi	r2,1
 10832d0:	e0bffa15 	stw	r2,-24(fp)
 10832d4:	00000206 	br	10832e0 <xTaskCreate+0xd0>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 10832d8:	00bfffc4 	movi	r2,-1
 10832dc:	e0bffa15 	stw	r2,-24(fp)
		}

		return xReturn;
 10832e0:	e0bffa17 	ldw	r2,-24(fp)
	}
 10832e4:	e037883a 	mov	sp,fp
 10832e8:	dfc00117 	ldw	ra,4(sp)
 10832ec:	df000017 	ldw	fp,0(sp)
 10832f0:	dec00204 	addi	sp,sp,8
 10832f4:	f800283a 	ret

010832f8 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
 10832f8:	defff804 	addi	sp,sp,-32
 10832fc:	dfc00715 	stw	ra,28(sp)
 1083300:	df000615 	stw	fp,24(sp)
 1083304:	df000604 	addi	fp,sp,24
 1083308:	e13ffc15 	stw	r4,-16(fp)
 108330c:	e17ffd15 	stw	r5,-12(fp)
 1083310:	e1bffe15 	stw	r6,-8(fp)
 1083314:	e1ffff15 	stw	r7,-4(fp)

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 1083318:	e0800417 	ldw	r2,16(fp)
 108331c:	10c00c17 	ldw	r3,48(r2)
 1083320:	e0bffe17 	ldw	r2,-8(fp)
 1083324:	1085883a 	add	r2,r2,r2
 1083328:	1085883a 	add	r2,r2,r2
 108332c:	100d883a 	mov	r6,r2
 1083330:	01402944 	movi	r5,165
 1083334:	1809883a 	mov	r4,r3
 1083338:	10863640 	call	1086364 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 108333c:	e0800417 	ldw	r2,16(fp)
 1083340:	10c00c17 	ldw	r3,48(r2)
 1083344:	e13ffe17 	ldw	r4,-8(fp)
 1083348:	00900034 	movhi	r2,16384
 108334c:	10bfffc4 	addi	r2,r2,-1
 1083350:	2085883a 	add	r2,r4,r2
 1083354:	1085883a 	add	r2,r2,r2
 1083358:	1085883a 	add	r2,r2,r2
 108335c:	1885883a 	add	r2,r3,r2
 1083360:	e0bffb15 	stw	r2,-20(fp)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 1083364:	e0fffb17 	ldw	r3,-20(fp)
 1083368:	00bfff04 	movi	r2,-4
 108336c:	1884703a 	and	r2,r3,r2
 1083370:	e0bffb15 	stw	r2,-20(fp)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
 1083374:	e0bffd17 	ldw	r2,-12(fp)
 1083378:	10001e26 	beq	r2,zero,10833f4 <prvInitialiseNewTask+0xfc>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 108337c:	e03ffa15 	stw	zero,-24(fp)
 1083380:	00001406 	br	10833d4 <prvInitialiseNewTask+0xdc>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 1083384:	e0fffd17 	ldw	r3,-12(fp)
 1083388:	e0bffa17 	ldw	r2,-24(fp)
 108338c:	1885883a 	add	r2,r3,r2
 1083390:	10c00003 	ldbu	r3,0(r2)
 1083394:	e1000417 	ldw	r4,16(fp)
 1083398:	e0bffa17 	ldw	r2,-24(fp)
 108339c:	2085883a 	add	r2,r4,r2
 10833a0:	10800d04 	addi	r2,r2,52
 10833a4:	10c00005 	stb	r3,0(r2)

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
 10833a8:	e0fffd17 	ldw	r3,-12(fp)
 10833ac:	e0bffa17 	ldw	r2,-24(fp)
 10833b0:	1885883a 	add	r2,r3,r2
 10833b4:	10800003 	ldbu	r2,0(r2)
 10833b8:	10803fcc 	andi	r2,r2,255
 10833bc:	1080201c 	xori	r2,r2,128
 10833c0:	10bfe004 	addi	r2,r2,-128
 10833c4:	10000726 	beq	r2,zero,10833e4 <prvInitialiseNewTask+0xec>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 10833c8:	e0bffa17 	ldw	r2,-24(fp)
 10833cc:	10800044 	addi	r2,r2,1
 10833d0:	e0bffa15 	stw	r2,-24(fp)
 10833d4:	e0bffa17 	ldw	r2,-24(fp)
 10833d8:	10800230 	cmpltui	r2,r2,8
 10833dc:	103fe91e 	bne	r2,zero,1083384 <__alt_data_end+0xfffadc54>
 10833e0:	00000106 	br	10833e8 <prvInitialiseNewTask+0xf0>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
 10833e4:	0001883a 	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 10833e8:	e0800417 	ldw	r2,16(fp)
 10833ec:	10000ec5 	stb	zero,59(r2)
 10833f0:	00000206 	br	10833fc <prvInitialiseNewTask+0x104>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 10833f4:	e0800417 	ldw	r2,16(fp)
 10833f8:	10000d05 	stb	zero,52(r2)
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 10833fc:	e0800217 	ldw	r2,8(fp)
 1083400:	10800170 	cmpltui	r2,r2,5
 1083404:	1000021e 	bne	r2,zero,1083410 <prvInitialiseNewTask+0x118>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1083408:	00800104 	movi	r2,4
 108340c:	e0800215 	stw	r2,8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 1083410:	e0800417 	ldw	r2,16(fp)
 1083414:	e0c00217 	ldw	r3,8(fp)
 1083418:	10c00b15 	stw	r3,44(r2)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 108341c:	e0800417 	ldw	r2,16(fp)
 1083420:	e0c00217 	ldw	r3,8(fp)
 1083424:	10c01015 	stw	r3,64(r2)
		pxNewTCB->uxMutexesHeld = 0;
 1083428:	e0800417 	ldw	r2,16(fp)
 108342c:	10001115 	stw	zero,68(r2)
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 1083430:	e0800417 	ldw	r2,16(fp)
 1083434:	10800104 	addi	r2,r2,4
 1083438:	1009883a 	mov	r4,r2
 108343c:	10807b40 	call	10807b4 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 1083440:	e0800417 	ldw	r2,16(fp)
 1083444:	10800604 	addi	r2,r2,24
 1083448:	1009883a 	mov	r4,r2
 108344c:	10807b40 	call	10807b4 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 1083450:	e0800417 	ldw	r2,16(fp)
 1083454:	e0c00417 	ldw	r3,16(fp)
 1083458:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 108345c:	00c00144 	movi	r3,5
 1083460:	e0800217 	ldw	r2,8(fp)
 1083464:	1887c83a 	sub	r3,r3,r2
 1083468:	e0800417 	ldw	r2,16(fp)
 108346c:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 1083470:	e0800417 	ldw	r2,16(fp)
 1083474:	e0c00417 	ldw	r3,16(fp)
 1083478:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 108347c:	e0800417 	ldw	r2,16(fp)
 1083480:	10000f15 	stw	zero,60(r2)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 1083484:	e0800417 	ldw	r2,16(fp)
 1083488:	10001215 	stw	zero,72(r2)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 108348c:	e0800417 	ldw	r2,16(fp)
 1083490:	10001305 	stb	zero,76(r2)
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 1083494:	e1bfff17 	ldw	r6,-4(fp)
 1083498:	e17ffc17 	ldw	r5,-16(fp)
 108349c:	e13ffb17 	ldw	r4,-20(fp)
 10834a0:	1080a080 	call	1080a08 <pxPortInitialiseStack>
 10834a4:	1007883a 	mov	r3,r2
 10834a8:	e0800417 	ldw	r2,16(fp)
 10834ac:	10c00015 	stw	r3,0(r2)
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
 10834b0:	e0800317 	ldw	r2,12(fp)
 10834b4:	10000326 	beq	r2,zero,10834c4 <prvInitialiseNewTask+0x1cc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 10834b8:	e0800317 	ldw	r2,12(fp)
 10834bc:	e0c00417 	ldw	r3,16(fp)
 10834c0:	10c00015 	stw	r3,0(r2)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 10834c4:	0001883a 	nop
 10834c8:	e037883a 	mov	sp,fp
 10834cc:	dfc00117 	ldw	ra,4(sp)
 10834d0:	df000017 	ldw	fp,0(sp)
 10834d4:	dec00204 	addi	sp,sp,8
 10834d8:	f800283a 	ret

010834dc <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 10834dc:	defffd04 	addi	sp,sp,-12
 10834e0:	dfc00215 	stw	ra,8(sp)
 10834e4:	df000115 	stw	fp,4(sp)
 10834e8:	df000104 	addi	fp,sp,4
 10834ec:	e13fff15 	stw	r4,-4(fp)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 10834f0:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 10834f4:	d0a4d617 	ldw	r2,-27816(gp)
 10834f8:	10800044 	addi	r2,r2,1
 10834fc:	d0a4d615 	stw	r2,-27816(gp)
		if( pxCurrentTCB == NULL )
 1083500:	d0a4d217 	ldw	r2,-27832(gp)
 1083504:	1000071e 	bne	r2,zero,1083524 <prvAddNewTaskToReadyList+0x48>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 1083508:	e0bfff17 	ldw	r2,-4(fp)
 108350c:	d0a4d215 	stw	r2,-27832(gp)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 1083510:	d0a4d617 	ldw	r2,-27816(gp)
 1083514:	10800058 	cmpnei	r2,r2,1
 1083518:	10000b1e 	bne	r2,zero,1083548 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 108351c:	10847680 	call	1084768 <prvInitialiseTaskLists>
 1083520:	00000906 	br	1083548 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 1083524:	d0a4d917 	ldw	r2,-27804(gp)
 1083528:	1000071e 	bne	r2,zero,1083548 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 108352c:	d0a4d217 	ldw	r2,-27832(gp)
 1083530:	10800b17 	ldw	r2,44(r2)
 1083534:	e0ffff17 	ldw	r3,-4(fp)
 1083538:	18c00b17 	ldw	r3,44(r3)
 108353c:	18800236 	bltu	r3,r2,1083548 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
 1083540:	e0bfff17 	ldw	r2,-4(fp)
 1083544:	d0a4d215 	stw	r2,-27832(gp)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 1083548:	d0a4dd17 	ldw	r2,-27788(gp)
 108354c:	10800044 	addi	r2,r2,1
 1083550:	d0a4dd15 	stw	r2,-27788(gp)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 1083554:	e0bfff17 	ldw	r2,-4(fp)
 1083558:	10800b17 	ldw	r2,44(r2)
 108355c:	d0e4d817 	ldw	r3,-27808(gp)
 1083560:	1880032e 	bgeu	r3,r2,1083570 <prvAddNewTaskToReadyList+0x94>
 1083564:	e0bfff17 	ldw	r2,-4(fp)
 1083568:	10800b17 	ldw	r2,44(r2)
 108356c:	d0a4d815 	stw	r2,-27808(gp)
 1083570:	e0bfff17 	ldw	r2,-4(fp)
 1083574:	10800b17 	ldw	r2,44(r2)
 1083578:	10c00524 	muli	r3,r2,20
 108357c:	00804374 	movhi	r2,269
 1083580:	10a0f704 	addi	r2,r2,-31780
 1083584:	1887883a 	add	r3,r3,r2
 1083588:	e0bfff17 	ldw	r2,-4(fp)
 108358c:	10800104 	addi	r2,r2,4
 1083590:	100b883a 	mov	r5,r2
 1083594:	1809883a 	mov	r4,r3
 1083598:	10807e00 	call	10807e0 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 108359c:	1084df40 	call	1084df4 <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
 10835a0:	d0a4d917 	ldw	r2,-27804(gp)
 10835a4:	10000626 	beq	r2,zero,10835c0 <prvAddNewTaskToReadyList+0xe4>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 10835a8:	d0a4d217 	ldw	r2,-27832(gp)
 10835ac:	10c00b17 	ldw	r3,44(r2)
 10835b0:	e0bfff17 	ldw	r2,-4(fp)
 10835b4:	10800b17 	ldw	r2,44(r2)
 10835b8:	1880012e 	bgeu	r3,r2,10835c0 <prvAddNewTaskToReadyList+0xe4>
		{
			taskYIELD_IF_USING_PREEMPTION();
 10835bc:	003b683a 	trap	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 10835c0:	0001883a 	nop
 10835c4:	e037883a 	mov	sp,fp
 10835c8:	dfc00117 	ldw	ra,4(sp)
 10835cc:	df000017 	ldw	fp,0(sp)
 10835d0:	dec00204 	addi	sp,sp,8
 10835d4:	f800283a 	ret

010835d8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
 10835d8:	defffc04 	addi	sp,sp,-16
 10835dc:	dfc00315 	stw	ra,12(sp)
 10835e0:	df000215 	stw	fp,8(sp)
 10835e4:	df000204 	addi	fp,sp,8
 10835e8:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 10835ec:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 10835f0:	e0bfff17 	ldw	r2,-4(fp)
 10835f4:	1000021e 	bne	r2,zero,1083600 <vTaskDelete+0x28>
 10835f8:	d0a4d217 	ldw	r2,-27832(gp)
 10835fc:	00000106 	br	1083604 <vTaskDelete+0x2c>
 1083600:	e0bfff17 	ldw	r2,-4(fp)
 1083604:	e0bffe15 	stw	r2,-8(fp)

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1083608:	e0bffe17 	ldw	r2,-8(fp)
 108360c:	10800104 	addi	r2,r2,4
 1083610:	1009883a 	mov	r4,r2
 1083614:	10809440 	call	1080944 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1083618:	e0bffe17 	ldw	r2,-8(fp)
 108361c:	10800a17 	ldw	r2,40(r2)
 1083620:	10000426 	beq	r2,zero,1083634 <vTaskDelete+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1083624:	e0bffe17 	ldw	r2,-8(fp)
 1083628:	10800604 	addi	r2,r2,24
 108362c:	1009883a 	mov	r4,r2
 1083630:	10809440 	call	1080944 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
 1083634:	d0a4dd17 	ldw	r2,-27788(gp)
 1083638:	10800044 	addi	r2,r2,1
 108363c:	d0a4dd15 	stw	r2,-27788(gp)

			if( pxTCB == pxCurrentTCB )
 1083640:	d0a4d217 	ldw	r2,-27832(gp)
 1083644:	e0fffe17 	ldw	r3,-8(fp)
 1083648:	18800a1e 	bne	r3,r2,1083674 <vTaskDelete+0x9c>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 108364c:	e0bffe17 	ldw	r2,-8(fp)
 1083650:	10800104 	addi	r2,r2,4
 1083654:	100b883a 	mov	r5,r2
 1083658:	01004374 	movhi	r4,269
 108365c:	21211f04 	addi	r4,r4,-31620
 1083660:	10807e00 	call	10807e0 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
 1083664:	d0a4d517 	ldw	r2,-27820(gp)
 1083668:	10800044 	addi	r2,r2,1
 108366c:	d0a4d515 	stw	r2,-27820(gp)
 1083670:	00000606 	br	108368c <vTaskDelete+0xb4>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
 1083674:	d0a4d617 	ldw	r2,-27816(gp)
 1083678:	10bfffc4 	addi	r2,r2,-1
 108367c:	d0a4d615 	stw	r2,-27816(gp)
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
 1083680:	e13ffe17 	ldw	r4,-8(fp)
 1083684:	10849640 	call	1084964 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
 1083688:	10849a80 	call	10849a8 <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
 108368c:	1084df40 	call	1084df4 <vTaskExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
 1083690:	d0a4d917 	ldw	r2,-27804(gp)
 1083694:	10000426 	beq	r2,zero,10836a8 <vTaskDelete+0xd0>
		{
			if( pxTCB == pxCurrentTCB )
 1083698:	d0a4d217 	ldw	r2,-27832(gp)
 108369c:	e0fffe17 	ldw	r3,-8(fp)
 10836a0:	1880011e 	bne	r3,r2,10836a8 <vTaskDelete+0xd0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 10836a4:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 10836a8:	0001883a 	nop
 10836ac:	e037883a 	mov	sp,fp
 10836b0:	dfc00117 	ldw	ra,4(sp)
 10836b4:	df000017 	ldw	fp,0(sp)
 10836b8:	dec00204 	addi	sp,sp,8
 10836bc:	f800283a 	ret

010836c0 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 10836c0:	defff804 	addi	sp,sp,-32
 10836c4:	dfc00715 	stw	ra,28(sp)
 10836c8:	df000615 	stw	fp,24(sp)
 10836cc:	df000604 	addi	fp,sp,24
 10836d0:	e13ffe15 	stw	r4,-8(fp)
 10836d4:	e17fff15 	stw	r5,-4(fp)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 10836d8:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 10836dc:	1083e400 	call	1083e40 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 10836e0:	d0a4d717 	ldw	r2,-27812(gp)
 10836e4:	e0bffb15 	stw	r2,-20(fp)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 10836e8:	e0bffe17 	ldw	r2,-8(fp)
 10836ec:	10c00017 	ldw	r3,0(r2)
 10836f0:	e0bfff17 	ldw	r2,-4(fp)
 10836f4:	1885883a 	add	r2,r3,r2
 10836f8:	e0bffc15 	stw	r2,-16(fp)

			if( xConstTickCount < *pxPreviousWakeTime )
 10836fc:	e0bffe17 	ldw	r2,-8(fp)
 1083700:	10800017 	ldw	r2,0(r2)
 1083704:	e0fffb17 	ldw	r3,-20(fp)
 1083708:	18800a2e 	bgeu	r3,r2,1083734 <vTaskDelayUntil+0x74>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 108370c:	e0bffe17 	ldw	r2,-8(fp)
 1083710:	10800017 	ldw	r2,0(r2)
 1083714:	e0fffc17 	ldw	r3,-16(fp)
 1083718:	18800f2e 	bgeu	r3,r2,1083758 <vTaskDelayUntil+0x98>
 108371c:	e0bffc17 	ldw	r2,-16(fp)
 1083720:	e0fffb17 	ldw	r3,-20(fp)
 1083724:	18800c2e 	bgeu	r3,r2,1083758 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 1083728:	00800044 	movi	r2,1
 108372c:	e0bffa15 	stw	r2,-24(fp)
 1083730:	00000906 	br	1083758 <vTaskDelayUntil+0x98>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 1083734:	e0bffe17 	ldw	r2,-8(fp)
 1083738:	10800017 	ldw	r2,0(r2)
 108373c:	e0fffc17 	ldw	r3,-16(fp)
 1083740:	18800336 	bltu	r3,r2,1083750 <vTaskDelayUntil+0x90>
 1083744:	e0bffc17 	ldw	r2,-16(fp)
 1083748:	e0fffb17 	ldw	r3,-20(fp)
 108374c:	1880022e 	bgeu	r3,r2,1083758 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 1083750:	00800044 	movi	r2,1
 1083754:	e0bffa15 	stw	r2,-24(fp)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 1083758:	e0bffe17 	ldw	r2,-8(fp)
 108375c:	e0fffc17 	ldw	r3,-16(fp)
 1083760:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
 1083764:	e0bffa17 	ldw	r2,-24(fp)
 1083768:	10000626 	beq	r2,zero,1083784 <vTaskDelayUntil+0xc4>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 108376c:	e0fffc17 	ldw	r3,-16(fp)
 1083770:	e0bffb17 	ldw	r2,-20(fp)
 1083774:	1885c83a 	sub	r2,r3,r2
 1083778:	000b883a 	mov	r5,zero
 108377c:	1009883a 	mov	r4,r2
 1083780:	10856140 	call	1085614 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 1083784:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 1083788:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 108378c:	e0bffd17 	ldw	r2,-12(fp)
 1083790:	1000011e 	bne	r2,zero,1083798 <vTaskDelayUntil+0xd8>
		{
			portYIELD_WITHIN_API();
 1083794:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1083798:	0001883a 	nop
 108379c:	e037883a 	mov	sp,fp
 10837a0:	dfc00117 	ldw	ra,4(sp)
 10837a4:	df000017 	ldw	fp,0(sp)
 10837a8:	dec00204 	addi	sp,sp,8
 10837ac:	f800283a 	ret

010837b0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 10837b0:	defffc04 	addi	sp,sp,-16
 10837b4:	dfc00315 	stw	ra,12(sp)
 10837b8:	df000215 	stw	fp,8(sp)
 10837bc:	df000204 	addi	fp,sp,8
 10837c0:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xAlreadyYielded = pdFALSE;
 10837c4:	e03ffe15 	stw	zero,-8(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 10837c8:	e0bfff17 	ldw	r2,-4(fp)
 10837cc:	10000626 	beq	r2,zero,10837e8 <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 10837d0:	1083e400 	call	1083e40 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 10837d4:	000b883a 	mov	r5,zero
 10837d8:	e13fff17 	ldw	r4,-4(fp)
 10837dc:	10856140 	call	1085614 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 10837e0:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 10837e4:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 10837e8:	e0bffe17 	ldw	r2,-8(fp)
 10837ec:	1000011e 	bne	r2,zero,10837f4 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
 10837f0:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 10837f4:	0001883a 	nop
 10837f8:	e037883a 	mov	sp,fp
 10837fc:	dfc00117 	ldw	ra,4(sp)
 1083800:	df000017 	ldw	fp,0(sp)
 1083804:	dec00204 	addi	sp,sp,8
 1083808:	f800283a 	ret

0108380c <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
 108380c:	defffb04 	addi	sp,sp,-20
 1083810:	dfc00415 	stw	ra,16(sp)
 1083814:	df000315 	stw	fp,12(sp)
 1083818:	df000304 	addi	fp,sp,12
 108381c:	e13fff15 	stw	r4,-4(fp)
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
 1083820:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 1083824:	e0bfff17 	ldw	r2,-4(fp)
 1083828:	1000021e 	bne	r2,zero,1083834 <uxTaskPriorityGet+0x28>
 108382c:	d0a4d217 	ldw	r2,-27832(gp)
 1083830:	00000106 	br	1083838 <uxTaskPriorityGet+0x2c>
 1083834:	e0bfff17 	ldw	r2,-4(fp)
 1083838:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 108383c:	e0bffd17 	ldw	r2,-12(fp)
 1083840:	10800b17 	ldw	r2,44(r2)
 1083844:	e0bffe15 	stw	r2,-8(fp)
		}
		taskEXIT_CRITICAL();
 1083848:	1084df40 	call	1084df4 <vTaskExitCritical>

		return uxReturn;
 108384c:	e0bffe17 	ldw	r2,-8(fp)
	}
 1083850:	e037883a 	mov	sp,fp
 1083854:	dfc00117 	ldw	ra,4(sp)
 1083858:	df000017 	ldw	fp,0(sp)
 108385c:	dec00204 	addi	sp,sp,8
 1083860:	f800283a 	ret

01083864 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
 1083864:	defffb04 	addi	sp,sp,-20
 1083868:	df000415 	stw	fp,16(sp)
 108386c:	df000404 	addi	fp,sp,16
 1083870:	e13fff15 	stw	r4,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 1083874:	e03ffc15 	stw	zero,-16(fp)
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 1083878:	e0bfff17 	ldw	r2,-4(fp)
 108387c:	1000021e 	bne	r2,zero,1083888 <uxTaskPriorityGetFromISR+0x24>
 1083880:	d0a4d217 	ldw	r2,-27832(gp)
 1083884:	00000106 	br	108388c <uxTaskPriorityGetFromISR+0x28>
 1083888:	e0bfff17 	ldw	r2,-4(fp)
 108388c:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 1083890:	e0bffd17 	ldw	r2,-12(fp)
 1083894:	10800b17 	ldw	r2,44(r2)
 1083898:	e0bffe15 	stw	r2,-8(fp)
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
 108389c:	e0bffe17 	ldw	r2,-8(fp)
	}
 10838a0:	e037883a 	mov	sp,fp
 10838a4:	df000017 	ldw	fp,0(sp)
 10838a8:	dec00104 	addi	sp,sp,4
 10838ac:	f800283a 	ret

010838b0 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
 10838b0:	defff804 	addi	sp,sp,-32
 10838b4:	dfc00715 	stw	ra,28(sp)
 10838b8:	df000615 	stw	fp,24(sp)
 10838bc:	df000604 	addi	fp,sp,24
 10838c0:	e13ffe15 	stw	r4,-8(fp)
 10838c4:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
 10838c8:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 10838cc:	e0bfff17 	ldw	r2,-4(fp)
 10838d0:	10800170 	cmpltui	r2,r2,5
 10838d4:	1000021e 	bne	r2,zero,10838e0 <vTaskPrioritySet+0x30>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 10838d8:	00800104 	movi	r2,4
 10838dc:	e0bfff15 	stw	r2,-4(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
 10838e0:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 10838e4:	e0bffe17 	ldw	r2,-8(fp)
 10838e8:	1000021e 	bne	r2,zero,10838f4 <vTaskPrioritySet+0x44>
 10838ec:	d0a4d217 	ldw	r2,-27832(gp)
 10838f0:	00000106 	br	10838f8 <vTaskPrioritySet+0x48>
 10838f4:	e0bffe17 	ldw	r2,-8(fp)
 10838f8:	e0bffb15 	stw	r2,-20(fp)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 10838fc:	e0bffb17 	ldw	r2,-20(fp)
 1083900:	10801017 	ldw	r2,64(r2)
 1083904:	e0bffc15 	stw	r2,-16(fp)
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
 1083908:	e0fffc17 	ldw	r3,-16(fp)
 108390c:	e0bfff17 	ldw	r2,-4(fp)
 1083910:	18804926 	beq	r3,r2,1083a38 <vTaskPrioritySet+0x188>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
 1083914:	e0bfff17 	ldw	r2,-4(fp)
 1083918:	e0fffc17 	ldw	r3,-16(fp)
 108391c:	18800a2e 	bgeu	r3,r2,1083948 <vTaskPrioritySet+0x98>
				{
					if( pxTCB != pxCurrentTCB )
 1083920:	d0a4d217 	ldw	r2,-27832(gp)
 1083924:	e0fffb17 	ldw	r3,-20(fp)
 1083928:	18800c26 	beq	r3,r2,108395c <vTaskPrioritySet+0xac>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 108392c:	d0a4d217 	ldw	r2,-27832(gp)
 1083930:	10800b17 	ldw	r2,44(r2)
 1083934:	e0ffff17 	ldw	r3,-4(fp)
 1083938:	18800836 	bltu	r3,r2,108395c <vTaskPrioritySet+0xac>
						{
							xYieldRequired = pdTRUE;
 108393c:	00800044 	movi	r2,1
 1083940:	e0bffa15 	stw	r2,-24(fp)
 1083944:	00000506 	br	108395c <vTaskPrioritySet+0xac>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
 1083948:	d0a4d217 	ldw	r2,-27832(gp)
 108394c:	e0fffb17 	ldw	r3,-20(fp)
 1083950:	1880021e 	bne	r3,r2,108395c <vTaskPrioritySet+0xac>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
 1083954:	00800044 	movi	r2,1
 1083958:	e0bffa15 	stw	r2,-24(fp)
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 108395c:	e0bffb17 	ldw	r2,-20(fp)
 1083960:	10800b17 	ldw	r2,44(r2)
 1083964:	e0bffd15 	stw	r2,-12(fp)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 1083968:	e0bffb17 	ldw	r2,-20(fp)
 108396c:	10c01017 	ldw	r3,64(r2)
 1083970:	e0bffb17 	ldw	r2,-20(fp)
 1083974:	10800b17 	ldw	r2,44(r2)
 1083978:	1880031e 	bne	r3,r2,1083988 <vTaskPrioritySet+0xd8>
					{
						pxTCB->uxPriority = uxNewPriority;
 108397c:	e0bffb17 	ldw	r2,-20(fp)
 1083980:	e0ffff17 	ldw	r3,-4(fp)
 1083984:	10c00b15 	stw	r3,44(r2)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 1083988:	e0bffb17 	ldw	r2,-20(fp)
 108398c:	e0ffff17 	ldw	r3,-4(fp)
 1083990:	10c01015 	stw	r3,64(r2)
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 1083994:	e0bffb17 	ldw	r2,-20(fp)
 1083998:	10800617 	ldw	r2,24(r2)
 108399c:	10000516 	blt	r2,zero,10839b4 <vTaskPrioritySet+0x104>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 10839a0:	00c00144 	movi	r3,5
 10839a4:	e0bfff17 	ldw	r2,-4(fp)
 10839a8:	1887c83a 	sub	r3,r3,r2
 10839ac:	e0bffb17 	ldw	r2,-20(fp)
 10839b0:	10c00615 	stw	r3,24(r2)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 10839b4:	e0bffb17 	ldw	r2,-20(fp)
 10839b8:	10c00517 	ldw	r3,20(r2)
 10839bc:	e0bffd17 	ldw	r2,-12(fp)
 10839c0:	11000524 	muli	r4,r2,20
 10839c4:	00804374 	movhi	r2,269
 10839c8:	10a0f704 	addi	r2,r2,-31780
 10839cc:	2085883a 	add	r2,r4,r2
 10839d0:	1880161e 	bne	r3,r2,1083a2c <vTaskPrioritySet+0x17c>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 10839d4:	e0bffb17 	ldw	r2,-20(fp)
 10839d8:	10800104 	addi	r2,r2,4
 10839dc:	1009883a 	mov	r4,r2
 10839e0:	10809440 	call	1080944 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
 10839e4:	e0bffb17 	ldw	r2,-20(fp)
 10839e8:	10800b17 	ldw	r2,44(r2)
 10839ec:	d0e4d817 	ldw	r3,-27808(gp)
 10839f0:	1880032e 	bgeu	r3,r2,1083a00 <vTaskPrioritySet+0x150>
 10839f4:	e0bffb17 	ldw	r2,-20(fp)
 10839f8:	10800b17 	ldw	r2,44(r2)
 10839fc:	d0a4d815 	stw	r2,-27808(gp)
 1083a00:	e0bffb17 	ldw	r2,-20(fp)
 1083a04:	10800b17 	ldw	r2,44(r2)
 1083a08:	10c00524 	muli	r3,r2,20
 1083a0c:	00804374 	movhi	r2,269
 1083a10:	10a0f704 	addi	r2,r2,-31780
 1083a14:	1887883a 	add	r3,r3,r2
 1083a18:	e0bffb17 	ldw	r2,-20(fp)
 1083a1c:	10800104 	addi	r2,r2,4
 1083a20:	100b883a 	mov	r5,r2
 1083a24:	1809883a 	mov	r4,r3
 1083a28:	10807e00 	call	10807e0 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
 1083a2c:	e0bffa17 	ldw	r2,-24(fp)
 1083a30:	10000126 	beq	r2,zero,1083a38 <vTaskPrioritySet+0x188>
				{
					taskYIELD_IF_USING_PREEMPTION();
 1083a34:	003b683a 	trap	0
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
 1083a38:	1084df40 	call	1084df4 <vTaskExitCritical>
	}
 1083a3c:	0001883a 	nop
 1083a40:	e037883a 	mov	sp,fp
 1083a44:	dfc00117 	ldw	ra,4(sp)
 1083a48:	df000017 	ldw	fp,0(sp)
 1083a4c:	dec00204 	addi	sp,sp,8
 1083a50:	f800283a 	ret

01083a54 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 1083a54:	defffc04 	addi	sp,sp,-16
 1083a58:	dfc00315 	stw	ra,12(sp)
 1083a5c:	df000215 	stw	fp,8(sp)
 1083a60:	df000204 	addi	fp,sp,8
 1083a64:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 1083a68:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1083a6c:	e0bfff17 	ldw	r2,-4(fp)
 1083a70:	1000021e 	bne	r2,zero,1083a7c <vTaskSuspend+0x28>
 1083a74:	d0a4d217 	ldw	r2,-27832(gp)
 1083a78:	00000106 	br	1083a80 <vTaskSuspend+0x2c>
 1083a7c:	e0bfff17 	ldw	r2,-4(fp)
 1083a80:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1083a84:	e0bffe17 	ldw	r2,-8(fp)
 1083a88:	10800104 	addi	r2,r2,4
 1083a8c:	1009883a 	mov	r4,r2
 1083a90:	10809440 	call	1080944 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1083a94:	e0bffe17 	ldw	r2,-8(fp)
 1083a98:	10800a17 	ldw	r2,40(r2)
 1083a9c:	10000426 	beq	r2,zero,1083ab0 <vTaskSuspend+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1083aa0:	e0bffe17 	ldw	r2,-8(fp)
 1083aa4:	10800604 	addi	r2,r2,24
 1083aa8:	1009883a 	mov	r4,r2
 1083aac:	10809440 	call	1080944 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 1083ab0:	e0bffe17 	ldw	r2,-8(fp)
 1083ab4:	10800104 	addi	r2,r2,4
 1083ab8:	100b883a 	mov	r5,r2
 1083abc:	01004374 	movhi	r4,269
 1083ac0:	21212404 	addi	r4,r4,-31600
 1083ac4:	10807e00 	call	10807e0 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 1083ac8:	e0bffe17 	ldw	r2,-8(fp)
 1083acc:	10801303 	ldbu	r2,76(r2)
 1083ad0:	10803fcc 	andi	r2,r2,255
 1083ad4:	10800058 	cmpnei	r2,r2,1
 1083ad8:	1000021e 	bne	r2,zero,1083ae4 <vTaskSuspend+0x90>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1083adc:	e0bffe17 	ldw	r2,-8(fp)
 1083ae0:	10001305 	stb	zero,76(r2)
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
 1083ae4:	1084df40 	call	1084df4 <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
 1083ae8:	d0a4d917 	ldw	r2,-27804(gp)
 1083aec:	10000326 	beq	r2,zero,1083afc <vTaskSuspend+0xa8>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
 1083af0:	1084da00 	call	1084da0 <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
 1083af4:	10849a80 	call	10849a8 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
 1083af8:	1084df40 	call	1084df4 <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
 1083afc:	d0a4d217 	ldw	r2,-27832(gp)
 1083b00:	e0fffe17 	ldw	r3,-8(fp)
 1083b04:	18800c1e 	bne	r3,r2,1083b38 <vTaskSuspend+0xe4>
		{
			if( xSchedulerRunning != pdFALSE )
 1083b08:	d0a4d917 	ldw	r2,-27804(gp)
 1083b0c:	10000226 	beq	r2,zero,1083b18 <vTaskSuspend+0xc4>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 1083b10:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1083b14:	00000806 	br	1083b38 <vTaskSuspend+0xe4>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 1083b18:	00804374 	movhi	r2,269
 1083b1c:	10a12404 	addi	r2,r2,-31600
 1083b20:	10c00017 	ldw	r3,0(r2)
 1083b24:	d0a4d617 	ldw	r2,-27816(gp)
 1083b28:	1880021e 	bne	r3,r2,1083b34 <vTaskSuspend+0xe0>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 1083b2c:	d024d215 	stw	zero,-27832(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1083b30:	00000106 	br	1083b38 <vTaskSuspend+0xe4>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
 1083b34:	10842740 	call	1084274 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1083b38:	0001883a 	nop
 1083b3c:	e037883a 	mov	sp,fp
 1083b40:	dfc00117 	ldw	ra,4(sp)
 1083b44:	df000017 	ldw	fp,0(sp)
 1083b48:	dec00204 	addi	sp,sp,8
 1083b4c:	f800283a 	ret

01083b50 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
 1083b50:	defffc04 	addi	sp,sp,-16
 1083b54:	df000315 	stw	fp,12(sp)
 1083b58:	df000304 	addi	fp,sp,12
 1083b5c:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xReturn = pdFALSE;
 1083b60:	e03ffd15 	stw	zero,-12(fp)
	const TCB_t * const pxTCB = xTask;
 1083b64:	e0bfff17 	ldw	r2,-4(fp)
 1083b68:	e0bffe15 	stw	r2,-8(fp)

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 1083b6c:	e0bffe17 	ldw	r2,-8(fp)
 1083b70:	10c00517 	ldw	r3,20(r2)
 1083b74:	00804374 	movhi	r2,269
 1083b78:	10a12404 	addi	r2,r2,-31600
 1083b7c:	18800a1e 	bne	r3,r2,1083ba8 <prvTaskIsTaskSuspended+0x58>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1083b80:	e0bffe17 	ldw	r2,-8(fp)
 1083b84:	10c00a17 	ldw	r3,40(r2)
 1083b88:	00804374 	movhi	r2,269
 1083b8c:	10a11a04 	addi	r2,r2,-31640
 1083b90:	18800526 	beq	r3,r2,1083ba8 <prvTaskIsTaskSuspended+0x58>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 1083b94:	e0bffe17 	ldw	r2,-8(fp)
 1083b98:	10800a17 	ldw	r2,40(r2)
 1083b9c:	1000021e 	bne	r2,zero,1083ba8 <prvTaskIsTaskSuspended+0x58>
				{
					xReturn = pdTRUE;
 1083ba0:	00800044 	movi	r2,1
 1083ba4:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 1083ba8:	e0bffd17 	ldw	r2,-12(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1083bac:	e037883a 	mov	sp,fp
 1083bb0:	df000017 	ldw	fp,0(sp)
 1083bb4:	dec00104 	addi	sp,sp,4
 1083bb8:	f800283a 	ret

01083bbc <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
 1083bbc:	defffc04 	addi	sp,sp,-16
 1083bc0:	dfc00315 	stw	ra,12(sp)
 1083bc4:	df000215 	stw	fp,8(sp)
 1083bc8:	df000204 	addi	fp,sp,8
 1083bcc:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = xTaskToResume;
 1083bd0:	e0bfff17 	ldw	r2,-4(fp)
 1083bd4:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 1083bd8:	d0a4d217 	ldw	r2,-27832(gp)
 1083bdc:	e0fffe17 	ldw	r3,-8(fp)
 1083be0:	18802326 	beq	r3,r2,1083c70 <vTaskResume+0xb4>
 1083be4:	e0bffe17 	ldw	r2,-8(fp)
 1083be8:	10002126 	beq	r2,zero,1083c70 <vTaskResume+0xb4>
		{
			taskENTER_CRITICAL();
 1083bec:	1084da00 	call	1084da0 <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1083bf0:	e13ffe17 	ldw	r4,-8(fp)
 1083bf4:	1083b500 	call	1083b50 <prvTaskIsTaskSuspended>
 1083bf8:	10001c26 	beq	r2,zero,1083c6c <vTaskResume+0xb0>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 1083bfc:	e0bffe17 	ldw	r2,-8(fp)
 1083c00:	10800104 	addi	r2,r2,4
 1083c04:	1009883a 	mov	r4,r2
 1083c08:	10809440 	call	1080944 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1083c0c:	e0bffe17 	ldw	r2,-8(fp)
 1083c10:	10800b17 	ldw	r2,44(r2)
 1083c14:	d0e4d817 	ldw	r3,-27808(gp)
 1083c18:	1880032e 	bgeu	r3,r2,1083c28 <vTaskResume+0x6c>
 1083c1c:	e0bffe17 	ldw	r2,-8(fp)
 1083c20:	10800b17 	ldw	r2,44(r2)
 1083c24:	d0a4d815 	stw	r2,-27808(gp)
 1083c28:	e0bffe17 	ldw	r2,-8(fp)
 1083c2c:	10800b17 	ldw	r2,44(r2)
 1083c30:	10c00524 	muli	r3,r2,20
 1083c34:	00804374 	movhi	r2,269
 1083c38:	10a0f704 	addi	r2,r2,-31780
 1083c3c:	1887883a 	add	r3,r3,r2
 1083c40:	e0bffe17 	ldw	r2,-8(fp)
 1083c44:	10800104 	addi	r2,r2,4
 1083c48:	100b883a 	mov	r5,r2
 1083c4c:	1809883a 	mov	r4,r3
 1083c50:	10807e00 	call	10807e0 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1083c54:	e0bffe17 	ldw	r2,-8(fp)
 1083c58:	10c00b17 	ldw	r3,44(r2)
 1083c5c:	d0a4d217 	ldw	r2,-27832(gp)
 1083c60:	10800b17 	ldw	r2,44(r2)
 1083c64:	18800136 	bltu	r3,r2,1083c6c <vTaskResume+0xb0>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
 1083c68:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 1083c6c:	1084df40 	call	1084df4 <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1083c70:	0001883a 	nop
 1083c74:	e037883a 	mov	sp,fp
 1083c78:	dfc00117 	ldw	ra,4(sp)
 1083c7c:	df000017 	ldw	fp,0(sp)
 1083c80:	dec00204 	addi	sp,sp,8
 1083c84:	f800283a 	ret

01083c88 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
 1083c88:	defffa04 	addi	sp,sp,-24
 1083c8c:	dfc00515 	stw	ra,20(sp)
 1083c90:	df000415 	stw	fp,16(sp)
 1083c94:	df000404 	addi	fp,sp,16
 1083c98:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xYieldRequired = pdFALSE;
 1083c9c:	e03ffc15 	stw	zero,-16(fp)
	TCB_t * const pxTCB = xTaskToResume;
 1083ca0:	e0bfff17 	ldw	r2,-4(fp)
 1083ca4:	e0bffd15 	stw	r2,-12(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1083ca8:	e03ffe15 	stw	zero,-8(fp)
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1083cac:	e13ffd17 	ldw	r4,-12(fp)
 1083cb0:	1083b500 	call	1083b50 <prvTaskIsTaskSuspended>
 1083cb4:	10002626 	beq	r2,zero,1083d50 <xTaskResumeFromISR+0xc8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1083cb8:	d0a4e017 	ldw	r2,-27776(gp)
 1083cbc:	10001e1e 	bne	r2,zero,1083d38 <xTaskResumeFromISR+0xb0>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1083cc0:	e0bffd17 	ldw	r2,-12(fp)
 1083cc4:	10c00b17 	ldw	r3,44(r2)
 1083cc8:	d0a4d217 	ldw	r2,-27832(gp)
 1083ccc:	10800b17 	ldw	r2,44(r2)
 1083cd0:	18800236 	bltu	r3,r2,1083cdc <xTaskResumeFromISR+0x54>
					{
						xYieldRequired = pdTRUE;
 1083cd4:	00800044 	movi	r2,1
 1083cd8:	e0bffc15 	stw	r2,-16(fp)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1083cdc:	e0bffd17 	ldw	r2,-12(fp)
 1083ce0:	10800104 	addi	r2,r2,4
 1083ce4:	1009883a 	mov	r4,r2
 1083ce8:	10809440 	call	1080944 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1083cec:	e0bffd17 	ldw	r2,-12(fp)
 1083cf0:	10800b17 	ldw	r2,44(r2)
 1083cf4:	d0e4d817 	ldw	r3,-27808(gp)
 1083cf8:	1880032e 	bgeu	r3,r2,1083d08 <xTaskResumeFromISR+0x80>
 1083cfc:	e0bffd17 	ldw	r2,-12(fp)
 1083d00:	10800b17 	ldw	r2,44(r2)
 1083d04:	d0a4d815 	stw	r2,-27808(gp)
 1083d08:	e0bffd17 	ldw	r2,-12(fp)
 1083d0c:	10800b17 	ldw	r2,44(r2)
 1083d10:	10c00524 	muli	r3,r2,20
 1083d14:	00804374 	movhi	r2,269
 1083d18:	10a0f704 	addi	r2,r2,-31780
 1083d1c:	1887883a 	add	r3,r3,r2
 1083d20:	e0bffd17 	ldw	r2,-12(fp)
 1083d24:	10800104 	addi	r2,r2,4
 1083d28:	100b883a 	mov	r5,r2
 1083d2c:	1809883a 	mov	r4,r3
 1083d30:	10807e00 	call	10807e0 <vListInsertEnd>
 1083d34:	00000606 	br	1083d50 <xTaskResumeFromISR+0xc8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1083d38:	e0bffd17 	ldw	r2,-12(fp)
 1083d3c:	10800604 	addi	r2,r2,24
 1083d40:	100b883a 	mov	r5,r2
 1083d44:	01004374 	movhi	r4,269
 1083d48:	21211a04 	addi	r4,r4,-31640
 1083d4c:	10807e00 	call	10807e0 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
 1083d50:	e0bffc17 	ldw	r2,-16(fp)
	}
 1083d54:	e037883a 	mov	sp,fp
 1083d58:	dfc00117 	ldw	ra,4(sp)
 1083d5c:	df000017 	ldw	fp,0(sp)
 1083d60:	dec00204 	addi	sp,sp,8
 1083d64:	f800283a 	ret

01083d68 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 1083d68:	defffa04 	addi	sp,sp,-24
 1083d6c:	dfc00515 	stw	ra,20(sp)
 1083d70:	df000415 	stw	fp,16(sp)
 1083d74:	df000404 	addi	fp,sp,16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 1083d78:	d0a4df04 	addi	r2,gp,-27780
 1083d7c:	d8800115 	stw	r2,4(sp)
 1083d80:	d8000015 	stw	zero,0(sp)
 1083d84:	000f883a 	mov	r7,zero
 1083d88:	01810004 	movi	r6,1024
 1083d8c:	01404274 	movhi	r5,265
 1083d90:	2962d904 	addi	r5,r5,-29852
 1083d94:	01004234 	movhi	r4,264
 1083d98:	2111d304 	addi	r4,r4,18252
 1083d9c:	10832100 	call	1083210 <xTaskCreate>
 1083da0:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 1083da4:	e0bffe17 	ldw	r2,-8(fp)
 1083da8:	10800058 	cmpnei	r2,r2,1
 1083dac:	10000c1e 	bne	r2,zero,1083de0 <vTaskStartScheduler+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1083db0:	0005303a 	rdctl	r2,status
 1083db4:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1083db8:	e0ffff17 	ldw	r3,-4(fp)
 1083dbc:	00bfff84 	movi	r2,-2
 1083dc0:	1884703a 	and	r2,r3,r2
 1083dc4:	1001703a 	wrctl	status,r2
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 1083dc8:	00bfffc4 	movi	r2,-1
 1083dcc:	d0a4de15 	stw	r2,-27784(gp)
		xSchedulerRunning = pdTRUE;
 1083dd0:	00800044 	movi	r2,1
 1083dd4:	d0a4d915 	stw	r2,-27804(gp)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 1083dd8:	d024d715 	stw	zero,-27812(gp)

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 1083ddc:	1080ae80 	call	1080ae8 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 1083de0:	0001883a 	nop
 1083de4:	e037883a 	mov	sp,fp
 1083de8:	dfc00117 	ldw	ra,4(sp)
 1083dec:	df000017 	ldw	fp,0(sp)
 1083df0:	dec00204 	addi	sp,sp,8
 1083df4:	f800283a 	ret

01083df8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 1083df8:	defffd04 	addi	sp,sp,-12
 1083dfc:	dfc00215 	stw	ra,8(sp)
 1083e00:	df000115 	stw	fp,4(sp)
 1083e04:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1083e08:	0005303a 	rdctl	r2,status
 1083e0c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1083e10:	e0ffff17 	ldw	r3,-4(fp)
 1083e14:	00bfff84 	movi	r2,-2
 1083e18:	1884703a 	and	r2,r3,r2
 1083e1c:	1001703a 	wrctl	status,r2
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
 1083e20:	d024d915 	stw	zero,-27804(gp)
	vPortEndScheduler();
 1083e24:	1080b200 	call	1080b20 <vPortEndScheduler>
}
 1083e28:	0001883a 	nop
 1083e2c:	e037883a 	mov	sp,fp
 1083e30:	dfc00117 	ldw	ra,4(sp)
 1083e34:	df000017 	ldw	fp,0(sp)
 1083e38:	dec00204 	addi	sp,sp,8
 1083e3c:	f800283a 	ret

01083e40 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 1083e40:	deffff04 	addi	sp,sp,-4
 1083e44:	df000015 	stw	fp,0(sp)
 1083e48:	d839883a 	mov	fp,sp
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
 1083e4c:	d0a4e017 	ldw	r2,-27776(gp)
 1083e50:	10800044 	addi	r2,r2,1
 1083e54:	d0a4e015 	stw	r2,-27776(gp)

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
 1083e58:	0001883a 	nop
 1083e5c:	e037883a 	mov	sp,fp
 1083e60:	df000017 	ldw	fp,0(sp)
 1083e64:	dec00104 	addi	sp,sp,4
 1083e68:	f800283a 	ret

01083e6c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 1083e6c:	defffb04 	addi	sp,sp,-20
 1083e70:	dfc00415 	stw	ra,16(sp)
 1083e74:	df000315 	stw	fp,12(sp)
 1083e78:	df000304 	addi	fp,sp,12
TCB_t *pxTCB = NULL;
 1083e7c:	e03ffd15 	stw	zero,-12(fp)
BaseType_t xAlreadyYielded = pdFALSE;
 1083e80:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 1083e84:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
 1083e88:	d0a4e017 	ldw	r2,-27776(gp)
 1083e8c:	10bfffc4 	addi	r2,r2,-1
 1083e90:	d0a4e015 	stw	r2,-27776(gp)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1083e94:	d0a4e017 	ldw	r2,-27776(gp)
 1083e98:	1000431e 	bne	r2,zero,1083fa8 <xTaskResumeAll+0x13c>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 1083e9c:	d0a4d617 	ldw	r2,-27816(gp)
 1083ea0:	10004126 	beq	r2,zero,1083fa8 <xTaskResumeAll+0x13c>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1083ea4:	00002606 	br	1083f40 <xTaskResumeAll+0xd4>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1083ea8:	00804374 	movhi	r2,269
 1083eac:	10a11a04 	addi	r2,r2,-31640
 1083eb0:	10800317 	ldw	r2,12(r2)
 1083eb4:	10800317 	ldw	r2,12(r2)
 1083eb8:	e0bffd15 	stw	r2,-12(fp)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1083ebc:	e0bffd17 	ldw	r2,-12(fp)
 1083ec0:	10800604 	addi	r2,r2,24
 1083ec4:	1009883a 	mov	r4,r2
 1083ec8:	10809440 	call	1080944 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1083ecc:	e0bffd17 	ldw	r2,-12(fp)
 1083ed0:	10800104 	addi	r2,r2,4
 1083ed4:	1009883a 	mov	r4,r2
 1083ed8:	10809440 	call	1080944 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1083edc:	e0bffd17 	ldw	r2,-12(fp)
 1083ee0:	10800b17 	ldw	r2,44(r2)
 1083ee4:	d0e4d817 	ldw	r3,-27808(gp)
 1083ee8:	1880032e 	bgeu	r3,r2,1083ef8 <xTaskResumeAll+0x8c>
 1083eec:	e0bffd17 	ldw	r2,-12(fp)
 1083ef0:	10800b17 	ldw	r2,44(r2)
 1083ef4:	d0a4d815 	stw	r2,-27808(gp)
 1083ef8:	e0bffd17 	ldw	r2,-12(fp)
 1083efc:	10800b17 	ldw	r2,44(r2)
 1083f00:	10c00524 	muli	r3,r2,20
 1083f04:	00804374 	movhi	r2,269
 1083f08:	10a0f704 	addi	r2,r2,-31780
 1083f0c:	1887883a 	add	r3,r3,r2
 1083f10:	e0bffd17 	ldw	r2,-12(fp)
 1083f14:	10800104 	addi	r2,r2,4
 1083f18:	100b883a 	mov	r5,r2
 1083f1c:	1809883a 	mov	r4,r3
 1083f20:	10807e00 	call	10807e0 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1083f24:	e0bffd17 	ldw	r2,-12(fp)
 1083f28:	10c00b17 	ldw	r3,44(r2)
 1083f2c:	d0a4d217 	ldw	r2,-27832(gp)
 1083f30:	10800b17 	ldw	r2,44(r2)
 1083f34:	18800236 	bltu	r3,r2,1083f40 <xTaskResumeAll+0xd4>
					{
						xYieldPending = pdTRUE;
 1083f38:	00800044 	movi	r2,1
 1083f3c:	d0a4db15 	stw	r2,-27796(gp)
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1083f40:	00804374 	movhi	r2,269
 1083f44:	10a11a04 	addi	r2,r2,-31640
 1083f48:	10800017 	ldw	r2,0(r2)
 1083f4c:	103fd61e 	bne	r2,zero,1083ea8 <__alt_data_end+0xfffae778>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 1083f50:	e0bffd17 	ldw	r2,-12(fp)
 1083f54:	10000126 	beq	r2,zero,1083f5c <xTaskResumeAll+0xf0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 1083f58:	10849a80 	call	10849a8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 1083f5c:	d0a4da17 	ldw	r2,-27800(gp)
 1083f60:	e0bfff15 	stw	r2,-4(fp)

					if( xPendedCounts > ( TickType_t ) 0U )
 1083f64:	e0bfff17 	ldw	r2,-4(fp)
 1083f68:	10000a26 	beq	r2,zero,1083f94 <xTaskResumeAll+0x128>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 1083f6c:	10840c40 	call	10840c4 <xTaskIncrementTick>
 1083f70:	10000226 	beq	r2,zero,1083f7c <xTaskResumeAll+0x110>
							{
								xYieldPending = pdTRUE;
 1083f74:	00800044 	movi	r2,1
 1083f78:	d0a4db15 	stw	r2,-27796(gp)
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
 1083f7c:	e0bfff17 	ldw	r2,-4(fp)
 1083f80:	10bfffc4 	addi	r2,r2,-1
 1083f84:	e0bfff15 	stw	r2,-4(fp)
						} while( xPendedCounts > ( TickType_t ) 0U );
 1083f88:	e0bfff17 	ldw	r2,-4(fp)
 1083f8c:	103ff71e 	bne	r2,zero,1083f6c <__alt_data_end+0xfffae83c>

						xPendedTicks = 0;
 1083f90:	d024da15 	stw	zero,-27800(gp)
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 1083f94:	d0a4db17 	ldw	r2,-27796(gp)
 1083f98:	10000326 	beq	r2,zero,1083fa8 <xTaskResumeAll+0x13c>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 1083f9c:	00800044 	movi	r2,1
 1083fa0:	e0bffe15 	stw	r2,-8(fp)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 1083fa4:	003b683a 	trap	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 1083fa8:	1084df40 	call	1084df4 <vTaskExitCritical>

	return xAlreadyYielded;
 1083fac:	e0bffe17 	ldw	r2,-8(fp)
}
 1083fb0:	e037883a 	mov	sp,fp
 1083fb4:	dfc00117 	ldw	ra,4(sp)
 1083fb8:	df000017 	ldw	fp,0(sp)
 1083fbc:	dec00204 	addi	sp,sp,8
 1083fc0:	f800283a 	ret

01083fc4 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 1083fc4:	defffe04 	addi	sp,sp,-8
 1083fc8:	df000115 	stw	fp,4(sp)
 1083fcc:	df000104 	addi	fp,sp,4
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 1083fd0:	d0a4d717 	ldw	r2,-27812(gp)
 1083fd4:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 1083fd8:	e0bfff17 	ldw	r2,-4(fp)
}
 1083fdc:	e037883a 	mov	sp,fp
 1083fe0:	df000017 	ldw	fp,0(sp)
 1083fe4:	dec00104 	addi	sp,sp,4
 1083fe8:	f800283a 	ret

01083fec <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 1083fec:	defffd04 	addi	sp,sp,-12
 1083ff0:	df000215 	stw	fp,8(sp)
 1083ff4:	df000204 	addi	fp,sp,8
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 1083ff8:	e03ffe15 	stw	zero,-8(fp)
	{
		xReturn = xTickCount;
 1083ffc:	d0a4d717 	ldw	r2,-27812(gp)
 1084000:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1084004:	e0bfff17 	ldw	r2,-4(fp)
}
 1084008:	e037883a 	mov	sp,fp
 108400c:	df000017 	ldw	fp,0(sp)
 1084010:	dec00104 	addi	sp,sp,4
 1084014:	f800283a 	ret

01084018 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 1084018:	deffff04 	addi	sp,sp,-4
 108401c:	df000015 	stw	fp,0(sp)
 1084020:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
 1084024:	d0a4d617 	ldw	r2,-27816(gp)
}
 1084028:	e037883a 	mov	sp,fp
 108402c:	df000017 	ldw	fp,0(sp)
 1084030:	dec00104 	addi	sp,sp,4
 1084034:	f800283a 	ret

01084038 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 1084038:	defffd04 	addi	sp,sp,-12
 108403c:	df000215 	stw	fp,8(sp)
 1084040:	df000204 	addi	fp,sp,8
 1084044:	e13fff15 	stw	r4,-4(fp)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 1084048:	e0bfff17 	ldw	r2,-4(fp)
 108404c:	1000021e 	bne	r2,zero,1084058 <pcTaskGetName+0x20>
 1084050:	d0a4d217 	ldw	r2,-27832(gp)
 1084054:	00000106 	br	108405c <pcTaskGetName+0x24>
 1084058:	e0bfff17 	ldw	r2,-4(fp)
 108405c:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
 1084060:	e0bffe17 	ldw	r2,-8(fp)
 1084064:	10800d04 	addi	r2,r2,52
}
 1084068:	e037883a 	mov	sp,fp
 108406c:	df000017 	ldw	fp,0(sp)
 1084070:	dec00104 	addi	sp,sp,4
 1084074:	f800283a 	ret

01084078 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
 1084078:	defffc04 	addi	sp,sp,-16
 108407c:	dfc00315 	stw	ra,12(sp)
 1084080:	df000215 	stw	fp,8(sp)
 1084084:	df000204 	addi	fp,sp,8
 1084088:	e13fff15 	stw	r4,-4(fp)
BaseType_t xYieldRequired = pdFALSE;
 108408c:	e03ffe15 	stw	zero,-8(fp)
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
 1084090:	1083e400 	call	1083e40 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
 1084094:	d0e4da17 	ldw	r3,-27800(gp)
 1084098:	e0bfff17 	ldw	r2,-4(fp)
 108409c:	1885883a 	add	r2,r3,r2
 10840a0:	d0a4da15 	stw	r2,-27800(gp)
	xYieldRequired = xTaskResumeAll();
 10840a4:	1083e6c0 	call	1083e6c <xTaskResumeAll>
 10840a8:	e0bffe15 	stw	r2,-8(fp)

	return xYieldRequired;
 10840ac:	e0bffe17 	ldw	r2,-8(fp)
}
 10840b0:	e037883a 	mov	sp,fp
 10840b4:	dfc00117 	ldw	ra,4(sp)
 10840b8:	df000017 	ldw	fp,0(sp)
 10840bc:	dec00204 	addi	sp,sp,8
 10840c0:	f800283a 	ret

010840c4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 10840c4:	defff904 	addi	sp,sp,-28
 10840c8:	dfc00615 	stw	ra,24(sp)
 10840cc:	df000515 	stw	fp,20(sp)
 10840d0:	df000504 	addi	fp,sp,20
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 10840d4:	e03ffb15 	stw	zero,-20(fp)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 10840d8:	d0a4e017 	ldw	r2,-27776(gp)
 10840dc:	10005c1e 	bne	r2,zero,1084250 <xTaskIncrementTick+0x18c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 10840e0:	d0a4d717 	ldw	r2,-27812(gp)
 10840e4:	10800044 	addi	r2,r2,1
 10840e8:	e0bffc15 	stw	r2,-16(fp)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 10840ec:	e0bffc17 	ldw	r2,-16(fp)
 10840f0:	d0a4d715 	stw	r2,-27812(gp)

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 10840f4:	e0bffc17 	ldw	r2,-16(fp)
 10840f8:	10000a1e 	bne	r2,zero,1084124 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
 10840fc:	d0a4d317 	ldw	r2,-27828(gp)
 1084100:	e0bffd15 	stw	r2,-12(fp)
 1084104:	d0a4d417 	ldw	r2,-27824(gp)
 1084108:	d0a4d315 	stw	r2,-27828(gp)
 108410c:	e0bffd17 	ldw	r2,-12(fp)
 1084110:	d0a4d415 	stw	r2,-27824(gp)
 1084114:	d0a4dc17 	ldw	r2,-27792(gp)
 1084118:	10800044 	addi	r2,r2,1
 108411c:	d0a4dc15 	stw	r2,-27792(gp)
 1084120:	10849a80 	call	10849a8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 1084124:	d0a4de17 	ldw	r2,-27784(gp)
 1084128:	e0fffc17 	ldw	r3,-16(fp)
 108412c:	18803836 	bltu	r3,r2,1084210 <xTaskIncrementTick+0x14c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1084130:	d0a4d317 	ldw	r2,-27828(gp)
 1084134:	10800017 	ldw	r2,0(r2)
 1084138:	1000031e 	bne	r2,zero,1084148 <xTaskIncrementTick+0x84>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 108413c:	00bfffc4 	movi	r2,-1
 1084140:	d0a4de15 	stw	r2,-27784(gp)
					break;
 1084144:	00003206 	br	1084210 <xTaskIncrementTick+0x14c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1084148:	d0a4d317 	ldw	r2,-27828(gp)
 108414c:	10800317 	ldw	r2,12(r2)
 1084150:	10800317 	ldw	r2,12(r2)
 1084154:	e0bffe15 	stw	r2,-8(fp)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1084158:	e0bffe17 	ldw	r2,-8(fp)
 108415c:	10800117 	ldw	r2,4(r2)
 1084160:	e0bfff15 	stw	r2,-4(fp)

					if( xConstTickCount < xItemValue )
 1084164:	e0fffc17 	ldw	r3,-16(fp)
 1084168:	e0bfff17 	ldw	r2,-4(fp)
 108416c:	1880032e 	bgeu	r3,r2,108417c <xTaskIncrementTick+0xb8>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 1084170:	e0bfff17 	ldw	r2,-4(fp)
 1084174:	d0a4de15 	stw	r2,-27784(gp)
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 1084178:	00002506 	br	1084210 <xTaskIncrementTick+0x14c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 108417c:	e0bffe17 	ldw	r2,-8(fp)
 1084180:	10800104 	addi	r2,r2,4
 1084184:	1009883a 	mov	r4,r2
 1084188:	10809440 	call	1080944 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 108418c:	e0bffe17 	ldw	r2,-8(fp)
 1084190:	10800a17 	ldw	r2,40(r2)
 1084194:	10000426 	beq	r2,zero,10841a8 <xTaskIncrementTick+0xe4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1084198:	e0bffe17 	ldw	r2,-8(fp)
 108419c:	10800604 	addi	r2,r2,24
 10841a0:	1009883a 	mov	r4,r2
 10841a4:	10809440 	call	1080944 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 10841a8:	e0bffe17 	ldw	r2,-8(fp)
 10841ac:	10800b17 	ldw	r2,44(r2)
 10841b0:	d0e4d817 	ldw	r3,-27808(gp)
 10841b4:	1880032e 	bgeu	r3,r2,10841c4 <xTaskIncrementTick+0x100>
 10841b8:	e0bffe17 	ldw	r2,-8(fp)
 10841bc:	10800b17 	ldw	r2,44(r2)
 10841c0:	d0a4d815 	stw	r2,-27808(gp)
 10841c4:	e0bffe17 	ldw	r2,-8(fp)
 10841c8:	10800b17 	ldw	r2,44(r2)
 10841cc:	10c00524 	muli	r3,r2,20
 10841d0:	00804374 	movhi	r2,269
 10841d4:	10a0f704 	addi	r2,r2,-31780
 10841d8:	1887883a 	add	r3,r3,r2
 10841dc:	e0bffe17 	ldw	r2,-8(fp)
 10841e0:	10800104 	addi	r2,r2,4
 10841e4:	100b883a 	mov	r5,r2
 10841e8:	1809883a 	mov	r4,r3
 10841ec:	10807e00 	call	10807e0 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 10841f0:	e0bffe17 	ldw	r2,-8(fp)
 10841f4:	10c00b17 	ldw	r3,44(r2)
 10841f8:	d0a4d217 	ldw	r2,-27832(gp)
 10841fc:	10800b17 	ldw	r2,44(r2)
 1084200:	18bfcb36 	bltu	r3,r2,1084130 <__alt_data_end+0xfffaea00>
						{
							xSwitchRequired = pdTRUE;
 1084204:	00800044 	movi	r2,1
 1084208:	e0bffb15 	stw	r2,-20(fp)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
 108420c:	003fc806 	br	1084130 <__alt_data_end+0xfffaea00>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 1084210:	d0a4d217 	ldw	r2,-27832(gp)
 1084214:	10c00b17 	ldw	r3,44(r2)
 1084218:	00804374 	movhi	r2,269
 108421c:	10a0f704 	addi	r2,r2,-31780
 1084220:	18c00524 	muli	r3,r3,20
 1084224:	10c5883a 	add	r2,r2,r3
 1084228:	10800017 	ldw	r2,0(r2)
 108422c:	108000b0 	cmpltui	r2,r2,2
 1084230:	1000021e 	bne	r2,zero,108423c <xTaskIncrementTick+0x178>
			{
				xSwitchRequired = pdTRUE;
 1084234:	00800044 	movi	r2,1
 1084238:	e0bffb15 	stw	r2,-20(fp)
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
 108423c:	d0a4db17 	ldw	r2,-27796(gp)
 1084240:	10000626 	beq	r2,zero,108425c <xTaskIncrementTick+0x198>
			{
				xSwitchRequired = pdTRUE;
 1084244:	00800044 	movi	r2,1
 1084248:	e0bffb15 	stw	r2,-20(fp)
 108424c:	00000306 	br	108425c <xTaskIncrementTick+0x198>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
 1084250:	d0a4da17 	ldw	r2,-27800(gp)
 1084254:	10800044 	addi	r2,r2,1
 1084258:	d0a4da15 	stw	r2,-27800(gp)
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
 108425c:	e0bffb17 	ldw	r2,-20(fp)
}
 1084260:	e037883a 	mov	sp,fp
 1084264:	dfc00117 	ldw	ra,4(sp)
 1084268:	df000017 	ldw	fp,0(sp)
 108426c:	dec00204 	addi	sp,sp,8
 1084270:	f800283a 	ret

01084274 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 1084274:	defffd04 	addi	sp,sp,-12
 1084278:	df000215 	stw	fp,8(sp)
 108427c:	df000204 	addi	fp,sp,8
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 1084280:	d0a4e017 	ldw	r2,-27776(gp)
 1084284:	10000326 	beq	r2,zero,1084294 <vTaskSwitchContext+0x20>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 1084288:	00800044 	movi	r2,1
 108428c:	d0a4db15 	stw	r2,-27796(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 1084290:	00002906 	br	1084338 <vTaskSwitchContext+0xc4>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 1084294:	d024db15 	stw	zero,-27796(gp)
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1084298:	d0a4d817 	ldw	r2,-27808(gp)
 108429c:	e0bffe15 	stw	r2,-8(fp)
 10842a0:	00000306 	br	10842b0 <vTaskSwitchContext+0x3c>
 10842a4:	e0bffe17 	ldw	r2,-8(fp)
 10842a8:	10bfffc4 	addi	r2,r2,-1
 10842ac:	e0bffe15 	stw	r2,-8(fp)
 10842b0:	00804374 	movhi	r2,269
 10842b4:	10a0f704 	addi	r2,r2,-31780
 10842b8:	e0fffe17 	ldw	r3,-8(fp)
 10842bc:	18c00524 	muli	r3,r3,20
 10842c0:	10c5883a 	add	r2,r2,r3
 10842c4:	10800017 	ldw	r2,0(r2)
 10842c8:	103ff626 	beq	r2,zero,10842a4 <__alt_data_end+0xfffaeb74>
 10842cc:	e0bffe17 	ldw	r2,-8(fp)
 10842d0:	10c00524 	muli	r3,r2,20
 10842d4:	00804374 	movhi	r2,269
 10842d8:	10a0f704 	addi	r2,r2,-31780
 10842dc:	1885883a 	add	r2,r3,r2
 10842e0:	e0bfff15 	stw	r2,-4(fp)
 10842e4:	e0bfff17 	ldw	r2,-4(fp)
 10842e8:	10800117 	ldw	r2,4(r2)
 10842ec:	10c00117 	ldw	r3,4(r2)
 10842f0:	e0bfff17 	ldw	r2,-4(fp)
 10842f4:	10c00115 	stw	r3,4(r2)
 10842f8:	e0bfff17 	ldw	r2,-4(fp)
 10842fc:	10c00117 	ldw	r3,4(r2)
 1084300:	e0bfff17 	ldw	r2,-4(fp)
 1084304:	10800204 	addi	r2,r2,8
 1084308:	1880051e 	bne	r3,r2,1084320 <vTaskSwitchContext+0xac>
 108430c:	e0bfff17 	ldw	r2,-4(fp)
 1084310:	10800117 	ldw	r2,4(r2)
 1084314:	10c00117 	ldw	r3,4(r2)
 1084318:	e0bfff17 	ldw	r2,-4(fp)
 108431c:	10c00115 	stw	r3,4(r2)
 1084320:	e0bfff17 	ldw	r2,-4(fp)
 1084324:	10800117 	ldw	r2,4(r2)
 1084328:	10800317 	ldw	r2,12(r2)
 108432c:	d0a4d215 	stw	r2,-27832(gp)
 1084330:	e0bffe17 	ldw	r2,-8(fp)
 1084334:	d0a4d815 	stw	r2,-27808(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 1084338:	0001883a 	nop
 108433c:	e037883a 	mov	sp,fp
 1084340:	df000017 	ldw	fp,0(sp)
 1084344:	dec00104 	addi	sp,sp,4
 1084348:	f800283a 	ret

0108434c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 108434c:	defffc04 	addi	sp,sp,-16
 1084350:	dfc00315 	stw	ra,12(sp)
 1084354:	df000215 	stw	fp,8(sp)
 1084358:	df000204 	addi	fp,sp,8
 108435c:	e13ffe15 	stw	r4,-8(fp)
 1084360:	e17fff15 	stw	r5,-4(fp)

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 1084364:	d0a4d217 	ldw	r2,-27832(gp)
 1084368:	10800604 	addi	r2,r2,24
 108436c:	100b883a 	mov	r5,r2
 1084370:	e13ffe17 	ldw	r4,-8(fp)
 1084374:	108086c0 	call	108086c <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 1084378:	01400044 	movi	r5,1
 108437c:	e13fff17 	ldw	r4,-4(fp)
 1084380:	10856140 	call	1085614 <prvAddCurrentTaskToDelayedList>
}
 1084384:	0001883a 	nop
 1084388:	e037883a 	mov	sp,fp
 108438c:	dfc00117 	ldw	ra,4(sp)
 1084390:	df000017 	ldw	fp,0(sp)
 1084394:	dec00204 	addi	sp,sp,8
 1084398:	f800283a 	ret

0108439c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
 108439c:	defffb04 	addi	sp,sp,-20
 10843a0:	dfc00415 	stw	ra,16(sp)
 10843a4:	df000315 	stw	fp,12(sp)
 10843a8:	df000304 	addi	fp,sp,12
 10843ac:	e13ffd15 	stw	r4,-12(fp)
 10843b0:	e17ffe15 	stw	r5,-8(fp)
 10843b4:	e1bfff15 	stw	r6,-4(fp)
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 10843b8:	d0a4d217 	ldw	r2,-27832(gp)
 10843bc:	e0fffe17 	ldw	r3,-8(fp)
 10843c0:	18e00034 	orhi	r3,r3,32768
 10843c4:	10c00615 	stw	r3,24(r2)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 10843c8:	d0a4d217 	ldw	r2,-27832(gp)
 10843cc:	10800604 	addi	r2,r2,24
 10843d0:	100b883a 	mov	r5,r2
 10843d4:	e13ffd17 	ldw	r4,-12(fp)
 10843d8:	10807e00 	call	10807e0 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 10843dc:	01400044 	movi	r5,1
 10843e0:	e13fff17 	ldw	r4,-4(fp)
 10843e4:	10856140 	call	1085614 <prvAddCurrentTaskToDelayedList>
}
 10843e8:	0001883a 	nop
 10843ec:	e037883a 	mov	sp,fp
 10843f0:	dfc00117 	ldw	ra,4(sp)
 10843f4:	df000017 	ldw	fp,0(sp)
 10843f8:	dec00204 	addi	sp,sp,8
 10843fc:	f800283a 	ret

01084400 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 1084400:	defffb04 	addi	sp,sp,-20
 1084404:	dfc00415 	stw	ra,16(sp)
 1084408:	df000315 	stw	fp,12(sp)
 108440c:	df000304 	addi	fp,sp,12
 1084410:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1084414:	e0bfff17 	ldw	r2,-4(fp)
 1084418:	10800317 	ldw	r2,12(r2)
 108441c:	10800317 	ldw	r2,12(r2)
 1084420:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 1084424:	e0bffe17 	ldw	r2,-8(fp)
 1084428:	10800604 	addi	r2,r2,24
 108442c:	1009883a 	mov	r4,r2
 1084430:	10809440 	call	1080944 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1084434:	d0a4e017 	ldw	r2,-27776(gp)
 1084438:	1000171e 	bne	r2,zero,1084498 <xTaskRemoveFromEventList+0x98>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 108443c:	e0bffe17 	ldw	r2,-8(fp)
 1084440:	10800104 	addi	r2,r2,4
 1084444:	1009883a 	mov	r4,r2
 1084448:	10809440 	call	1080944 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 108444c:	e0bffe17 	ldw	r2,-8(fp)
 1084450:	10800b17 	ldw	r2,44(r2)
 1084454:	d0e4d817 	ldw	r3,-27808(gp)
 1084458:	1880032e 	bgeu	r3,r2,1084468 <xTaskRemoveFromEventList+0x68>
 108445c:	e0bffe17 	ldw	r2,-8(fp)
 1084460:	10800b17 	ldw	r2,44(r2)
 1084464:	d0a4d815 	stw	r2,-27808(gp)
 1084468:	e0bffe17 	ldw	r2,-8(fp)
 108446c:	10800b17 	ldw	r2,44(r2)
 1084470:	10c00524 	muli	r3,r2,20
 1084474:	00804374 	movhi	r2,269
 1084478:	10a0f704 	addi	r2,r2,-31780
 108447c:	1887883a 	add	r3,r3,r2
 1084480:	e0bffe17 	ldw	r2,-8(fp)
 1084484:	10800104 	addi	r2,r2,4
 1084488:	100b883a 	mov	r5,r2
 108448c:	1809883a 	mov	r4,r3
 1084490:	10807e00 	call	10807e0 <vListInsertEnd>
 1084494:	00000606 	br	10844b0 <xTaskRemoveFromEventList+0xb0>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 1084498:	e0bffe17 	ldw	r2,-8(fp)
 108449c:	10800604 	addi	r2,r2,24
 10844a0:	100b883a 	mov	r5,r2
 10844a4:	01004374 	movhi	r4,269
 10844a8:	21211a04 	addi	r4,r4,-31640
 10844ac:	10807e00 	call	10807e0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 10844b0:	e0bffe17 	ldw	r2,-8(fp)
 10844b4:	10800b17 	ldw	r2,44(r2)
 10844b8:	d0e4d217 	ldw	r3,-27832(gp)
 10844bc:	18c00b17 	ldw	r3,44(r3)
 10844c0:	1880052e 	bgeu	r3,r2,10844d8 <xTaskRemoveFromEventList+0xd8>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 10844c4:	00800044 	movi	r2,1
 10844c8:	e0bffd15 	stw	r2,-12(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 10844cc:	00800044 	movi	r2,1
 10844d0:	d0a4db15 	stw	r2,-27796(gp)
 10844d4:	00000106 	br	10844dc <xTaskRemoveFromEventList+0xdc>
	}
	else
	{
		xReturn = pdFALSE;
 10844d8:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 10844dc:	e0bffd17 	ldw	r2,-12(fp)
}
 10844e0:	e037883a 	mov	sp,fp
 10844e4:	dfc00117 	ldw	ra,4(sp)
 10844e8:	df000017 	ldw	fp,0(sp)
 10844ec:	dec00204 	addi	sp,sp,8
 10844f0:	f800283a 	ret

010844f4 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
 10844f4:	defffb04 	addi	sp,sp,-20
 10844f8:	dfc00415 	stw	ra,16(sp)
 10844fc:	df000315 	stw	fp,12(sp)
 1084500:	df000304 	addi	fp,sp,12
 1084504:	e13ffe15 	stw	r4,-8(fp)
 1084508:	e17fff15 	stw	r5,-4(fp)
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 108450c:	e0bfff17 	ldw	r2,-4(fp)
 1084510:	10e00034 	orhi	r3,r2,32768
 1084514:	e0bffe17 	ldw	r2,-8(fp)
 1084518:	10c00015 	stw	r3,0(r2)

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 108451c:	e0bffe17 	ldw	r2,-8(fp)
 1084520:	10800317 	ldw	r2,12(r2)
 1084524:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
 1084528:	e13ffe17 	ldw	r4,-8(fp)
 108452c:	10809440 	call	1080944 <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 1084530:	e0bffd17 	ldw	r2,-12(fp)
 1084534:	10800104 	addi	r2,r2,4
 1084538:	1009883a 	mov	r4,r2
 108453c:	10809440 	call	1080944 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 1084540:	e0bffd17 	ldw	r2,-12(fp)
 1084544:	10800b17 	ldw	r2,44(r2)
 1084548:	d0e4d817 	ldw	r3,-27808(gp)
 108454c:	1880032e 	bgeu	r3,r2,108455c <vTaskRemoveFromUnorderedEventList+0x68>
 1084550:	e0bffd17 	ldw	r2,-12(fp)
 1084554:	10800b17 	ldw	r2,44(r2)
 1084558:	d0a4d815 	stw	r2,-27808(gp)
 108455c:	e0bffd17 	ldw	r2,-12(fp)
 1084560:	10800b17 	ldw	r2,44(r2)
 1084564:	10c00524 	muli	r3,r2,20
 1084568:	00804374 	movhi	r2,269
 108456c:	10a0f704 	addi	r2,r2,-31780
 1084570:	1887883a 	add	r3,r3,r2
 1084574:	e0bffd17 	ldw	r2,-12(fp)
 1084578:	10800104 	addi	r2,r2,4
 108457c:	100b883a 	mov	r5,r2
 1084580:	1809883a 	mov	r4,r3
 1084584:	10807e00 	call	10807e0 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 1084588:	e0bffd17 	ldw	r2,-12(fp)
 108458c:	10800b17 	ldw	r2,44(r2)
 1084590:	d0e4d217 	ldw	r3,-27832(gp)
 1084594:	18c00b17 	ldw	r3,44(r3)
 1084598:	1880022e 	bgeu	r3,r2,10845a4 <vTaskRemoveFromUnorderedEventList+0xb0>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
 108459c:	00800044 	movi	r2,1
 10845a0:	d0a4db15 	stw	r2,-27796(gp)
	}
}
 10845a4:	0001883a 	nop
 10845a8:	e037883a 	mov	sp,fp
 10845ac:	dfc00117 	ldw	ra,4(sp)
 10845b0:	df000017 	ldw	fp,0(sp)
 10845b4:	dec00204 	addi	sp,sp,8
 10845b8:	f800283a 	ret

010845bc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 10845bc:	defffd04 	addi	sp,sp,-12
 10845c0:	dfc00215 	stw	ra,8(sp)
 10845c4:	df000115 	stw	fp,4(sp)
 10845c8:	df000104 	addi	fp,sp,4
 10845cc:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
 10845d0:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
 10845d4:	d0e4dc17 	ldw	r3,-27792(gp)
 10845d8:	e0bfff17 	ldw	r2,-4(fp)
 10845dc:	10c00015 	stw	r3,0(r2)
		pxTimeOut->xTimeOnEntering = xTickCount;
 10845e0:	d0e4d717 	ldw	r3,-27812(gp)
 10845e4:	e0bfff17 	ldw	r2,-4(fp)
 10845e8:	10c00115 	stw	r3,4(r2)
	}
	taskEXIT_CRITICAL();
 10845ec:	1084df40 	call	1084df4 <vTaskExitCritical>
}
 10845f0:	0001883a 	nop
 10845f4:	e037883a 	mov	sp,fp
 10845f8:	dfc00117 	ldw	ra,4(sp)
 10845fc:	df000017 	ldw	fp,0(sp)
 1084600:	dec00204 	addi	sp,sp,8
 1084604:	f800283a 	ret

01084608 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 1084608:	defffe04 	addi	sp,sp,-8
 108460c:	df000115 	stw	fp,4(sp)
 1084610:	df000104 	addi	fp,sp,4
 1084614:	e13fff15 	stw	r4,-4(fp)
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 1084618:	d0e4dc17 	ldw	r3,-27792(gp)
 108461c:	e0bfff17 	ldw	r2,-4(fp)
 1084620:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
 1084624:	d0e4d717 	ldw	r3,-27812(gp)
 1084628:	e0bfff17 	ldw	r2,-4(fp)
 108462c:	10c00115 	stw	r3,4(r2)
}
 1084630:	0001883a 	nop
 1084634:	e037883a 	mov	sp,fp
 1084638:	df000017 	ldw	fp,0(sp)
 108463c:	dec00104 	addi	sp,sp,4
 1084640:	f800283a 	ret

01084644 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 1084644:	defff904 	addi	sp,sp,-28
 1084648:	dfc00615 	stw	ra,24(sp)
 108464c:	df000515 	stw	fp,20(sp)
 1084650:	df000504 	addi	fp,sp,20
 1084654:	e13ffe15 	stw	r4,-8(fp)
 1084658:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 108465c:	1084da00 	call	1084da0 <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 1084660:	d0a4d717 	ldw	r2,-27812(gp)
 1084664:	e0bffc15 	stw	r2,-16(fp)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 1084668:	e0bffe17 	ldw	r2,-8(fp)
 108466c:	10800117 	ldw	r2,4(r2)
 1084670:	e0fffc17 	ldw	r3,-16(fp)
 1084674:	1885c83a 	sub	r2,r3,r2
 1084678:	e0bffd15 	stw	r2,-12(fp)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 108467c:	e0bfff17 	ldw	r2,-4(fp)
 1084680:	10800017 	ldw	r2,0(r2)
 1084684:	10bfffd8 	cmpnei	r2,r2,-1
 1084688:	1000021e 	bne	r2,zero,1084694 <xTaskCheckForTimeOut+0x50>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 108468c:	e03ffb15 	stw	zero,-20(fp)
 1084690:	00001d06 	br	1084708 <xTaskCheckForTimeOut+0xc4>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 1084694:	e0bffe17 	ldw	r2,-8(fp)
 1084698:	10c00017 	ldw	r3,0(r2)
 108469c:	d0a4dc17 	ldw	r2,-27792(gp)
 10846a0:	18800726 	beq	r3,r2,10846c0 <xTaskCheckForTimeOut+0x7c>
 10846a4:	e0bffe17 	ldw	r2,-8(fp)
 10846a8:	10800117 	ldw	r2,4(r2)
 10846ac:	e0fffc17 	ldw	r3,-16(fp)
 10846b0:	18800336 	bltu	r3,r2,10846c0 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 10846b4:	00800044 	movi	r2,1
 10846b8:	e0bffb15 	stw	r2,-20(fp)
 10846bc:	00001206 	br	1084708 <xTaskCheckForTimeOut+0xc4>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 10846c0:	e0bfff17 	ldw	r2,-4(fp)
 10846c4:	10800017 	ldw	r2,0(r2)
 10846c8:	e0fffd17 	ldw	r3,-12(fp)
 10846cc:	18800a2e 	bgeu	r3,r2,10846f8 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
 10846d0:	e0bfff17 	ldw	r2,-4(fp)
 10846d4:	10c00017 	ldw	r3,0(r2)
 10846d8:	e0bffd17 	ldw	r2,-12(fp)
 10846dc:	1887c83a 	sub	r3,r3,r2
 10846e0:	e0bfff17 	ldw	r2,-4(fp)
 10846e4:	10c00015 	stw	r3,0(r2)
			vTaskInternalSetTimeOutState( pxTimeOut );
 10846e8:	e13ffe17 	ldw	r4,-8(fp)
 10846ec:	10846080 	call	1084608 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 10846f0:	e03ffb15 	stw	zero,-20(fp)
 10846f4:	00000406 	br	1084708 <xTaskCheckForTimeOut+0xc4>
		}
		else
		{
			*pxTicksToWait = 0;
 10846f8:	e0bfff17 	ldw	r2,-4(fp)
 10846fc:	10000015 	stw	zero,0(r2)
			xReturn = pdTRUE;
 1084700:	00800044 	movi	r2,1
 1084704:	e0bffb15 	stw	r2,-20(fp)
		}
	}
	taskEXIT_CRITICAL();
 1084708:	1084df40 	call	1084df4 <vTaskExitCritical>

	return xReturn;
 108470c:	e0bffb17 	ldw	r2,-20(fp)
}
 1084710:	e037883a 	mov	sp,fp
 1084714:	dfc00117 	ldw	ra,4(sp)
 1084718:	df000017 	ldw	fp,0(sp)
 108471c:	dec00204 	addi	sp,sp,8
 1084720:	f800283a 	ret

01084724 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 1084724:	deffff04 	addi	sp,sp,-4
 1084728:	df000015 	stw	fp,0(sp)
 108472c:	d839883a 	mov	fp,sp
	xYieldPending = pdTRUE;
 1084730:	00800044 	movi	r2,1
 1084734:	d0a4db15 	stw	r2,-27796(gp)
}
 1084738:	0001883a 	nop
 108473c:	e037883a 	mov	sp,fp
 1084740:	df000017 	ldw	fp,0(sp)
 1084744:	dec00104 	addi	sp,sp,4
 1084748:	f800283a 	ret

0108474c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 108474c:	defffd04 	addi	sp,sp,-12
 1084750:	dfc00215 	stw	ra,8(sp)
 1084754:	df000115 	stw	fp,4(sp)
 1084758:	df000104 	addi	fp,sp,4
 108475c:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 1084760:	10848200 	call	1084820 <prvCheckTasksWaitingTermination>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 1084764:	003ffe06 	br	1084760 <__alt_data_end+0xfffaf030>

01084768 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 1084768:	defffd04 	addi	sp,sp,-12
 108476c:	dfc00215 	stw	ra,8(sp)
 1084770:	df000115 	stw	fp,4(sp)
 1084774:	df000104 	addi	fp,sp,4
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 1084778:	e03fff15 	stw	zero,-4(fp)
 108477c:	00000a06 	br	10847a8 <prvInitialiseTaskLists+0x40>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 1084780:	e0bfff17 	ldw	r2,-4(fp)
 1084784:	10c00524 	muli	r3,r2,20
 1084788:	00804374 	movhi	r2,269
 108478c:	10a0f704 	addi	r2,r2,-31780
 1084790:	1885883a 	add	r2,r3,r2
 1084794:	1009883a 	mov	r4,r2
 1084798:	108074c0 	call	108074c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 108479c:	e0bfff17 	ldw	r2,-4(fp)
 10847a0:	10800044 	addi	r2,r2,1
 10847a4:	e0bfff15 	stw	r2,-4(fp)
 10847a8:	e0bfff17 	ldw	r2,-4(fp)
 10847ac:	10800170 	cmpltui	r2,r2,5
 10847b0:	103ff31e 	bne	r2,zero,1084780 <__alt_data_end+0xfffaf050>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 10847b4:	01004374 	movhi	r4,269
 10847b8:	21211004 	addi	r4,r4,-31680
 10847bc:	108074c0 	call	108074c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 10847c0:	01004374 	movhi	r4,269
 10847c4:	21211504 	addi	r4,r4,-31660
 10847c8:	108074c0 	call	108074c <vListInitialise>
	vListInitialise( &xPendingReadyList );
 10847cc:	01004374 	movhi	r4,269
 10847d0:	21211a04 	addi	r4,r4,-31640
 10847d4:	108074c0 	call	108074c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 10847d8:	01004374 	movhi	r4,269
 10847dc:	21211f04 	addi	r4,r4,-31620
 10847e0:	108074c0 	call	108074c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 10847e4:	01004374 	movhi	r4,269
 10847e8:	21212404 	addi	r4,r4,-31600
 10847ec:	108074c0 	call	108074c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 10847f0:	00804374 	movhi	r2,269
 10847f4:	10a11004 	addi	r2,r2,-31680
 10847f8:	d0a4d315 	stw	r2,-27828(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 10847fc:	00804374 	movhi	r2,269
 1084800:	10a11504 	addi	r2,r2,-31660
 1084804:	d0a4d415 	stw	r2,-27824(gp)
}
 1084808:	0001883a 	nop
 108480c:	e037883a 	mov	sp,fp
 1084810:	dfc00117 	ldw	ra,4(sp)
 1084814:	df000017 	ldw	fp,0(sp)
 1084818:	dec00204 	addi	sp,sp,8
 108481c:	f800283a 	ret

01084820 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 1084820:	defffd04 	addi	sp,sp,-12
 1084824:	dfc00215 	stw	ra,8(sp)
 1084828:	df000115 	stw	fp,4(sp)
 108482c:	df000104 	addi	fp,sp,4
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 1084830:	00001306 	br	1084880 <prvCheckTasksWaitingTermination+0x60>
		{
			taskENTER_CRITICAL();
 1084834:	1084da00 	call	1084da0 <vTaskEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1084838:	00804374 	movhi	r2,269
 108483c:	10a11f04 	addi	r2,r2,-31620
 1084840:	10800317 	ldw	r2,12(r2)
 1084844:	10800317 	ldw	r2,12(r2)
 1084848:	e0bfff15 	stw	r2,-4(fp)
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 108484c:	e0bfff17 	ldw	r2,-4(fp)
 1084850:	10800104 	addi	r2,r2,4
 1084854:	1009883a 	mov	r4,r2
 1084858:	10809440 	call	1080944 <uxListRemove>
				--uxCurrentNumberOfTasks;
 108485c:	d0a4d617 	ldw	r2,-27816(gp)
 1084860:	10bfffc4 	addi	r2,r2,-1
 1084864:	d0a4d615 	stw	r2,-27816(gp)
				--uxDeletedTasksWaitingCleanUp;
 1084868:	d0a4d517 	ldw	r2,-27820(gp)
 108486c:	10bfffc4 	addi	r2,r2,-1
 1084870:	d0a4d515 	stw	r2,-27820(gp)
			}
			taskEXIT_CRITICAL();
 1084874:	1084df40 	call	1084df4 <vTaskExitCritical>

			prvDeleteTCB( pxTCB );
 1084878:	e13fff17 	ldw	r4,-4(fp)
 108487c:	10849640 	call	1084964 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 1084880:	d0a4d517 	ldw	r2,-27820(gp)
 1084884:	103feb1e 	bne	r2,zero,1084834 <__alt_data_end+0xfffaf104>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 1084888:	0001883a 	nop
 108488c:	e037883a 	mov	sp,fp
 1084890:	dfc00117 	ldw	ra,4(sp)
 1084894:	df000017 	ldw	fp,0(sp)
 1084898:	dec00204 	addi	sp,sp,8
 108489c:	f800283a 	ret

010848a0 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
 10848a0:	defffd04 	addi	sp,sp,-12
 10848a4:	df000215 	stw	fp,8(sp)
 10848a8:	df000204 	addi	fp,sp,8
 10848ac:	e13fff15 	stw	r4,-4(fp)
	uint32_t ulCount = 0U;
 10848b0:	e03ffe15 	stw	zero,-8(fp)

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 10848b4:	00000606 	br	10848d0 <prvTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
 10848b8:	e0bfff17 	ldw	r2,-4(fp)
 10848bc:	10800044 	addi	r2,r2,1
 10848c0:	e0bfff15 	stw	r2,-4(fp)
			ulCount++;
 10848c4:	e0bffe17 	ldw	r2,-8(fp)
 10848c8:	10800044 	addi	r2,r2,1
 10848cc:	e0bffe15 	stw	r2,-8(fp)

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 10848d0:	e0bfff17 	ldw	r2,-4(fp)
 10848d4:	10800003 	ldbu	r2,0(r2)
 10848d8:	10803fcc 	andi	r2,r2,255
 10848dc:	10802960 	cmpeqi	r2,r2,165
 10848e0:	103ff51e 	bne	r2,zero,10848b8 <__alt_data_end+0xfffaf188>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 10848e4:	e0bffe17 	ldw	r2,-8(fp)
 10848e8:	1004d0ba 	srli	r2,r2,2
 10848ec:	e0bffe15 	stw	r2,-8(fp)

		return ( configSTACK_DEPTH_TYPE ) ulCount;
 10848f0:	e0bffe17 	ldw	r2,-8(fp)
	}
 10848f4:	e037883a 	mov	sp,fp
 10848f8:	df000017 	ldw	fp,0(sp)
 10848fc:	dec00104 	addi	sp,sp,4
 1084900:	f800283a 	ret

01084904 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
 1084904:	defffa04 	addi	sp,sp,-24
 1084908:	dfc00515 	stw	ra,20(sp)
 108490c:	df000415 	stw	fp,16(sp)
 1084910:	df000404 	addi	fp,sp,16
 1084914:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
 1084918:	e0bfff17 	ldw	r2,-4(fp)
 108491c:	1000021e 	bne	r2,zero,1084928 <uxTaskGetStackHighWaterMark+0x24>
 1084920:	d0a4d217 	ldw	r2,-27832(gp)
 1084924:	00000106 	br	108492c <uxTaskGetStackHighWaterMark+0x28>
 1084928:	e0bfff17 	ldw	r2,-4(fp)
 108492c:	e0bffc15 	stw	r2,-16(fp)

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 1084930:	e0bffc17 	ldw	r2,-16(fp)
 1084934:	10800c17 	ldw	r2,48(r2)
 1084938:	e0bffd15 	stw	r2,-12(fp)
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 108493c:	e13ffd17 	ldw	r4,-12(fp)
 1084940:	10848a00 	call	10848a0 <prvTaskCheckFreeStackSpace>
 1084944:	10bfffcc 	andi	r2,r2,65535
 1084948:	e0bffe15 	stw	r2,-8(fp)

		return uxReturn;
 108494c:	e0bffe17 	ldw	r2,-8(fp)
	}
 1084950:	e037883a 	mov	sp,fp
 1084954:	dfc00117 	ldw	ra,4(sp)
 1084958:	df000017 	ldw	fp,0(sp)
 108495c:	dec00204 	addi	sp,sp,8
 1084960:	f800283a 	ret

01084964 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 1084964:	defffd04 	addi	sp,sp,-12
 1084968:	dfc00215 	stw	ra,8(sp)
 108496c:	df000115 	stw	fp,4(sp)
 1084970:	df000104 	addi	fp,sp,4
 1084974:	e13fff15 	stw	r4,-4(fp)

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 1084978:	e0bfff17 	ldw	r2,-4(fp)
 108497c:	10800c17 	ldw	r2,48(r2)
 1084980:	1009883a 	mov	r4,r2
 1084984:	1080e880 	call	1080e88 <vPortFree>
			vPortFree( pxTCB );
 1084988:	e13fff17 	ldw	r4,-4(fp)
 108498c:	1080e880 	call	1080e88 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 1084990:	0001883a 	nop
 1084994:	e037883a 	mov	sp,fp
 1084998:	dfc00117 	ldw	ra,4(sp)
 108499c:	df000017 	ldw	fp,0(sp)
 10849a0:	dec00204 	addi	sp,sp,8
 10849a4:	f800283a 	ret

010849a8 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 10849a8:	defffe04 	addi	sp,sp,-8
 10849ac:	df000115 	stw	fp,4(sp)
 10849b0:	df000104 	addi	fp,sp,4
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 10849b4:	d0a4d317 	ldw	r2,-27828(gp)
 10849b8:	10800017 	ldw	r2,0(r2)
 10849bc:	1000031e 	bne	r2,zero,10849cc <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 10849c0:	00bfffc4 	movi	r2,-1
 10849c4:	d0a4de15 	stw	r2,-27784(gp)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 10849c8:	00000706 	br	10849e8 <prvResetNextTaskUnblockTime+0x40>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 10849cc:	d0a4d317 	ldw	r2,-27828(gp)
 10849d0:	10800317 	ldw	r2,12(r2)
 10849d4:	10800317 	ldw	r2,12(r2)
 10849d8:	e0bfff15 	stw	r2,-4(fp)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 10849dc:	e0bfff17 	ldw	r2,-4(fp)
 10849e0:	10800117 	ldw	r2,4(r2)
 10849e4:	d0a4de15 	stw	r2,-27784(gp)
	}
}
 10849e8:	0001883a 	nop
 10849ec:	e037883a 	mov	sp,fp
 10849f0:	df000017 	ldw	fp,0(sp)
 10849f4:	dec00104 	addi	sp,sp,4
 10849f8:	f800283a 	ret

010849fc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
 10849fc:	defffe04 	addi	sp,sp,-8
 1084a00:	df000115 	stw	fp,4(sp)
 1084a04:	df000104 	addi	fp,sp,4
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 1084a08:	d0a4d217 	ldw	r2,-27832(gp)
 1084a0c:	e0bfff15 	stw	r2,-4(fp)

		return xReturn;
 1084a10:	e0bfff17 	ldw	r2,-4(fp)
	}
 1084a14:	e037883a 	mov	sp,fp
 1084a18:	df000017 	ldw	fp,0(sp)
 1084a1c:	dec00104 	addi	sp,sp,4
 1084a20:	f800283a 	ret

01084a24 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 1084a24:	defffb04 	addi	sp,sp,-20
 1084a28:	dfc00415 	stw	ra,16(sp)
 1084a2c:	df000315 	stw	fp,12(sp)
 1084a30:	df000304 	addi	fp,sp,12
 1084a34:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 1084a38:	e0bfff17 	ldw	r2,-4(fp)
 1084a3c:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 1084a40:	e03ffd15 	stw	zero,-12(fp)

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
 1084a44:	e0bfff17 	ldw	r2,-4(fp)
 1084a48:	10004026 	beq	r2,zero,1084b4c <xTaskPriorityInherit+0x128>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 1084a4c:	e0bffe17 	ldw	r2,-8(fp)
 1084a50:	10c00b17 	ldw	r3,44(r2)
 1084a54:	d0a4d217 	ldw	r2,-27832(gp)
 1084a58:	10800b17 	ldw	r2,44(r2)
 1084a5c:	1880342e 	bgeu	r3,r2,1084b30 <xTaskPriorityInherit+0x10c>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 1084a60:	e0bffe17 	ldw	r2,-8(fp)
 1084a64:	10800617 	ldw	r2,24(r2)
 1084a68:	10000616 	blt	r2,zero,1084a84 <xTaskPriorityInherit+0x60>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1084a6c:	d0a4d217 	ldw	r2,-27832(gp)
 1084a70:	10800b17 	ldw	r2,44(r2)
 1084a74:	00c00144 	movi	r3,5
 1084a78:	1887c83a 	sub	r3,r3,r2
 1084a7c:	e0bffe17 	ldw	r2,-8(fp)
 1084a80:	10c00615 	stw	r3,24(r2)
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 1084a84:	e0bffe17 	ldw	r2,-8(fp)
 1084a88:	10c00517 	ldw	r3,20(r2)
 1084a8c:	e0bffe17 	ldw	r2,-8(fp)
 1084a90:	10800b17 	ldw	r2,44(r2)
 1084a94:	11000524 	muli	r4,r2,20
 1084a98:	00804374 	movhi	r2,269
 1084a9c:	10a0f704 	addi	r2,r2,-31780
 1084aa0:	2085883a 	add	r2,r4,r2
 1084aa4:	18801b1e 	bne	r3,r2,1084b14 <xTaskPriorityInherit+0xf0>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1084aa8:	e0bffe17 	ldw	r2,-8(fp)
 1084aac:	10800104 	addi	r2,r2,4
 1084ab0:	1009883a 	mov	r4,r2
 1084ab4:	10809440 	call	1080944 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 1084ab8:	d0a4d217 	ldw	r2,-27832(gp)
 1084abc:	10c00b17 	ldw	r3,44(r2)
 1084ac0:	e0bffe17 	ldw	r2,-8(fp)
 1084ac4:	10c00b15 	stw	r3,44(r2)
					prvAddTaskToReadyList( pxMutexHolderTCB );
 1084ac8:	e0bffe17 	ldw	r2,-8(fp)
 1084acc:	10800b17 	ldw	r2,44(r2)
 1084ad0:	d0e4d817 	ldw	r3,-27808(gp)
 1084ad4:	1880032e 	bgeu	r3,r2,1084ae4 <xTaskPriorityInherit+0xc0>
 1084ad8:	e0bffe17 	ldw	r2,-8(fp)
 1084adc:	10800b17 	ldw	r2,44(r2)
 1084ae0:	d0a4d815 	stw	r2,-27808(gp)
 1084ae4:	e0bffe17 	ldw	r2,-8(fp)
 1084ae8:	10800b17 	ldw	r2,44(r2)
 1084aec:	10c00524 	muli	r3,r2,20
 1084af0:	00804374 	movhi	r2,269
 1084af4:	10a0f704 	addi	r2,r2,-31780
 1084af8:	1887883a 	add	r3,r3,r2
 1084afc:	e0bffe17 	ldw	r2,-8(fp)
 1084b00:	10800104 	addi	r2,r2,4
 1084b04:	100b883a 	mov	r5,r2
 1084b08:	1809883a 	mov	r4,r3
 1084b0c:	10807e00 	call	10807e0 <vListInsertEnd>
 1084b10:	00000406 	br	1084b24 <xTaskPriorityInherit+0x100>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 1084b14:	d0a4d217 	ldw	r2,-27832(gp)
 1084b18:	10c00b17 	ldw	r3,44(r2)
 1084b1c:	e0bffe17 	ldw	r2,-8(fp)
 1084b20:	10c00b15 	stw	r3,44(r2)
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
 1084b24:	00800044 	movi	r2,1
 1084b28:	e0bffd15 	stw	r2,-12(fp)
 1084b2c:	00000706 	br	1084b4c <xTaskPriorityInherit+0x128>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 1084b30:	e0bffe17 	ldw	r2,-8(fp)
 1084b34:	10c01017 	ldw	r3,64(r2)
 1084b38:	d0a4d217 	ldw	r2,-27832(gp)
 1084b3c:	10800b17 	ldw	r2,44(r2)
 1084b40:	1880022e 	bgeu	r3,r2,1084b4c <xTaskPriorityInherit+0x128>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
 1084b44:	00800044 	movi	r2,1
 1084b48:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 1084b4c:	e0bffd17 	ldw	r2,-12(fp)
	}
 1084b50:	e037883a 	mov	sp,fp
 1084b54:	dfc00117 	ldw	ra,4(sp)
 1084b58:	df000017 	ldw	fp,0(sp)
 1084b5c:	dec00204 	addi	sp,sp,8
 1084b60:	f800283a 	ret

01084b64 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 1084b64:	defffb04 	addi	sp,sp,-20
 1084b68:	dfc00415 	stw	ra,16(sp)
 1084b6c:	df000315 	stw	fp,12(sp)
 1084b70:	df000304 	addi	fp,sp,12
 1084b74:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
 1084b78:	e0bfff17 	ldw	r2,-4(fp)
 1084b7c:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 1084b80:	e03ffd15 	stw	zero,-12(fp)

		if( pxMutexHolder != NULL )
 1084b84:	e0bfff17 	ldw	r2,-4(fp)
 1084b88:	10002f26 	beq	r2,zero,1084c48 <xTaskPriorityDisinherit+0xe4>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 1084b8c:	e0bffe17 	ldw	r2,-8(fp)
 1084b90:	10801117 	ldw	r2,68(r2)
 1084b94:	10ffffc4 	addi	r3,r2,-1
 1084b98:	e0bffe17 	ldw	r2,-8(fp)
 1084b9c:	10c01115 	stw	r3,68(r2)

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 1084ba0:	e0bffe17 	ldw	r2,-8(fp)
 1084ba4:	10c00b17 	ldw	r3,44(r2)
 1084ba8:	e0bffe17 	ldw	r2,-8(fp)
 1084bac:	10801017 	ldw	r2,64(r2)
 1084bb0:	18802526 	beq	r3,r2,1084c48 <xTaskPriorityDisinherit+0xe4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 1084bb4:	e0bffe17 	ldw	r2,-8(fp)
 1084bb8:	10801117 	ldw	r2,68(r2)
 1084bbc:	1000221e 	bne	r2,zero,1084c48 <xTaskPriorityDisinherit+0xe4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1084bc0:	e0bffe17 	ldw	r2,-8(fp)
 1084bc4:	10800104 	addi	r2,r2,4
 1084bc8:	1009883a 	mov	r4,r2
 1084bcc:	10809440 	call	1080944 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 1084bd0:	e0bffe17 	ldw	r2,-8(fp)
 1084bd4:	10c01017 	ldw	r3,64(r2)
 1084bd8:	e0bffe17 	ldw	r2,-8(fp)
 1084bdc:	10c00b15 	stw	r3,44(r2)

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1084be0:	e0bffe17 	ldw	r2,-8(fp)
 1084be4:	10800b17 	ldw	r2,44(r2)
 1084be8:	00c00144 	movi	r3,5
 1084bec:	1887c83a 	sub	r3,r3,r2
 1084bf0:	e0bffe17 	ldw	r2,-8(fp)
 1084bf4:	10c00615 	stw	r3,24(r2)
					prvAddTaskToReadyList( pxTCB );
 1084bf8:	e0bffe17 	ldw	r2,-8(fp)
 1084bfc:	10800b17 	ldw	r2,44(r2)
 1084c00:	d0e4d817 	ldw	r3,-27808(gp)
 1084c04:	1880032e 	bgeu	r3,r2,1084c14 <xTaskPriorityDisinherit+0xb0>
 1084c08:	e0bffe17 	ldw	r2,-8(fp)
 1084c0c:	10800b17 	ldw	r2,44(r2)
 1084c10:	d0a4d815 	stw	r2,-27808(gp)
 1084c14:	e0bffe17 	ldw	r2,-8(fp)
 1084c18:	10800b17 	ldw	r2,44(r2)
 1084c1c:	10c00524 	muli	r3,r2,20
 1084c20:	00804374 	movhi	r2,269
 1084c24:	10a0f704 	addi	r2,r2,-31780
 1084c28:	1887883a 	add	r3,r3,r2
 1084c2c:	e0bffe17 	ldw	r2,-8(fp)
 1084c30:	10800104 	addi	r2,r2,4
 1084c34:	100b883a 	mov	r5,r2
 1084c38:	1809883a 	mov	r4,r3
 1084c3c:	10807e00 	call	10807e0 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 1084c40:	00800044 	movi	r2,1
 1084c44:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 1084c48:	e0bffd17 	ldw	r2,-12(fp)
	}
 1084c4c:	e037883a 	mov	sp,fp
 1084c50:	dfc00117 	ldw	ra,4(sp)
 1084c54:	df000017 	ldw	fp,0(sp)
 1084c58:	dec00204 	addi	sp,sp,8
 1084c5c:	f800283a 	ret

01084c60 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
 1084c60:	defff804 	addi	sp,sp,-32
 1084c64:	dfc00715 	stw	ra,28(sp)
 1084c68:	df000615 	stw	fp,24(sp)
 1084c6c:	df000604 	addi	fp,sp,24
 1084c70:	e13ffe15 	stw	r4,-8(fp)
 1084c74:	e17fff15 	stw	r5,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
 1084c78:	e0bffe17 	ldw	r2,-8(fp)
 1084c7c:	e0bffb15 	stw	r2,-20(fp)
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 1084c80:	00800044 	movi	r2,1
 1084c84:	e0bffc15 	stw	r2,-16(fp)

		if( pxMutexHolder != NULL )
 1084c88:	e0bffe17 	ldw	r2,-8(fp)
 1084c8c:	10003e26 	beq	r2,zero,1084d88 <vTaskPriorityDisinheritAfterTimeout+0x128>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 1084c90:	e0bffb17 	ldw	r2,-20(fp)
 1084c94:	10c01017 	ldw	r3,64(r2)
 1084c98:	e0bfff17 	ldw	r2,-4(fp)
 1084c9c:	1880032e 	bgeu	r3,r2,1084cac <vTaskPriorityDisinheritAfterTimeout+0x4c>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 1084ca0:	e0bfff17 	ldw	r2,-4(fp)
 1084ca4:	e0bffa15 	stw	r2,-24(fp)
 1084ca8:	00000306 	br	1084cb8 <vTaskPriorityDisinheritAfterTimeout+0x58>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
 1084cac:	e0bffb17 	ldw	r2,-20(fp)
 1084cb0:	10801017 	ldw	r2,64(r2)
 1084cb4:	e0bffa15 	stw	r2,-24(fp)
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
 1084cb8:	e0bffb17 	ldw	r2,-20(fp)
 1084cbc:	10c00b17 	ldw	r3,44(r2)
 1084cc0:	e0bffa17 	ldw	r2,-24(fp)
 1084cc4:	18803026 	beq	r3,r2,1084d88 <vTaskPriorityDisinheritAfterTimeout+0x128>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 1084cc8:	e0bffb17 	ldw	r2,-20(fp)
 1084ccc:	10c01117 	ldw	r3,68(r2)
 1084cd0:	e0bffc17 	ldw	r2,-16(fp)
 1084cd4:	18802c1e 	bne	r3,r2,1084d88 <vTaskPriorityDisinheritAfterTimeout+0x128>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1084cd8:	e0bffb17 	ldw	r2,-20(fp)
 1084cdc:	10800b17 	ldw	r2,44(r2)
 1084ce0:	e0bffd15 	stw	r2,-12(fp)
					pxTCB->uxPriority = uxPriorityToUse;
 1084ce4:	e0bffb17 	ldw	r2,-20(fp)
 1084ce8:	e0fffa17 	ldw	r3,-24(fp)
 1084cec:	10c00b15 	stw	r3,44(r2)

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 1084cf0:	e0bffb17 	ldw	r2,-20(fp)
 1084cf4:	10800617 	ldw	r2,24(r2)
 1084cf8:	10000516 	blt	r2,zero,1084d10 <vTaskPriorityDisinheritAfterTimeout+0xb0>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1084cfc:	00c00144 	movi	r3,5
 1084d00:	e0bffa17 	ldw	r2,-24(fp)
 1084d04:	1887c83a 	sub	r3,r3,r2
 1084d08:	e0bffb17 	ldw	r2,-20(fp)
 1084d0c:	10c00615 	stw	r3,24(r2)
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 1084d10:	e0bffb17 	ldw	r2,-20(fp)
 1084d14:	10c00517 	ldw	r3,20(r2)
 1084d18:	e0bffd17 	ldw	r2,-12(fp)
 1084d1c:	11000524 	muli	r4,r2,20
 1084d20:	00804374 	movhi	r2,269
 1084d24:	10a0f704 	addi	r2,r2,-31780
 1084d28:	2085883a 	add	r2,r4,r2
 1084d2c:	1880161e 	bne	r3,r2,1084d88 <vTaskPriorityDisinheritAfterTimeout+0x128>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1084d30:	e0bffb17 	ldw	r2,-20(fp)
 1084d34:	10800104 	addi	r2,r2,4
 1084d38:	1009883a 	mov	r4,r2
 1084d3c:	10809440 	call	1080944 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
 1084d40:	e0bffb17 	ldw	r2,-20(fp)
 1084d44:	10800b17 	ldw	r2,44(r2)
 1084d48:	d0e4d817 	ldw	r3,-27808(gp)
 1084d4c:	1880032e 	bgeu	r3,r2,1084d5c <vTaskPriorityDisinheritAfterTimeout+0xfc>
 1084d50:	e0bffb17 	ldw	r2,-20(fp)
 1084d54:	10800b17 	ldw	r2,44(r2)
 1084d58:	d0a4d815 	stw	r2,-27808(gp)
 1084d5c:	e0bffb17 	ldw	r2,-20(fp)
 1084d60:	10800b17 	ldw	r2,44(r2)
 1084d64:	10c00524 	muli	r3,r2,20
 1084d68:	00804374 	movhi	r2,269
 1084d6c:	10a0f704 	addi	r2,r2,-31780
 1084d70:	1887883a 	add	r3,r3,r2
 1084d74:	e0bffb17 	ldw	r2,-20(fp)
 1084d78:	10800104 	addi	r2,r2,4
 1084d7c:	100b883a 	mov	r5,r2
 1084d80:	1809883a 	mov	r4,r3
 1084d84:	10807e00 	call	10807e0 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1084d88:	0001883a 	nop
 1084d8c:	e037883a 	mov	sp,fp
 1084d90:	dfc00117 	ldw	ra,4(sp)
 1084d94:	df000017 	ldw	fp,0(sp)
 1084d98:	dec00204 	addi	sp,sp,8
 1084d9c:	f800283a 	ret

01084da0 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
 1084da0:	defffe04 	addi	sp,sp,-8
 1084da4:	df000115 	stw	fp,4(sp)
 1084da8:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1084dac:	0005303a 	rdctl	r2,status
 1084db0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1084db4:	e0ffff17 	ldw	r3,-4(fp)
 1084db8:	00bfff84 	movi	r2,-2
 1084dbc:	1884703a 	and	r2,r3,r2
 1084dc0:	1001703a 	wrctl	status,r2
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
 1084dc4:	d0a4d917 	ldw	r2,-27804(gp)
 1084dc8:	10000526 	beq	r2,zero,1084de0 <vTaskEnterCritical+0x40>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
 1084dcc:	d0a4d217 	ldw	r2,-27832(gp)
 1084dd0:	10c00f17 	ldw	r3,60(r2)
 1084dd4:	18c00044 	addi	r3,r3,1
 1084dd8:	10c00f15 	stw	r3,60(r2)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
 1084ddc:	d0a4d217 	ldw	r2,-27832(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1084de0:	0001883a 	nop
 1084de4:	e037883a 	mov	sp,fp
 1084de8:	df000017 	ldw	fp,0(sp)
 1084dec:	dec00104 	addi	sp,sp,4
 1084df0:	f800283a 	ret

01084df4 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
 1084df4:	defffe04 	addi	sp,sp,-8
 1084df8:	df000115 	stw	fp,4(sp)
 1084dfc:	df000104 	addi	fp,sp,4
		if( xSchedulerRunning != pdFALSE )
 1084e00:	d0a4d917 	ldw	r2,-27804(gp)
 1084e04:	10000e26 	beq	r2,zero,1084e40 <vTaskExitCritical+0x4c>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
 1084e08:	d0a4d217 	ldw	r2,-27832(gp)
 1084e0c:	10800f17 	ldw	r2,60(r2)
 1084e10:	10000b26 	beq	r2,zero,1084e40 <vTaskExitCritical+0x4c>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
 1084e14:	d0a4d217 	ldw	r2,-27832(gp)
 1084e18:	10c00f17 	ldw	r3,60(r2)
 1084e1c:	18ffffc4 	addi	r3,r3,-1
 1084e20:	10c00f15 	stw	r3,60(r2)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
 1084e24:	d0a4d217 	ldw	r2,-27832(gp)
 1084e28:	10800f17 	ldw	r2,60(r2)
 1084e2c:	1000041e 	bne	r2,zero,1084e40 <vTaskExitCritical+0x4c>
 1084e30:	00800044 	movi	r2,1
 1084e34:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1084e38:	e0bfff17 	ldw	r2,-4(fp)
 1084e3c:	1001703a 	wrctl	status,r2
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1084e40:	0001883a 	nop
 1084e44:	e037883a 	mov	sp,fp
 1084e48:	df000017 	ldw	fp,0(sp)
 1084e4c:	dec00104 	addi	sp,sp,4
 1084e50:	f800283a 	ret

01084e54 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 1084e54:	defffe04 	addi	sp,sp,-8
 1084e58:	df000115 	stw	fp,4(sp)
 1084e5c:	df000104 	addi	fp,sp,4
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 1084e60:	d0a4d217 	ldw	r2,-27832(gp)
 1084e64:	10800617 	ldw	r2,24(r2)
 1084e68:	e0bfff15 	stw	r2,-4(fp)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1084e6c:	d0a4d217 	ldw	r2,-27832(gp)
 1084e70:	d0e4d217 	ldw	r3,-27832(gp)
 1084e74:	18c00b17 	ldw	r3,44(r3)
 1084e78:	01000144 	movi	r4,5
 1084e7c:	20c7c83a 	sub	r3,r4,r3
 1084e80:	10c00615 	stw	r3,24(r2)

	return uxReturn;
 1084e84:	e0bfff17 	ldw	r2,-4(fp)
}
 1084e88:	e037883a 	mov	sp,fp
 1084e8c:	df000017 	ldw	fp,0(sp)
 1084e90:	dec00104 	addi	sp,sp,4
 1084e94:	f800283a 	ret

01084e98 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
 1084e98:	deffff04 	addi	sp,sp,-4
 1084e9c:	df000015 	stw	fp,0(sp)
 1084ea0:	d839883a 	mov	fp,sp
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 1084ea4:	d0a4d217 	ldw	r2,-27832(gp)
 1084ea8:	10000426 	beq	r2,zero,1084ebc <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 1084eac:	d0a4d217 	ldw	r2,-27832(gp)
 1084eb0:	10c01117 	ldw	r3,68(r2)
 1084eb4:	18c00044 	addi	r3,r3,1
 1084eb8:	10c01115 	stw	r3,68(r2)
		}

		return pxCurrentTCB;
 1084ebc:	d0a4d217 	ldw	r2,-27832(gp)
	}
 1084ec0:	e037883a 	mov	sp,fp
 1084ec4:	df000017 	ldw	fp,0(sp)
 1084ec8:	dec00104 	addi	sp,sp,4
 1084ecc:	f800283a 	ret

01084ed0 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
 1084ed0:	defffb04 	addi	sp,sp,-20
 1084ed4:	dfc00415 	stw	ra,16(sp)
 1084ed8:	df000315 	stw	fp,12(sp)
 1084edc:	df000304 	addi	fp,sp,12
 1084ee0:	e13ffe15 	stw	r4,-8(fp)
 1084ee4:	e17fff15 	stw	r5,-4(fp)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
 1084ee8:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 1084eec:	d0a4d217 	ldw	r2,-27832(gp)
 1084ef0:	10801217 	ldw	r2,72(r2)
 1084ef4:	1000091e 	bne	r2,zero,1084f1c <ulTaskNotifyTake+0x4c>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 1084ef8:	d0a4d217 	ldw	r2,-27832(gp)
 1084efc:	00c00044 	movi	r3,1
 1084f00:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 1084f04:	e0bfff17 	ldw	r2,-4(fp)
 1084f08:	10000426 	beq	r2,zero,1084f1c <ulTaskNotifyTake+0x4c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 1084f0c:	01400044 	movi	r5,1
 1084f10:	e13fff17 	ldw	r4,-4(fp)
 1084f14:	10856140 	call	1085614 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 1084f18:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 1084f1c:	1084df40 	call	1084df4 <vTaskExitCritical>

		taskENTER_CRITICAL();
 1084f20:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 1084f24:	d0a4d217 	ldw	r2,-27832(gp)
 1084f28:	10801217 	ldw	r2,72(r2)
 1084f2c:	e0bffd15 	stw	r2,-12(fp)

			if( ulReturn != 0UL )
 1084f30:	e0bffd17 	ldw	r2,-12(fp)
 1084f34:	10000926 	beq	r2,zero,1084f5c <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
 1084f38:	e0bffe17 	ldw	r2,-8(fp)
 1084f3c:	10000326 	beq	r2,zero,1084f4c <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
 1084f40:	d0a4d217 	ldw	r2,-27832(gp)
 1084f44:	10001215 	stw	zero,72(r2)
 1084f48:	00000406 	br	1084f5c <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
 1084f4c:	d0a4d217 	ldw	r2,-27832(gp)
 1084f50:	e0fffd17 	ldw	r3,-12(fp)
 1084f54:	18ffffc4 	addi	r3,r3,-1
 1084f58:	10c01215 	stw	r3,72(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1084f5c:	d0a4d217 	ldw	r2,-27832(gp)
 1084f60:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
 1084f64:	1084df40 	call	1084df4 <vTaskExitCritical>

		return ulReturn;
 1084f68:	e0bffd17 	ldw	r2,-12(fp)
	}
 1084f6c:	e037883a 	mov	sp,fp
 1084f70:	dfc00117 	ldw	ra,4(sp)
 1084f74:	df000017 	ldw	fp,0(sp)
 1084f78:	dec00204 	addi	sp,sp,8
 1084f7c:	f800283a 	ret

01084f80 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
 1084f80:	defff904 	addi	sp,sp,-28
 1084f84:	dfc00615 	stw	ra,24(sp)
 1084f88:	df000515 	stw	fp,20(sp)
 1084f8c:	df000504 	addi	fp,sp,20
 1084f90:	e13ffc15 	stw	r4,-16(fp)
 1084f94:	e17ffd15 	stw	r5,-12(fp)
 1084f98:	e1bffe15 	stw	r6,-8(fp)
 1084f9c:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
 1084fa0:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 1084fa4:	d0a4d217 	ldw	r2,-27832(gp)
 1084fa8:	10801303 	ldbu	r2,76(r2)
 1084fac:	10803fcc 	andi	r2,r2,255
 1084fb0:	108000a0 	cmpeqi	r2,r2,2
 1084fb4:	10000f1e 	bne	r2,zero,1084ff4 <xTaskNotifyWait+0x74>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 1084fb8:	d0a4d217 	ldw	r2,-27832(gp)
 1084fbc:	11001217 	ldw	r4,72(r2)
 1084fc0:	e0fffc17 	ldw	r3,-16(fp)
 1084fc4:	00c6303a 	nor	r3,zero,r3
 1084fc8:	20c6703a 	and	r3,r4,r3
 1084fcc:	10c01215 	stw	r3,72(r2)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 1084fd0:	d0a4d217 	ldw	r2,-27832(gp)
 1084fd4:	00c00044 	movi	r3,1
 1084fd8:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 1084fdc:	e0bfff17 	ldw	r2,-4(fp)
 1084fe0:	10000426 	beq	r2,zero,1084ff4 <xTaskNotifyWait+0x74>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 1084fe4:	01400044 	movi	r5,1
 1084fe8:	e13fff17 	ldw	r4,-4(fp)
 1084fec:	10856140 	call	1085614 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 1084ff0:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 1084ff4:	1084df40 	call	1084df4 <vTaskExitCritical>

		taskENTER_CRITICAL();
 1084ff8:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
 1084ffc:	e0bffe17 	ldw	r2,-8(fp)
 1085000:	10000426 	beq	r2,zero,1085014 <xTaskNotifyWait+0x94>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 1085004:	d0a4d217 	ldw	r2,-27832(gp)
 1085008:	10c01217 	ldw	r3,72(r2)
 108500c:	e0bffe17 	ldw	r2,-8(fp)
 1085010:	10c00015 	stw	r3,0(r2)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 1085014:	d0a4d217 	ldw	r2,-27832(gp)
 1085018:	10801303 	ldbu	r2,76(r2)
 108501c:	10803fcc 	andi	r2,r2,255
 1085020:	108000a0 	cmpeqi	r2,r2,2
 1085024:	1000021e 	bne	r2,zero,1085030 <xTaskNotifyWait+0xb0>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
 1085028:	e03ffb15 	stw	zero,-20(fp)
 108502c:	00000806 	br	1085050 <xTaskNotifyWait+0xd0>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 1085030:	d0a4d217 	ldw	r2,-27832(gp)
 1085034:	11001217 	ldw	r4,72(r2)
 1085038:	e0fffd17 	ldw	r3,-12(fp)
 108503c:	00c6303a 	nor	r3,zero,r3
 1085040:	20c6703a 	and	r3,r4,r3
 1085044:	10c01215 	stw	r3,72(r2)
				xReturn = pdTRUE;
 1085048:	00800044 	movi	r2,1
 108504c:	e0bffb15 	stw	r2,-20(fp)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1085050:	d0a4d217 	ldw	r2,-27832(gp)
 1085054:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
 1085058:	1084df40 	call	1084df4 <vTaskExitCritical>

		return xReturn;
 108505c:	e0bffb17 	ldw	r2,-20(fp)
	}
 1085060:	e037883a 	mov	sp,fp
 1085064:	dfc00117 	ldw	ra,4(sp)
 1085068:	df000017 	ldw	fp,0(sp)
 108506c:	dec00204 	addi	sp,sp,8
 1085070:	f800283a 	ret

01085074 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 1085074:	defff704 	addi	sp,sp,-36
 1085078:	dfc00815 	stw	ra,32(sp)
 108507c:	df000715 	stw	fp,28(sp)
 1085080:	df000704 	addi	fp,sp,28
 1085084:	e13ffc15 	stw	r4,-16(fp)
 1085088:	e17ffd15 	stw	r5,-12(fp)
 108508c:	e1bffe15 	stw	r6,-8(fp)
 1085090:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
 1085094:	00800044 	movi	r2,1
 1085098:	e0bff915 	stw	r2,-28(fp)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
 108509c:	e0bffc17 	ldw	r2,-16(fp)
 10850a0:	e0bffa15 	stw	r2,-24(fp)

		taskENTER_CRITICAL();
 10850a4:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 10850a8:	e0bfff17 	ldw	r2,-4(fp)
 10850ac:	10000426 	beq	r2,zero,10850c0 <xTaskGenericNotify+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 10850b0:	e0bffa17 	ldw	r2,-24(fp)
 10850b4:	10c01217 	ldw	r3,72(r2)
 10850b8:	e0bfff17 	ldw	r2,-4(fp)
 10850bc:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 10850c0:	e0bffa17 	ldw	r2,-24(fp)
 10850c4:	10801303 	ldbu	r2,76(r2)
 10850c8:	e0bffb05 	stb	r2,-20(fp)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 10850cc:	e0bffa17 	ldw	r2,-24(fp)
 10850d0:	00c00084 	movi	r3,2
 10850d4:	10c01305 	stb	r3,76(r2)

			switch( eAction )
 10850d8:	e0bffe17 	ldw	r2,-8(fp)
 10850dc:	10800168 	cmpgeui	r2,r2,5
 10850e0:	1000261e 	bne	r2,zero,108517c <xTaskGenericNotify+0x108>
 10850e4:	e0bffe17 	ldw	r2,-8(fp)
 10850e8:	100690ba 	slli	r3,r2,2
 10850ec:	00804234 	movhi	r2,264
 10850f0:	10944004 	addi	r2,r2,20736
 10850f4:	1885883a 	add	r2,r3,r2
 10850f8:	10800017 	ldw	r2,0(r2)
 10850fc:	1000683a 	jmp	r2
 1085100:	01085184 	movi	r4,8518
 1085104:	01085114 	movui	r4,8516
 1085108:	01085130 	cmpltui	r4,zero,8516
 108510c:	01085148 	cmpgei	r4,zero,8517
 1085110:	01085158 	cmpnei	r4,zero,8517
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 1085114:	e0bffa17 	ldw	r2,-24(fp)
 1085118:	10c01217 	ldw	r3,72(r2)
 108511c:	e0bffd17 	ldw	r2,-12(fp)
 1085120:	1886b03a 	or	r3,r3,r2
 1085124:	e0bffa17 	ldw	r2,-24(fp)
 1085128:	10c01215 	stw	r3,72(r2)
					break;
 108512c:	00001606 	br	1085188 <xTaskGenericNotify+0x114>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 1085130:	e0bffa17 	ldw	r2,-24(fp)
 1085134:	10801217 	ldw	r2,72(r2)
 1085138:	10c00044 	addi	r3,r2,1
 108513c:	e0bffa17 	ldw	r2,-24(fp)
 1085140:	10c01215 	stw	r3,72(r2)
					break;
 1085144:	00001006 	br	1085188 <xTaskGenericNotify+0x114>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 1085148:	e0bffa17 	ldw	r2,-24(fp)
 108514c:	e0fffd17 	ldw	r3,-12(fp)
 1085150:	10c01215 	stw	r3,72(r2)
					break;
 1085154:	00000c06 	br	1085188 <xTaskGenericNotify+0x114>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 1085158:	e0bffb03 	ldbu	r2,-20(fp)
 108515c:	108000a0 	cmpeqi	r2,r2,2
 1085160:	1000041e 	bne	r2,zero,1085174 <xTaskGenericNotify+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
 1085164:	e0bffa17 	ldw	r2,-24(fp)
 1085168:	e0fffd17 	ldw	r3,-12(fp)
 108516c:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 1085170:	00000506 	br	1085188 <xTaskGenericNotify+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 1085174:	e03ff915 	stw	zero,-28(fp)
					}
					break;
 1085178:	00000306 	br	1085188 <xTaskGenericNotify+0x114>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
 108517c:	0001883a 	nop
 1085180:	00000106 	br	1085188 <xTaskGenericNotify+0x114>
					break;

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
 1085184:	0001883a 	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 1085188:	e0bffb03 	ldbu	r2,-20(fp)
 108518c:	10800058 	cmpnei	r2,r2,1
 1085190:	10001c1e 	bne	r2,zero,1085204 <xTaskGenericNotify+0x190>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1085194:	e0bffa17 	ldw	r2,-24(fp)
 1085198:	10800104 	addi	r2,r2,4
 108519c:	1009883a 	mov	r4,r2
 10851a0:	10809440 	call	1080944 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 10851a4:	e0bffa17 	ldw	r2,-24(fp)
 10851a8:	10800b17 	ldw	r2,44(r2)
 10851ac:	d0e4d817 	ldw	r3,-27808(gp)
 10851b0:	1880032e 	bgeu	r3,r2,10851c0 <xTaskGenericNotify+0x14c>
 10851b4:	e0bffa17 	ldw	r2,-24(fp)
 10851b8:	10800b17 	ldw	r2,44(r2)
 10851bc:	d0a4d815 	stw	r2,-27808(gp)
 10851c0:	e0bffa17 	ldw	r2,-24(fp)
 10851c4:	10800b17 	ldw	r2,44(r2)
 10851c8:	10c00524 	muli	r3,r2,20
 10851cc:	00804374 	movhi	r2,269
 10851d0:	10a0f704 	addi	r2,r2,-31780
 10851d4:	1887883a 	add	r3,r3,r2
 10851d8:	e0bffa17 	ldw	r2,-24(fp)
 10851dc:	10800104 	addi	r2,r2,4
 10851e0:	100b883a 	mov	r5,r2
 10851e4:	1809883a 	mov	r4,r3
 10851e8:	10807e00 	call	10807e0 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 10851ec:	e0bffa17 	ldw	r2,-24(fp)
 10851f0:	10800b17 	ldw	r2,44(r2)
 10851f4:	d0e4d217 	ldw	r3,-27832(gp)
 10851f8:	18c00b17 	ldw	r3,44(r3)
 10851fc:	1880012e 	bgeu	r3,r2,1085204 <xTaskGenericNotify+0x190>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
 1085200:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 1085204:	1084df40 	call	1084df4 <vTaskExitCritical>

		return xReturn;
 1085208:	e0bff917 	ldw	r2,-28(fp)
	}
 108520c:	e037883a 	mov	sp,fp
 1085210:	dfc00117 	ldw	ra,4(sp)
 1085214:	df000017 	ldw	fp,0(sp)
 1085218:	dec00204 	addi	sp,sp,8
 108521c:	f800283a 	ret

01085220 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
 1085220:	defff604 	addi	sp,sp,-40
 1085224:	dfc00915 	stw	ra,36(sp)
 1085228:	df000815 	stw	fp,32(sp)
 108522c:	df000804 	addi	fp,sp,32
 1085230:	e13ffc15 	stw	r4,-16(fp)
 1085234:	e17ffd15 	stw	r5,-12(fp)
 1085238:	e1bffe15 	stw	r6,-8(fp)
 108523c:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
 1085240:	00800044 	movi	r2,1
 1085244:	e0bff815 	stw	r2,-32(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
 1085248:	e0bffc17 	ldw	r2,-16(fp)
 108524c:	e0bff915 	stw	r2,-28(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1085250:	e03ffa15 	stw	zero,-24(fp)
		{
			if( pulPreviousNotificationValue != NULL )
 1085254:	e0bfff17 	ldw	r2,-4(fp)
 1085258:	10000426 	beq	r2,zero,108526c <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 108525c:	e0bff917 	ldw	r2,-28(fp)
 1085260:	10c01217 	ldw	r3,72(r2)
 1085264:	e0bfff17 	ldw	r2,-4(fp)
 1085268:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 108526c:	e0bff917 	ldw	r2,-28(fp)
 1085270:	10801303 	ldbu	r2,76(r2)
 1085274:	e0bffb05 	stb	r2,-20(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 1085278:	e0bff917 	ldw	r2,-28(fp)
 108527c:	00c00084 	movi	r3,2
 1085280:	10c01305 	stb	r3,76(r2)

			switch( eAction )
 1085284:	e0bffe17 	ldw	r2,-8(fp)
 1085288:	10800168 	cmpgeui	r2,r2,5
 108528c:	1000261e 	bne	r2,zero,1085328 <xTaskGenericNotifyFromISR+0x108>
 1085290:	e0bffe17 	ldw	r2,-8(fp)
 1085294:	100690ba 	slli	r3,r2,2
 1085298:	00804234 	movhi	r2,264
 108529c:	1094ab04 	addi	r2,r2,21164
 10852a0:	1885883a 	add	r2,r3,r2
 10852a4:	10800017 	ldw	r2,0(r2)
 10852a8:	1000683a 	jmp	r2
 10852ac:	01085330 	cmpltui	r4,zero,8524
 10852b0:	010852c0 	call	10852c <__alt_mem_sdram-0x6f7ad4>
 10852b4:	010852dc 	xori	r4,zero,8523
 10852b8:	010852f4 	movhi	r4,8523
 10852bc:	01085304 	movi	r4,8524
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 10852c0:	e0bff917 	ldw	r2,-28(fp)
 10852c4:	10c01217 	ldw	r3,72(r2)
 10852c8:	e0bffd17 	ldw	r2,-12(fp)
 10852cc:	1886b03a 	or	r3,r3,r2
 10852d0:	e0bff917 	ldw	r2,-28(fp)
 10852d4:	10c01215 	stw	r3,72(r2)
					break;
 10852d8:	00001606 	br	1085334 <xTaskGenericNotifyFromISR+0x114>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 10852dc:	e0bff917 	ldw	r2,-28(fp)
 10852e0:	10801217 	ldw	r2,72(r2)
 10852e4:	10c00044 	addi	r3,r2,1
 10852e8:	e0bff917 	ldw	r2,-28(fp)
 10852ec:	10c01215 	stw	r3,72(r2)
					break;
 10852f0:	00001006 	br	1085334 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 10852f4:	e0bff917 	ldw	r2,-28(fp)
 10852f8:	e0fffd17 	ldw	r3,-12(fp)
 10852fc:	10c01215 	stw	r3,72(r2)
					break;
 1085300:	00000c06 	br	1085334 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 1085304:	e0bffb03 	ldbu	r2,-20(fp)
 1085308:	108000a0 	cmpeqi	r2,r2,2
 108530c:	1000041e 	bne	r2,zero,1085320 <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
 1085310:	e0bff917 	ldw	r2,-28(fp)
 1085314:	e0fffd17 	ldw	r3,-12(fp)
 1085318:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 108531c:	00000506 	br	1085334 <xTaskGenericNotifyFromISR+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 1085320:	e03ff815 	stw	zero,-32(fp)
					}
					break;
 1085324:	00000306 	br	1085334 <xTaskGenericNotifyFromISR+0x114>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
 1085328:	0001883a 	nop
 108532c:	00000106 	br	1085334 <xTaskGenericNotifyFromISR+0x114>
					break;

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
 1085330:	0001883a 	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 1085334:	e0bffb03 	ldbu	r2,-20(fp)
 1085338:	10800058 	cmpnei	r2,r2,1
 108533c:	10002b1e 	bne	r2,zero,10853ec <xTaskGenericNotifyFromISR+0x1cc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1085340:	d0a4e017 	ldw	r2,-27776(gp)
 1085344:	1000171e 	bne	r2,zero,10853a4 <xTaskGenericNotifyFromISR+0x184>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1085348:	e0bff917 	ldw	r2,-28(fp)
 108534c:	10800104 	addi	r2,r2,4
 1085350:	1009883a 	mov	r4,r2
 1085354:	10809440 	call	1080944 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1085358:	e0bff917 	ldw	r2,-28(fp)
 108535c:	10800b17 	ldw	r2,44(r2)
 1085360:	d0e4d817 	ldw	r3,-27808(gp)
 1085364:	1880032e 	bgeu	r3,r2,1085374 <xTaskGenericNotifyFromISR+0x154>
 1085368:	e0bff917 	ldw	r2,-28(fp)
 108536c:	10800b17 	ldw	r2,44(r2)
 1085370:	d0a4d815 	stw	r2,-27808(gp)
 1085374:	e0bff917 	ldw	r2,-28(fp)
 1085378:	10800b17 	ldw	r2,44(r2)
 108537c:	10c00524 	muli	r3,r2,20
 1085380:	00804374 	movhi	r2,269
 1085384:	10a0f704 	addi	r2,r2,-31780
 1085388:	1887883a 	add	r3,r3,r2
 108538c:	e0bff917 	ldw	r2,-28(fp)
 1085390:	10800104 	addi	r2,r2,4
 1085394:	100b883a 	mov	r5,r2
 1085398:	1809883a 	mov	r4,r3
 108539c:	10807e00 	call	10807e0 <vListInsertEnd>
 10853a0:	00000606 	br	10853bc <xTaskGenericNotifyFromISR+0x19c>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 10853a4:	e0bff917 	ldw	r2,-28(fp)
 10853a8:	10800604 	addi	r2,r2,24
 10853ac:	100b883a 	mov	r5,r2
 10853b0:	01004374 	movhi	r4,269
 10853b4:	21211a04 	addi	r4,r4,-31640
 10853b8:	10807e00 	call	10807e0 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 10853bc:	e0bff917 	ldw	r2,-28(fp)
 10853c0:	10800b17 	ldw	r2,44(r2)
 10853c4:	d0e4d217 	ldw	r3,-27832(gp)
 10853c8:	18c00b17 	ldw	r3,44(r3)
 10853cc:	1880072e 	bgeu	r3,r2,10853ec <xTaskGenericNotifyFromISR+0x1cc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 10853d0:	e0800217 	ldw	r2,8(fp)
 10853d4:	10000326 	beq	r2,zero,10853e4 <xTaskGenericNotifyFromISR+0x1c4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 10853d8:	e0800217 	ldw	r2,8(fp)
 10853dc:	00c00044 	movi	r3,1
 10853e0:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
 10853e4:	00800044 	movi	r2,1
 10853e8:	d0a4db15 	stw	r2,-27796(gp)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
 10853ec:	e0bff817 	ldw	r2,-32(fp)
	}
 10853f0:	e037883a 	mov	sp,fp
 10853f4:	dfc00117 	ldw	ra,4(sp)
 10853f8:	df000017 	ldw	fp,0(sp)
 10853fc:	dec00204 	addi	sp,sp,8
 1085400:	f800283a 	ret

01085404 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
 1085404:	defff904 	addi	sp,sp,-28
 1085408:	dfc00615 	stw	ra,24(sp)
 108540c:	df000515 	stw	fp,20(sp)
 1085410:	df000504 	addi	fp,sp,20
 1085414:	e13ffe15 	stw	r4,-8(fp)
 1085418:	e17fff15 	stw	r5,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
 108541c:	e0bffe17 	ldw	r2,-8(fp)
 1085420:	e0bffb15 	stw	r2,-20(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1085424:	e03ffc15 	stw	zero,-16(fp)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 1085428:	e0bffb17 	ldw	r2,-20(fp)
 108542c:	10801303 	ldbu	r2,76(r2)
 1085430:	e0bffd05 	stb	r2,-12(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 1085434:	e0bffb17 	ldw	r2,-20(fp)
 1085438:	00c00084 	movi	r3,2
 108543c:	10c01305 	stb	r3,76(r2)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
 1085440:	e0bffb17 	ldw	r2,-20(fp)
 1085444:	10801217 	ldw	r2,72(r2)
 1085448:	10c00044 	addi	r3,r2,1
 108544c:	e0bffb17 	ldw	r2,-20(fp)
 1085450:	10c01215 	stw	r3,72(r2)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 1085454:	e0bffd03 	ldbu	r2,-12(fp)
 1085458:	10800058 	cmpnei	r2,r2,1
 108545c:	10002b1e 	bne	r2,zero,108550c <vTaskNotifyGiveFromISR+0x108>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1085460:	d0a4e017 	ldw	r2,-27776(gp)
 1085464:	1000171e 	bne	r2,zero,10854c4 <vTaskNotifyGiveFromISR+0xc0>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1085468:	e0bffb17 	ldw	r2,-20(fp)
 108546c:	10800104 	addi	r2,r2,4
 1085470:	1009883a 	mov	r4,r2
 1085474:	10809440 	call	1080944 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1085478:	e0bffb17 	ldw	r2,-20(fp)
 108547c:	10800b17 	ldw	r2,44(r2)
 1085480:	d0e4d817 	ldw	r3,-27808(gp)
 1085484:	1880032e 	bgeu	r3,r2,1085494 <vTaskNotifyGiveFromISR+0x90>
 1085488:	e0bffb17 	ldw	r2,-20(fp)
 108548c:	10800b17 	ldw	r2,44(r2)
 1085490:	d0a4d815 	stw	r2,-27808(gp)
 1085494:	e0bffb17 	ldw	r2,-20(fp)
 1085498:	10800b17 	ldw	r2,44(r2)
 108549c:	10c00524 	muli	r3,r2,20
 10854a0:	00804374 	movhi	r2,269
 10854a4:	10a0f704 	addi	r2,r2,-31780
 10854a8:	1887883a 	add	r3,r3,r2
 10854ac:	e0bffb17 	ldw	r2,-20(fp)
 10854b0:	10800104 	addi	r2,r2,4
 10854b4:	100b883a 	mov	r5,r2
 10854b8:	1809883a 	mov	r4,r3
 10854bc:	10807e00 	call	10807e0 <vListInsertEnd>
 10854c0:	00000606 	br	10854dc <vTaskNotifyGiveFromISR+0xd8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 10854c4:	e0bffb17 	ldw	r2,-20(fp)
 10854c8:	10800604 	addi	r2,r2,24
 10854cc:	100b883a 	mov	r5,r2
 10854d0:	01004374 	movhi	r4,269
 10854d4:	21211a04 	addi	r4,r4,-31640
 10854d8:	10807e00 	call	10807e0 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 10854dc:	e0bffb17 	ldw	r2,-20(fp)
 10854e0:	10800b17 	ldw	r2,44(r2)
 10854e4:	d0e4d217 	ldw	r3,-27832(gp)
 10854e8:	18c00b17 	ldw	r3,44(r3)
 10854ec:	1880072e 	bgeu	r3,r2,108550c <vTaskNotifyGiveFromISR+0x108>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 10854f0:	e0bfff17 	ldw	r2,-4(fp)
 10854f4:	10000326 	beq	r2,zero,1085504 <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 10854f8:	e0bfff17 	ldw	r2,-4(fp)
 10854fc:	00c00044 	movi	r3,1
 1085500:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
 1085504:	00800044 	movi	r2,1
 1085508:	d0a4db15 	stw	r2,-27796(gp)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
 108550c:	0001883a 	nop
 1085510:	e037883a 	mov	sp,fp
 1085514:	dfc00117 	ldw	ra,4(sp)
 1085518:	df000017 	ldw	fp,0(sp)
 108551c:	dec00204 	addi	sp,sp,8
 1085520:	f800283a 	ret

01085524 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
 1085524:	defffb04 	addi	sp,sp,-20
 1085528:	dfc00415 	stw	ra,16(sp)
 108552c:	df000315 	stw	fp,12(sp)
 1085530:	df000304 	addi	fp,sp,12
 1085534:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
 1085538:	e0bfff17 	ldw	r2,-4(fp)
 108553c:	1000021e 	bne	r2,zero,1085548 <xTaskNotifyStateClear+0x24>
 1085540:	d0a4d217 	ldw	r2,-27832(gp)
 1085544:	00000106 	br	108554c <xTaskNotifyStateClear+0x28>
 1085548:	e0bfff17 	ldw	r2,-4(fp)
 108554c:	e0bffe15 	stw	r2,-8(fp)

		taskENTER_CRITICAL();
 1085550:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 1085554:	e0bffe17 	ldw	r2,-8(fp)
 1085558:	10801303 	ldbu	r2,76(r2)
 108555c:	10803fcc 	andi	r2,r2,255
 1085560:	10800098 	cmpnei	r2,r2,2
 1085564:	1000051e 	bne	r2,zero,108557c <xTaskNotifyStateClear+0x58>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1085568:	e0bffe17 	ldw	r2,-8(fp)
 108556c:	10001305 	stb	zero,76(r2)
				xReturn = pdPASS;
 1085570:	00800044 	movi	r2,1
 1085574:	e0bffd15 	stw	r2,-12(fp)
 1085578:	00000106 	br	1085580 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
 108557c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
		taskEXIT_CRITICAL();
 1085580:	1084df40 	call	1084df4 <vTaskExitCritical>

		return xReturn;
 1085584:	e0bffd17 	ldw	r2,-12(fp)
	}
 1085588:	e037883a 	mov	sp,fp
 108558c:	dfc00117 	ldw	ra,4(sp)
 1085590:	df000017 	ldw	fp,0(sp)
 1085594:	dec00204 	addi	sp,sp,8
 1085598:	f800283a 	ret

0108559c <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
 108559c:	defffa04 	addi	sp,sp,-24
 10855a0:	dfc00515 	stw	ra,20(sp)
 10855a4:	df000415 	stw	fp,16(sp)
 10855a8:	df000404 	addi	fp,sp,16
 10855ac:	e13ffe15 	stw	r4,-8(fp)
 10855b0:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
 10855b4:	e0bffe17 	ldw	r2,-8(fp)
 10855b8:	1000021e 	bne	r2,zero,10855c4 <ulTaskNotifyValueClear+0x28>
 10855bc:	d0a4d217 	ldw	r2,-27832(gp)
 10855c0:	00000106 	br	10855c8 <ulTaskNotifyValueClear+0x2c>
 10855c4:	e0bffe17 	ldw	r2,-8(fp)
 10855c8:	e0bffc15 	stw	r2,-16(fp)

		taskENTER_CRITICAL();
 10855cc:	1084da00 	call	1084da0 <vTaskEnterCritical>
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 10855d0:	d0a4d217 	ldw	r2,-27832(gp)
 10855d4:	10801217 	ldw	r2,72(r2)
 10855d8:	e0bffd15 	stw	r2,-12(fp)
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
 10855dc:	e0bffc17 	ldw	r2,-16(fp)
 10855e0:	10c01217 	ldw	r3,72(r2)
 10855e4:	e0bfff17 	ldw	r2,-4(fp)
 10855e8:	0084303a 	nor	r2,zero,r2
 10855ec:	1886703a 	and	r3,r3,r2
 10855f0:	e0bffc17 	ldw	r2,-16(fp)
 10855f4:	10c01215 	stw	r3,72(r2)
		}
		taskEXIT_CRITICAL();
 10855f8:	1084df40 	call	1084df4 <vTaskExitCritical>

		return ulReturn;
 10855fc:	e0bffd17 	ldw	r2,-12(fp)
	}
 1085600:	e037883a 	mov	sp,fp
 1085604:	dfc00117 	ldw	ra,4(sp)
 1085608:	df000017 	ldw	fp,0(sp)
 108560c:	dec00204 	addi	sp,sp,8
 1085610:	f800283a 	ret

01085614 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 1085614:	defffa04 	addi	sp,sp,-24
 1085618:	dfc00515 	stw	ra,20(sp)
 108561c:	df000415 	stw	fp,16(sp)
 1085620:	df000404 	addi	fp,sp,16
 1085624:	e13ffe15 	stw	r4,-8(fp)
 1085628:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 108562c:	d0a4d717 	ldw	r2,-27812(gp)
 1085630:	e0bffc15 	stw	r2,-16(fp)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1085634:	d0a4d217 	ldw	r2,-27832(gp)
 1085638:	10800104 	addi	r2,r2,4
 108563c:	1009883a 	mov	r4,r2
 1085640:	10809440 	call	1080944 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 1085644:	e0bffe17 	ldw	r2,-8(fp)
 1085648:	10bfffd8 	cmpnei	r2,r2,-1
 108564c:	1000091e 	bne	r2,zero,1085674 <prvAddCurrentTaskToDelayedList+0x60>
 1085650:	e0bfff17 	ldw	r2,-4(fp)
 1085654:	10000726 	beq	r2,zero,1085674 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 1085658:	d0a4d217 	ldw	r2,-27832(gp)
 108565c:	10800104 	addi	r2,r2,4
 1085660:	100b883a 	mov	r5,r2
 1085664:	01004374 	movhi	r4,269
 1085668:	21212404 	addi	r4,r4,-31600
 108566c:	10807e00 	call	10807e0 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 1085670:	00001c06 	br	10856e4 <prvAddCurrentTaskToDelayedList+0xd0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 1085674:	e0fffc17 	ldw	r3,-16(fp)
 1085678:	e0bffe17 	ldw	r2,-8(fp)
 108567c:	1885883a 	add	r2,r3,r2
 1085680:	e0bffd15 	stw	r2,-12(fp)

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 1085684:	d0a4d217 	ldw	r2,-27832(gp)
 1085688:	e0fffd17 	ldw	r3,-12(fp)
 108568c:	10c00115 	stw	r3,4(r2)

			if( xTimeToWake < xConstTickCount )
 1085690:	e0fffd17 	ldw	r3,-12(fp)
 1085694:	e0bffc17 	ldw	r2,-16(fp)
 1085698:	1880072e 	bgeu	r3,r2,10856b8 <prvAddCurrentTaskToDelayedList+0xa4>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 108569c:	d0e4d417 	ldw	r3,-27824(gp)
 10856a0:	d0a4d217 	ldw	r2,-27832(gp)
 10856a4:	10800104 	addi	r2,r2,4
 10856a8:	100b883a 	mov	r5,r2
 10856ac:	1809883a 	mov	r4,r3
 10856b0:	108086c0 	call	108086c <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 10856b4:	00000b06 	br	10856e4 <prvAddCurrentTaskToDelayedList+0xd0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 10856b8:	d0e4d317 	ldw	r3,-27828(gp)
 10856bc:	d0a4d217 	ldw	r2,-27832(gp)
 10856c0:	10800104 	addi	r2,r2,4
 10856c4:	100b883a 	mov	r5,r2
 10856c8:	1809883a 	mov	r4,r3
 10856cc:	108086c0 	call	108086c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 10856d0:	d0a4de17 	ldw	r2,-27784(gp)
 10856d4:	e0fffd17 	ldw	r3,-12(fp)
 10856d8:	1880022e 	bgeu	r3,r2,10856e4 <prvAddCurrentTaskToDelayedList+0xd0>
				{
					xNextTaskUnblockTime = xTimeToWake;
 10856dc:	e0bffd17 	ldw	r2,-12(fp)
 10856e0:	d0a4de15 	stw	r2,-27784(gp)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 10856e4:	0001883a 	nop
 10856e8:	e037883a 	mov	sp,fp
 10856ec:	dfc00117 	ldw	ra,4(sp)
 10856f0:	df000017 	ldw	fp,0(sp)
 10856f4:	dec00204 	addi	sp,sp,8
 10856f8:	f800283a 	ret

010856fc <set_output>:

#pragma diag_warning 188


static void set_output(const bool output)
{
 10856fc:	defffe04 	addi	sp,sp,-8
 1085700:	df000115 	stw	fp,4(sp)
 1085704:	df000104 	addi	fp,sp,4
 1085708:	e13fff15 	stw	r4,-4(fp)

	IOWR_ALTERA_AVALON_PIO_DIRECTION(LCD_DATA_BASE, 0);
 108570c:	0007883a 	mov	r3,zero
 1085710:	00804434 	movhi	r2,272
 1085714:	10841d04 	addi	r2,r2,4212
 1085718:	10c00035 	stwio	r3,0(r2)
	if (output)
 108571c:	e0bfff17 	ldw	r2,-4(fp)
 1085720:	10000426 	beq	r2,zero,1085734 <set_output+0x38>
		IOWR_ALTERA_AVALON_PIO_DIRECTION(LCD_DATA_BASE, 0xFF);
 1085724:	00c03fc4 	movi	r3,255
 1085728:	00804434 	movhi	r2,272
 108572c:	10841d04 	addi	r2,r2,4212
 1085730:	10c00035 	stwio	r3,0(r2)
}
 1085734:	0001883a 	nop
 1085738:	e037883a 	mov	sp,fp
 108573c:	df000017 	ldw	fp,0(sp)
 1085740:	dec00104 	addi	sp,sp,4
 1085744:	f800283a 	ret

01085748 <enable>:

static void enable(const bool pulse)
{
 1085748:	defffd04 	addi	sp,sp,-12
 108574c:	dfc00215 	stw	ra,8(sp)
 1085750:	df000115 	stw	fp,4(sp)
 1085754:	df000104 	addi	fp,sp,4
 1085758:	e13fff15 	stw	r4,-4(fp)
	if (pulse)
 108575c:	e0bfff17 	ldw	r2,-4(fp)
 1085760:	10000626 	beq	r2,zero,108577c <enable+0x34>
	{
		IOWR_ALTERA_AVALON_PIO_DATA(LCD_E_BASE, 0x01);
 1085764:	00c00044 	movi	r3,1
 1085768:	00804434 	movhi	r2,272
 108576c:	10841004 	addi	r2,r2,4160
 1085770:	10c00035 	stwio	r3,0(r2)
		vTaskDelay(1);
 1085774:	01000044 	movi	r4,1
 1085778:	10837b00 	call	10837b0 <vTaskDelay>
	}
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_E_BASE, 0);
 108577c:	0007883a 	mov	r3,zero
 1085780:	00804434 	movhi	r2,272
 1085784:	10841004 	addi	r2,r2,4160
 1085788:	10c00035 	stwio	r3,0(r2)
	vTaskDelay(1);
 108578c:	01000044 	movi	r4,1
 1085790:	10837b00 	call	10837b0 <vTaskDelay>
}
 1085794:	0001883a 	nop
 1085798:	e037883a 	mov	sp,fp
 108579c:	dfc00117 	ldw	ra,4(sp)
 10857a0:	df000017 	ldw	fp,0(sp)
 10857a4:	dec00204 	addi	sp,sp,8
 10857a8:	f800283a 	ret

010857ac <write>:

static void write(const alt_u8 data, const bool reg)
{
 10857ac:	defffc04 	addi	sp,sp,-16
 10857b0:	dfc00315 	stw	ra,12(sp)
 10857b4:	df000215 	stw	fp,8(sp)
 10857b8:	df000204 	addi	fp,sp,8
 10857bc:	2005883a 	mov	r2,r4
 10857c0:	e17fff15 	stw	r5,-4(fp)
 10857c4:	e0bffe05 	stb	r2,-8(fp)
	set_output(TRUE);
 10857c8:	01000044 	movi	r4,1
 10857cc:	10856fc0 	call	10856fc <set_output>
	//alt_putstr("set_output TRUE\n");
	
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RW_BASE, 0);
 10857d0:	0007883a 	mov	r3,zero
 10857d4:	00804434 	movhi	r2,272
 10857d8:	10841404 	addi	r2,r2,4176
 10857dc:	10c00035 	stwio	r3,0(r2)
	//alt_putstr("RW 0\n");
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RS_BASE, reg);
 10857e0:	00804434 	movhi	r2,272
 10857e4:	10841804 	addi	r2,r2,4192
 10857e8:	e0ffff17 	ldw	r3,-4(fp)
 10857ec:	10c00035 	stwio	r3,0(r2)
	//alt_putstr("RS installed\n");
	
	if (MODE_8_OR_4 == 8) IOWR_ALTERA_AVALON_PIO_DATA(LCD_DATA_BASE, data);
 10857f0:	e0fffe03 	ldbu	r3,-8(fp)
 10857f4:	00804434 	movhi	r2,272
 10857f8:	10841c04 	addi	r2,r2,4208
 10857fc:	10c00035 	stwio	r3,0(r2)
	else IOWR_ALTERA_AVALON_PIO_DATA(LCD_DATA_BASE, data << 4);
	//alt_putstr("data installed\n");
	
	enable(TRUE);
 1085800:	01000044 	movi	r4,1
 1085804:	10857480 	call	1085748 <enable>
	//alt_putstr("enable\n");
}
 1085808:	0001883a 	nop
 108580c:	e037883a 	mov	sp,fp
 1085810:	dfc00117 	ldw	ra,4(sp)
 1085814:	df000017 	ldw	fp,0(sp)
 1085818:	dec00204 	addi	sp,sp,8
 108581c:	f800283a 	ret

01085820 <read_busy>:

static bool read_busy(void)
{
 1085820:	defffd04 	addi	sp,sp,-12
 1085824:	dfc00215 	stw	ra,8(sp)
 1085828:	df000115 	stw	fp,4(sp)
 108582c:	df000104 	addi	fp,sp,4
	alt_u8 data;

	set_output(FALSE);
 1085830:	0009883a 	mov	r4,zero
 1085834:	10856fc0 	call	10856fc <set_output>
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RS_BASE, 0);
 1085838:	0007883a 	mov	r3,zero
 108583c:	00804434 	movhi	r2,272
 1085840:	10841804 	addi	r2,r2,4192
 1085844:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RW_BASE, 0x01);
 1085848:	00c00044 	movi	r3,1
 108584c:	00804434 	movhi	r2,272
 1085850:	10841404 	addi	r2,r2,4176
 1085854:	10c00035 	stwio	r3,0(r2)
	enable(FALSE);
 1085858:	0009883a 	mov	r4,zero
 108585c:	10857480 	call	1085748 <enable>
	data = IORD_ALTERA_AVALON_PIO_DATA(LCD_DATA_BASE);
 1085860:	00804434 	movhi	r2,272
 1085864:	10841c04 	addi	r2,r2,4208
 1085868:	10800037 	ldwio	r2,0(r2)
 108586c:	e0bfff05 	stb	r2,-4(fp)
	enable(FALSE);
 1085870:	0009883a 	mov	r4,zero
 1085874:	10857480 	call	1085748 <enable>
	enable(TRUE);
 1085878:	01000044 	movi	r4,1
 108587c:	10857480 	call	1085748 <enable>

	if (data >> 7 == 1)
 1085880:	e0bfff03 	ldbu	r2,-4(fp)
 1085884:	1004d1fa 	srli	r2,r2,7
 1085888:	10803fcc 	andi	r2,r2,255
 108588c:	10800058 	cmpnei	r2,r2,1
 1085890:	1000021e 	bne	r2,zero,108589c <read_busy+0x7c>
		return (TRUE);
 1085894:	00800044 	movi	r2,1
 1085898:	00000106 	br	10858a0 <read_busy+0x80>

	return (FALSE);
 108589c:	0005883a 	mov	r2,zero

}
 10858a0:	e037883a 	mov	sp,fp
 10858a4:	dfc00117 	ldw	ra,4(sp)
 10858a8:	df000017 	ldw	fp,0(sp)
 10858ac:	dec00204 	addi	sp,sp,8
 10858b0:	f800283a 	ret

010858b4 <hd44780_clear>:

/**
 * Clear the LCD
 */
void hd44780_clear(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd)
{
 10858b4:	defff904 	addi	sp,sp,-28
 10858b8:	dfc00615 	stw	ra,24(sp)
 10858bc:	df000515 	stw	fp,20(sp)
 10858c0:	df000504 	addi	fp,sp,20
 10858c4:	e13ffd15 	stw	r4,-12(fp)
 10858c8:	e17ffe15 	stw	r5,-8(fp)
 10858cc:	e1bfff15 	stw	r6,-4(fp)
	int data = 0x01;
 10858d0:	00800044 	movi	r2,1
 10858d4:	e0bffb15 	stw	r2,-20(fp)
	int rs = 0;
 10858d8:	e03ffc15 	stw	zero,-16(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
 10858dc:	017fffc4 	movi	r5,-1
 10858e0:	e13fff17 	ldw	r4,-4(fp)
 10858e4:	10818980 	call	1081898 <xQueueSemaphoreTake>
 10858e8:	10800058 	cmpnei	r2,r2,1
 10858ec:	1000101e 	bne	r2,zero,1085930 <hd44780_clear+0x7c>
	{
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
 10858f0:	000f883a 	mov	r7,zero
 10858f4:	01bfffc4 	movi	r6,-1
 10858f8:	e17ffb04 	addi	r5,fp,-20
 10858fc:	e13ffd17 	ldw	r4,-12(fp)
 1085900:	108136c0 	call	108136c <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
 1085904:	e0bffc04 	addi	r2,fp,-16
 1085908:	000f883a 	mov	r7,zero
 108590c:	01bfffc4 	movi	r6,-1
 1085910:	100b883a 	mov	r5,r2
 1085914:	e13ffe17 	ldw	r4,-8(fp)
 1085918:	108136c0 	call	108136c <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
 108591c:	000f883a 	mov	r7,zero
 1085920:	000d883a 	mov	r6,zero
 1085924:	000b883a 	mov	r5,zero
 1085928:	e13fff17 	ldw	r4,-4(fp)
 108592c:	108136c0 	call	108136c <xQueueGenericSend>
	}
}
 1085930:	0001883a 	nop
 1085934:	e037883a 	mov	sp,fp
 1085938:	dfc00117 	ldw	ra,4(sp)
 108593c:	df000017 	ldw	fp,0(sp)
 1085940:	dec00204 	addi	sp,sp,8
 1085944:	f800283a 	ret

01085948 <hd44780_home>:

/**
 * Move cursor home
 */
void hd44780_home(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd)
{
 1085948:	defff904 	addi	sp,sp,-28
 108594c:	dfc00615 	stw	ra,24(sp)
 1085950:	df000515 	stw	fp,20(sp)
 1085954:	df000504 	addi	fp,sp,20
 1085958:	e13ffd15 	stw	r4,-12(fp)
 108595c:	e17ffe15 	stw	r5,-8(fp)
 1085960:	e1bfff15 	stw	r6,-4(fp)
	int data = 0x02;
 1085964:	00800084 	movi	r2,2
 1085968:	e0bffb15 	stw	r2,-20(fp)
	int rs = 0;
 108596c:	e03ffc15 	stw	zero,-16(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
 1085970:	017fffc4 	movi	r5,-1
 1085974:	e13fff17 	ldw	r4,-4(fp)
 1085978:	10818980 	call	1081898 <xQueueSemaphoreTake>
 108597c:	10800058 	cmpnei	r2,r2,1
 1085980:	1000101e 	bne	r2,zero,10859c4 <hd44780_home+0x7c>
	{
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
 1085984:	000f883a 	mov	r7,zero
 1085988:	01bfffc4 	movi	r6,-1
 108598c:	e17ffb04 	addi	r5,fp,-20
 1085990:	e13ffd17 	ldw	r4,-12(fp)
 1085994:	108136c0 	call	108136c <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
 1085998:	e0bffc04 	addi	r2,fp,-16
 108599c:	000f883a 	mov	r7,zero
 10859a0:	01bfffc4 	movi	r6,-1
 10859a4:	100b883a 	mov	r5,r2
 10859a8:	e13ffe17 	ldw	r4,-8(fp)
 10859ac:	108136c0 	call	108136c <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
 10859b0:	000f883a 	mov	r7,zero
 10859b4:	000d883a 	mov	r6,zero
 10859b8:	000b883a 	mov	r5,zero
 10859bc:	e13fff17 	ldw	r4,-4(fp)
 10859c0:	108136c0 	call	108136c <xQueueGenericSend>
	}
}
 10859c4:	0001883a 	nop
 10859c8:	e037883a 	mov	sp,fp
 10859cc:	dfc00117 	ldw	ra,4(sp)
 10859d0:	df000017 	ldw	fp,0(sp)
 10859d4:	dec00204 	addi	sp,sp,8
 10859d8:	f800283a 	ret

010859dc <hd44780_display>:
 * @param cursor	Cursor on/off
 * @param blink		Blinking cursor on/off
 *
 */
void hd44780_display(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const bool enable, const bool cursor, const bool blink)
{
 10859dc:	defff804 	addi	sp,sp,-32
 10859e0:	dfc00715 	stw	ra,28(sp)
 10859e4:	df000615 	stw	fp,24(sp)
 10859e8:	df000604 	addi	fp,sp,24
 10859ec:	e13ffc15 	stw	r4,-16(fp)
 10859f0:	e17ffd15 	stw	r5,-12(fp)
 10859f4:	e1bffe15 	stw	r6,-8(fp)
 10859f8:	e1ffff15 	stw	r7,-4(fp)
	alt_u16 command = HD44780_DISPLAY;
 10859fc:	00800204 	movi	r2,8
 1085a00:	e0bffa0d 	sth	r2,-24(fp)

	if (enable)
 1085a04:	e0bfff17 	ldw	r2,-4(fp)
 1085a08:	10000326 	beq	r2,zero,1085a18 <hd44780_display+0x3c>
		command |= HD44780_DISPLAY_ON;
 1085a0c:	e0bffa0b 	ldhu	r2,-24(fp)
 1085a10:	10800114 	ori	r2,r2,4
 1085a14:	e0bffa0d 	sth	r2,-24(fp)
	/*else
  {
		Queue_Head = Queue_Tail = 0;
	}*/
	if (cursor)
 1085a18:	e0800217 	ldw	r2,8(fp)
 1085a1c:	10000326 	beq	r2,zero,1085a2c <hd44780_display+0x50>
		command |= HD44780_CURSOR_ON;
 1085a20:	e0bffa0b 	ldhu	r2,-24(fp)
 1085a24:	10800094 	ori	r2,r2,2
 1085a28:	e0bffa0d 	sth	r2,-24(fp)
	if (blink)
 1085a2c:	e0800317 	ldw	r2,12(fp)
 1085a30:	10000326 	beq	r2,zero,1085a40 <hd44780_display+0x64>
		command |= HD44780_BLINK_ON;
 1085a34:	e0bffa0b 	ldhu	r2,-24(fp)
 1085a38:	10800054 	ori	r2,r2,1
 1085a3c:	e0bffa0d 	sth	r2,-24(fp)

	int rs = 0;
 1085a40:	e03ffb15 	stw	zero,-20(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
 1085a44:	017fffc4 	movi	r5,-1
 1085a48:	e13ffe17 	ldw	r4,-8(fp)
 1085a4c:	10818980 	call	1081898 <xQueueSemaphoreTake>
 1085a50:	10800058 	cmpnei	r2,r2,1
 1085a54:	1000101e 	bne	r2,zero,1085a98 <hd44780_display+0xbc>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
 1085a58:	000f883a 	mov	r7,zero
 1085a5c:	01bfffc4 	movi	r6,-1
 1085a60:	e17ffa04 	addi	r5,fp,-24
 1085a64:	e13ffc17 	ldw	r4,-16(fp)
 1085a68:	108136c0 	call	108136c <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
 1085a6c:	e0bffb04 	addi	r2,fp,-20
 1085a70:	000f883a 	mov	r7,zero
 1085a74:	01bfffc4 	movi	r6,-1
 1085a78:	100b883a 	mov	r5,r2
 1085a7c:	e13ffd17 	ldw	r4,-12(fp)
 1085a80:	108136c0 	call	108136c <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
 1085a84:	000f883a 	mov	r7,zero
 1085a88:	000d883a 	mov	r6,zero
 1085a8c:	000b883a 	mov	r5,zero
 1085a90:	e13ffe17 	ldw	r4,-8(fp)
 1085a94:	108136c0 	call	108136c <xQueueGenericSend>
	}
}
 1085a98:	0001883a 	nop
 1085a9c:	e037883a 	mov	sp,fp
 1085aa0:	dfc00117 	ldw	ra,4(sp)
 1085aa4:	df000017 	ldw	fp,0(sp)
 1085aa8:	dec00204 	addi	sp,sp,8
 1085aac:	f800283a 	ret

01085ab0 <hd44780_position>:
 *
 * @param row	Row
 * @param col	Column
 */
void hd44780_position(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const alt_u8 row, const alt_u8 col)
{
 1085ab0:	defff604 	addi	sp,sp,-40
 1085ab4:	dfc00915 	stw	ra,36(sp)
 1085ab8:	df000815 	stw	fp,32(sp)
 1085abc:	df000804 	addi	fp,sp,32
 1085ac0:	e13ffb15 	stw	r4,-20(fp)
 1085ac4:	e17ffc15 	stw	r5,-16(fp)
 1085ac8:	e1bffd15 	stw	r6,-12(fp)
 1085acc:	3807883a 	mov	r3,r7
 1085ad0:	e0800217 	ldw	r2,8(fp)
 1085ad4:	e0fffe05 	stb	r3,-8(fp)
 1085ad8:	e0bfff05 	stb	r2,-4(fp)
	alt_u16 command = HD44780_DGRAM;
 1085adc:	00802004 	movi	r2,128
 1085ae0:	e0bff80d 	sth	r2,-32(fp)
	const alt_u8 offsets[] = { 0x00, 0x40, 0x14, 0x54 };
 1085ae4:	e03ff885 	stb	zero,-30(fp)
 1085ae8:	00801004 	movi	r2,64
 1085aec:	e0bff8c5 	stb	r2,-29(fp)
 1085af0:	00800504 	movi	r2,20
 1085af4:	e0bff905 	stb	r2,-28(fp)
 1085af8:	00801504 	movi	r2,84
 1085afc:	e0bff945 	stb	r2,-27(fp)

	command |= col + offsets[row];
 1085b00:	e0ffff03 	ldbu	r3,-4(fp)
 1085b04:	e0bffe03 	ldbu	r2,-8(fp)
 1085b08:	e13ff884 	addi	r4,fp,-30
 1085b0c:	2085883a 	add	r2,r4,r2
 1085b10:	10800003 	ldbu	r2,0(r2)
 1085b14:	10803fcc 	andi	r2,r2,255
 1085b18:	1885883a 	add	r2,r3,r2
 1085b1c:	1007883a 	mov	r3,r2
 1085b20:	e0bff80b 	ldhu	r2,-32(fp)
 1085b24:	1884b03a 	or	r2,r3,r2
 1085b28:	e0bff80d 	sth	r2,-32(fp)
	int rs = 0;
 1085b2c:	e03ffa15 	stw	zero,-24(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
 1085b30:	017fffc4 	movi	r5,-1
 1085b34:	e13ffd17 	ldw	r4,-12(fp)
 1085b38:	10818980 	call	1081898 <xQueueSemaphoreTake>
 1085b3c:	10800058 	cmpnei	r2,r2,1
 1085b40:	1000101e 	bne	r2,zero,1085b84 <hd44780_position+0xd4>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
 1085b44:	000f883a 	mov	r7,zero
 1085b48:	01bfffc4 	movi	r6,-1
 1085b4c:	e17ff804 	addi	r5,fp,-32
 1085b50:	e13ffb17 	ldw	r4,-20(fp)
 1085b54:	108136c0 	call	108136c <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
 1085b58:	e0bffa04 	addi	r2,fp,-24
 1085b5c:	000f883a 	mov	r7,zero
 1085b60:	01bfffc4 	movi	r6,-1
 1085b64:	100b883a 	mov	r5,r2
 1085b68:	e13ffc17 	ldw	r4,-16(fp)
 1085b6c:	108136c0 	call	108136c <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
 1085b70:	000f883a 	mov	r7,zero
 1085b74:	000d883a 	mov	r6,zero
 1085b78:	000b883a 	mov	r5,zero
 1085b7c:	e13ffd17 	ldw	r4,-12(fp)
 1085b80:	108136c0 	call	108136c <xQueueGenericSend>
	}
}
 1085b84:	0001883a 	nop
 1085b88:	e037883a 	mov	sp,fp
 1085b8c:	dfc00117 	ldw	ra,4(sp)
 1085b90:	df000017 	ldw	fp,0(sp)
 1085b94:	dec00204 	addi	sp,sp,8
 1085b98:	f800283a 	ret

01085b9c <hd44780_cgram>:
 * @param pos	UDG number
 * @param udg	UDG definition
 */
 //           
void hd44780_cgram(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const alt_u8 pos, const char udg[8])
{
 1085b9c:	defff804 	addi	sp,sp,-32
 1085ba0:	dfc00715 	stw	ra,28(sp)
 1085ba4:	df000615 	stw	fp,24(sp)
 1085ba8:	df000604 	addi	fp,sp,24
 1085bac:	e13ffc15 	stw	r4,-16(fp)
 1085bb0:	e17ffd15 	stw	r5,-12(fp)
 1085bb4:	e1bffe15 	stw	r6,-8(fp)
 1085bb8:	3805883a 	mov	r2,r7
 1085bbc:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 i;
	alt_u16 command = HD44780_CGRAM;
 1085bc0:	00801004 	movi	r2,64
 1085bc4:	e0bffa8d 	sth	r2,-22(fp)

	if (pos < 8) alt_putstr("pos cgram failed");
 1085bc8:	e0bfff03 	ldbu	r2,-4(fp)
 1085bcc:	10800228 	cmpgeui	r2,r2,8
 1085bd0:	1000031e 	bne	r2,zero,1085be0 <hd44780_cgram+0x44>
 1085bd4:	01004274 	movhi	r4,265
 1085bd8:	2122db04 	addi	r4,r4,-29844
 1085bdc:	1086f7c0 	call	1086f7c <alt_putstr>

	command |= pos * 8;
 1085be0:	e0bfff03 	ldbu	r2,-4(fp)
 1085be4:	100490fa 	slli	r2,r2,3
 1085be8:	1007883a 	mov	r3,r2
 1085bec:	e0bffa8b 	ldhu	r2,-22(fp)
 1085bf0:	1884b03a 	or	r2,r3,r2
 1085bf4:	e0bffa8d 	sth	r2,-22(fp)

	int rs = 0;
 1085bf8:	e03ffb15 	stw	zero,-20(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
 1085bfc:	017fffc4 	movi	r5,-1
 1085c00:	e13ffe17 	ldw	r4,-8(fp)
 1085c04:	10818980 	call	1081898 <xQueueSemaphoreTake>
 1085c08:	10800058 	cmpnei	r2,r2,1
 1085c0c:	1000291e 	bne	r2,zero,1085cb4 <hd44780_cgram+0x118>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
 1085c10:	e0bffa84 	addi	r2,fp,-22
 1085c14:	000f883a 	mov	r7,zero
 1085c18:	01bfffc4 	movi	r6,-1
 1085c1c:	100b883a 	mov	r5,r2
 1085c20:	e13ffc17 	ldw	r4,-16(fp)
 1085c24:	108136c0 	call	108136c <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
 1085c28:	e0bffb04 	addi	r2,fp,-20
 1085c2c:	000f883a 	mov	r7,zero
 1085c30:	01bfffc4 	movi	r6,-1
 1085c34:	100b883a 	mov	r5,r2
 1085c38:	e13ffd17 	ldw	r4,-12(fp)
 1085c3c:	108136c0 	call	108136c <xQueueGenericSend>
		
		rs = 1;
 1085c40:	00800044 	movi	r2,1
 1085c44:	e0bffb15 	stw	r2,-20(fp)
		for (i = 0; i < 8; i++)
 1085c48:	e03ffa05 	stb	zero,-24(fp)
 1085c4c:	00001106 	br	1085c94 <hd44780_cgram+0xf8>
		{
				xQueueSendToBack(Queue_lcd_data, &udg[i], portMAX_DELAY);
 1085c50:	e0bffa03 	ldbu	r2,-24(fp)
 1085c54:	e0c00217 	ldw	r3,8(fp)
 1085c58:	1885883a 	add	r2,r3,r2
 1085c5c:	000f883a 	mov	r7,zero
 1085c60:	01bfffc4 	movi	r6,-1
 1085c64:	100b883a 	mov	r5,r2
 1085c68:	e13ffc17 	ldw	r4,-16(fp)
 1085c6c:	108136c0 	call	108136c <xQueueGenericSend>
				xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
 1085c70:	e0bffb04 	addi	r2,fp,-20
 1085c74:	000f883a 	mov	r7,zero
 1085c78:	01bfffc4 	movi	r6,-1
 1085c7c:	100b883a 	mov	r5,r2
 1085c80:	e13ffd17 	ldw	r4,-12(fp)
 1085c84:	108136c0 	call	108136c <xQueueGenericSend>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
		
		rs = 1;
		for (i = 0; i < 8; i++)
 1085c88:	e0bffa03 	ldbu	r2,-24(fp)
 1085c8c:	10800044 	addi	r2,r2,1
 1085c90:	e0bffa05 	stb	r2,-24(fp)
 1085c94:	e0bffa03 	ldbu	r2,-24(fp)
 1085c98:	10800230 	cmpltui	r2,r2,8
 1085c9c:	103fec1e 	bne	r2,zero,1085c50 <__alt_data_end+0xfffb0520>
		{
				xQueueSendToBack(Queue_lcd_data, &udg[i], portMAX_DELAY);
				xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
		}
		xSemaphoreGive( Mutex_write_lcd );
 1085ca0:	000f883a 	mov	r7,zero
 1085ca4:	000d883a 	mov	r6,zero
 1085ca8:	000b883a 	mov	r5,zero
 1085cac:	e13ffe17 	ldw	r4,-8(fp)
 1085cb0:	108136c0 	call	108136c <xQueueGenericSend>
	}
}
 1085cb4:	0001883a 	nop
 1085cb8:	e037883a 	mov	sp,fp
 1085cbc:	dfc00117 	ldw	ra,4(sp)
 1085cc0:	df000017 	ldw	fp,0(sp)
 1085cc4:	dec00204 	addi	sp,sp,8
 1085cc8:	f800283a 	ret

01085ccc <hd44780_put>:
 * Send a single character to the LCD
 *
 * @param chr	Character to send
 */
void hd44780_put(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char chr)
{
 1085ccc:	defff904 	addi	sp,sp,-28
 1085cd0:	dfc00615 	stw	ra,24(sp)
 1085cd4:	df000515 	stw	fp,20(sp)
 1085cd8:	df000504 	addi	fp,sp,20
 1085cdc:	e13ffc15 	stw	r4,-16(fp)
 1085ce0:	e17ffd15 	stw	r5,-12(fp)
 1085ce4:	e1bffe15 	stw	r6,-8(fp)
 1085ce8:	3805883a 	mov	r2,r7
 1085cec:	e0bfff05 	stb	r2,-4(fp)
	int rs = 1;
 1085cf0:	00800044 	movi	r2,1
 1085cf4:	e0bffb15 	stw	r2,-20(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
 1085cf8:	017fffc4 	movi	r5,-1
 1085cfc:	e13ffe17 	ldw	r4,-8(fp)
 1085d00:	10818980 	call	1081898 <xQueueSemaphoreTake>
 1085d04:	10800058 	cmpnei	r2,r2,1
 1085d08:	1000101e 	bne	r2,zero,1085d4c <hd44780_put+0x80>
	{
		xQueueSendToBack(Queue_lcd_data, &chr, portMAX_DELAY);
 1085d0c:	e0bfff04 	addi	r2,fp,-4
 1085d10:	000f883a 	mov	r7,zero
 1085d14:	01bfffc4 	movi	r6,-1
 1085d18:	100b883a 	mov	r5,r2
 1085d1c:	e13ffc17 	ldw	r4,-16(fp)
 1085d20:	108136c0 	call	108136c <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
 1085d24:	000f883a 	mov	r7,zero
 1085d28:	01bfffc4 	movi	r6,-1
 1085d2c:	e17ffb04 	addi	r5,fp,-20
 1085d30:	e13ffd17 	ldw	r4,-12(fp)
 1085d34:	108136c0 	call	108136c <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
 1085d38:	000f883a 	mov	r7,zero
 1085d3c:	000d883a 	mov	r6,zero
 1085d40:	000b883a 	mov	r5,zero
 1085d44:	e13ffe17 	ldw	r4,-8(fp)
 1085d48:	108136c0 	call	108136c <xQueueGenericSend>
	}
}
 1085d4c:	0001883a 	nop
 1085d50:	e037883a 	mov	sp,fp
 1085d54:	dfc00117 	ldw	ra,4(sp)
 1085d58:	df000017 	ldw	fp,0(sp)
 1085d5c:	dec00204 	addi	sp,sp,8
 1085d60:	f800283a 	ret

01085d64 <hd44780_print>:
 * Send a string to the LCD
 *
 * @param string	String to send
 */
void hd44780_print(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char* string)
{
 1085d64:	defff704 	addi	sp,sp,-36
 1085d68:	dfc00815 	stw	ra,32(sp)
 1085d6c:	df000715 	stw	fp,28(sp)
 1085d70:	dc000615 	stw	r16,24(sp)
 1085d74:	df000704 	addi	fp,sp,28
 1085d78:	e13ffb15 	stw	r4,-20(fp)
 1085d7c:	e17ffc15 	stw	r5,-16(fp)
 1085d80:	e1bffd15 	stw	r6,-12(fp)
 1085d84:	e1fffe15 	stw	r7,-8(fp)
	alt_u8 i = 0;
 1085d88:	e03ff905 	stb	zero,-28(fp)
	int rs = 1;
 1085d8c:	00800044 	movi	r2,1
 1085d90:	e0bffa15 	stw	r2,-24(fp)
	
	for(; i < strlen(string); i++)
 1085d94:	00000f06 	br	1085dd4 <hd44780_print+0x70>
	{
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, string[i]);
 1085d98:	e0bff903 	ldbu	r2,-28(fp)
 1085d9c:	e0fffe17 	ldw	r3,-8(fp)
 1085da0:	1885883a 	add	r2,r3,r2
 1085da4:	10800003 	ldbu	r2,0(r2)
 1085da8:	10803fcc 	andi	r2,r2,255
 1085dac:	1080201c 	xori	r2,r2,128
 1085db0:	10bfe004 	addi	r2,r2,-128
 1085db4:	100f883a 	mov	r7,r2
 1085db8:	e1bffd17 	ldw	r6,-12(fp)
 1085dbc:	e17ffc17 	ldw	r5,-16(fp)
 1085dc0:	e13ffb17 	ldw	r4,-20(fp)
 1085dc4:	1085ccc0 	call	1085ccc <hd44780_put>
void hd44780_print(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char* string)
{
	alt_u8 i = 0;
	int rs = 1;
	
	for(; i < strlen(string); i++)
 1085dc8:	e0bff903 	ldbu	r2,-28(fp)
 1085dcc:	10800044 	addi	r2,r2,1
 1085dd0:	e0bff905 	stb	r2,-28(fp)
 1085dd4:	e43ff903 	ldbu	r16,-28(fp)
 1085dd8:	e13ffe17 	ldw	r4,-8(fp)
 1085ddc:	10864180 	call	1086418 <strlen>
 1085de0:	80bfed36 	bltu	r16,r2,1085d98 <__alt_data_end+0xfffb0668>
	{
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, string[i]);
	}
}
 1085de4:	0001883a 	nop
 1085de8:	e6ffff04 	addi	sp,fp,-4
 1085dec:	dfc00217 	ldw	ra,8(sp)
 1085df0:	df000117 	ldw	fp,4(sp)
 1085df4:	dc000017 	ldw	r16,0(sp)
 1085df8:	dec00304 	addi	sp,sp,12
 1085dfc:	f800283a 	ret

01085e00 <hd44780_printf>:
 *
 * @param fmt	String format
 * @param ...	Variable arguments (see printf())
 */
void hd44780_printf(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char *fmt, ...)
{
 1085e00:	deffee04 	addi	sp,sp,-72
 1085e04:	dfc01115 	stw	ra,68(sp)
 1085e08:	df001015 	stw	fp,64(sp)
 1085e0c:	df001004 	addi	fp,sp,64
 1085e10:	e13ffc15 	stw	r4,-16(fp)
 1085e14:	e17ffd15 	stw	r5,-12(fp)
 1085e18:	e1bffe15 	stw	r6,-8(fp)
 1085e1c:	e1ffff15 	stw	r7,-4(fp)
	alt_u16 i;
	alt_u16 size;
	alt_u8 character;
	char buffer[32];
	va_list args;
	int rs = 1;
 1085e20:	00800044 	movi	r2,1
 1085e24:	e0bff115 	stw	r2,-60(fp)

	va_start(args, fmt);
 1085e28:	e0800204 	addi	r2,fp,8
 1085e2c:	e0bffb15 	stw	r2,-20(fp)
	size = vsprintf(buffer, fmt, args);
 1085e30:	e0fffb17 	ldw	r3,-20(fp)
 1085e34:	e0bff2c4 	addi	r2,fp,-53
 1085e38:	180d883a 	mov	r6,r3
 1085e3c:	e17fff17 	ldw	r5,-4(fp)
 1085e40:	1009883a 	mov	r4,r2
 1085e44:	10864900 	call	1086490 <vsprintf>
 1085e48:	e0bff20d 	sth	r2,-56(fp)
	for (i = 0; i < size; i++)
 1085e4c:	e03ff00d 	sth	zero,-64(fp)
 1085e50:	00001106 	br	1085e98 <hd44780_printf+0x98>
	{
		character = buffer[i];
 1085e54:	e0bff00b 	ldhu	r2,-64(fp)
 1085e58:	e0fff2c4 	addi	r3,fp,-53
 1085e5c:	1885883a 	add	r2,r3,r2
 1085e60:	10800003 	ldbu	r2,0(r2)
 1085e64:	e0bff285 	stb	r2,-54(fp)
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, character);
 1085e68:	e0bff283 	ldbu	r2,-54(fp)
 1085e6c:	10803fcc 	andi	r2,r2,255
 1085e70:	1080201c 	xori	r2,r2,128
 1085e74:	10bfe004 	addi	r2,r2,-128
 1085e78:	100f883a 	mov	r7,r2
 1085e7c:	e1bffe17 	ldw	r6,-8(fp)
 1085e80:	e17ffd17 	ldw	r5,-12(fp)
 1085e84:	e13ffc17 	ldw	r4,-16(fp)
 1085e88:	1085ccc0 	call	1085ccc <hd44780_put>
	va_list args;
	int rs = 1;

	va_start(args, fmt);
	size = vsprintf(buffer, fmt, args);
	for (i = 0; i < size; i++)
 1085e8c:	e0bff00b 	ldhu	r2,-64(fp)
 1085e90:	10800044 	addi	r2,r2,1
 1085e94:	e0bff00d 	sth	r2,-64(fp)
 1085e98:	e0fff00b 	ldhu	r3,-64(fp)
 1085e9c:	e0bff20b 	ldhu	r2,-56(fp)
 1085ea0:	18bfec36 	bltu	r3,r2,1085e54 <__alt_data_end+0xfffb0724>
	{
		character = buffer[i];
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, character);
	}
}
 1085ea4:	0001883a 	nop
 1085ea8:	e037883a 	mov	sp,fp
 1085eac:	dfc00117 	ldw	ra,4(sp)
 1085eb0:	df000017 	ldw	fp,0(sp)
 1085eb4:	dec00204 	addi	sp,sp,8
 1085eb8:	f800283a 	ret

01085ebc <hd44780_init>:

/**
 * Initialise the LCD
 */
void hd44780_init(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd)
{
 1085ebc:	defff904 	addi	sp,sp,-28
 1085ec0:	dfc00615 	stw	ra,24(sp)
 1085ec4:	df000515 	stw	fp,20(sp)
 1085ec8:	df000504 	addi	fp,sp,20
 1085ecc:	e13ffd15 	stw	r4,-12(fp)
 1085ed0:	e17ffe15 	stw	r5,-8(fp)
 1085ed4:	e1bfff15 	stw	r6,-4(fp)
	int data, rs = 0;
 1085ed8:	e03ffc15 	stw	zero,-16(fp)
	alt_putstr("initialisation start\n");
 1085edc:	01004274 	movhi	r4,265
 1085ee0:	2122e004 	addi	r4,r4,-29824
 1085ee4:	1086f7c0 	call	1086f7c <alt_putstr>
	//function set
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
 1085ee8:	017fffc4 	movi	r5,-1
 1085eec:	e13fff17 	ldw	r4,-4(fp)
 1085ef0:	10818980 	call	1081898 <xQueueSemaphoreTake>
 1085ef4:	10800058 	cmpnei	r2,r2,1
 1085ef8:	1000421e 	bne	r2,zero,1086004 <hd44780_init+0x148>
	{
		data = 0x3C;
 1085efc:	00800f04 	movi	r2,60
 1085f00:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
 1085f04:	000f883a 	mov	r7,zero
 1085f08:	01bfffc4 	movi	r6,-1
 1085f0c:	e17ffb04 	addi	r5,fp,-20
 1085f10:	e13ffd17 	ldw	r4,-12(fp)
 1085f14:	108136c0 	call	108136c <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
 1085f18:	e0bffc04 	addi	r2,fp,-16
 1085f1c:	000f883a 	mov	r7,zero
 1085f20:	01bfffc4 	movi	r6,-1
 1085f24:	100b883a 	mov	r5,r2
 1085f28:	e13ffe17 	ldw	r4,-8(fp)
 1085f2c:	108136c0 	call	108136c <xQueueGenericSend>
		alt_putstr("initialisation function\n");
 1085f30:	01004274 	movhi	r4,265
 1085f34:	2122e604 	addi	r4,r4,-29800
 1085f38:	1086f7c0 	call	1086f7c <alt_putstr>
		//display and cursor control
		data = 0x0C;
 1085f3c:	00800304 	movi	r2,12
 1085f40:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
 1085f44:	000f883a 	mov	r7,zero
 1085f48:	01bfffc4 	movi	r6,-1
 1085f4c:	e17ffb04 	addi	r5,fp,-20
 1085f50:	e13ffd17 	ldw	r4,-12(fp)
 1085f54:	108136c0 	call	108136c <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
 1085f58:	e0bffc04 	addi	r2,fp,-16
 1085f5c:	000f883a 	mov	r7,zero
 1085f60:	01bfffc4 	movi	r6,-1
 1085f64:	100b883a 	mov	r5,r2
 1085f68:	e13ffe17 	ldw	r4,-8(fp)
 1085f6c:	108136c0 	call	108136c <xQueueGenericSend>
		alt_putstr("initialisation display\n");
 1085f70:	01004274 	movhi	r4,265
 1085f74:	2122ed04 	addi	r4,r4,-29772
 1085f78:	1086f7c0 	call	1086f7c <alt_putstr>
		//display clear
		data = 0x01;
 1085f7c:	00800044 	movi	r2,1
 1085f80:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
 1085f84:	000f883a 	mov	r7,zero
 1085f88:	01bfffc4 	movi	r6,-1
 1085f8c:	e17ffb04 	addi	r5,fp,-20
 1085f90:	e13ffd17 	ldw	r4,-12(fp)
 1085f94:	108136c0 	call	108136c <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
 1085f98:	e0bffc04 	addi	r2,fp,-16
 1085f9c:	000f883a 	mov	r7,zero
 1085fa0:	01bfffc4 	movi	r6,-1
 1085fa4:	100b883a 	mov	r5,r2
 1085fa8:	e13ffe17 	ldw	r4,-8(fp)
 1085fac:	108136c0 	call	108136c <xQueueGenericSend>
		alt_putstr("clear display\n");
 1085fb0:	01004274 	movhi	r4,265
 1085fb4:	2122f304 	addi	r4,r4,-29748
 1085fb8:	1086f7c0 	call	1086f7c <alt_putstr>
		//entry mode set
		data = 0x07;
 1085fbc:	008001c4 	movi	r2,7
 1085fc0:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
 1085fc4:	000f883a 	mov	r7,zero
 1085fc8:	01bfffc4 	movi	r6,-1
 1085fcc:	e17ffb04 	addi	r5,fp,-20
 1085fd0:	e13ffd17 	ldw	r4,-12(fp)
 1085fd4:	108136c0 	call	108136c <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
 1085fd8:	e0bffc04 	addi	r2,fp,-16
 1085fdc:	000f883a 	mov	r7,zero
 1085fe0:	01bfffc4 	movi	r6,-1
 1085fe4:	100b883a 	mov	r5,r2
 1085fe8:	e13ffe17 	ldw	r4,-8(fp)
 1085fec:	108136c0 	call	108136c <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
 1085ff0:	000f883a 	mov	r7,zero
 1085ff4:	000d883a 	mov	r6,zero
 1085ff8:	000b883a 	mov	r5,zero
 1085ffc:	e13fff17 	ldw	r4,-4(fp)
 1086000:	108136c0 	call	108136c <xQueueGenericSend>
	}
	alt_putstr("initialisation finished\n");
 1086004:	01004274 	movhi	r4,265
 1086008:	2122f704 	addi	r4,r4,-29732
 108600c:	1086f7c0 	call	1086f7c <alt_putstr>
	/* hd44780_clear();
	hd44780_home(); */
}
 1086010:	0001883a 	nop
 1086014:	e037883a 	mov	sp,fp
 1086018:	dfc00117 	ldw	ra,4(sp)
 108601c:	df000017 	ldw	fp,0(sp)
 1086020:	dec00204 	addi	sp,sp,8
 1086024:	f800283a 	ret

01086028 <sayHello>:

xQueueHandle Queue_lcd_data, Queue_lcd_rs;
xSemaphoreHandle Mutex_write_lcd;
int n = 0;

void sayHello( void *p){
 1086028:	defff304 	addi	sp,sp,-52
 108602c:	dfc00c15 	stw	ra,48(sp)
 1086030:	df000b15 	stw	fp,44(sp)
 1086034:	df000b04 	addi	fp,sp,44
 1086038:	e13fff15 	stw	r4,-4(fp)
	char data[] = "%s, %s, %d, ", data2[] = "asd", data3[] = "sdf";
 108603c:	00880b34 	movhi	r2,8236
 1086040:	109cc944 	addi	r2,r2,29477
 1086044:	e0bff915 	stw	r2,-28(fp)
 1086048:	00880b34 	movhi	r2,8236
 108604c:	109cc944 	addi	r2,r2,29477
 1086050:	e0bffa15 	stw	r2,-24(fp)
 1086054:	00880b34 	movhi	r2,8236
 1086058:	10990944 	addi	r2,r2,25637
 108605c:	e0bffb15 	stw	r2,-20(fp)
 1086060:	e03ffc05 	stb	zero,-16(fp)
 1086064:	00801844 	movi	r2,97
 1086068:	e0bffc45 	stb	r2,-15(fp)
 108606c:	00801cc4 	movi	r2,115
 1086070:	e0bffc85 	stb	r2,-14(fp)
 1086074:	00801904 	movi	r2,100
 1086078:	e0bffcc5 	stb	r2,-13(fp)
 108607c:	e03ffd05 	stb	zero,-12(fp)
 1086080:	00801cc4 	movi	r2,115
 1086084:	e0bffd45 	stb	r2,-11(fp)
 1086088:	00801904 	movi	r2,100
 108608c:	e0bffd85 	stb	r2,-10(fp)
 1086090:	00801984 	movi	r2,102
 1086094:	e0bffdc5 	stb	r2,-9(fp)
 1086098:	e03ffe05 	stb	zero,-8(fp)
	int data4 = 20;
 108609c:	00800504 	movi	r2,20
 10860a0:	e0bff815 	stw	r2,-32(fp)
while(1){
	printf("Hello, world!\n");
 10860a4:	01004274 	movhi	r4,265
 10860a8:	2122fe04 	addi	r4,r4,-29704
 10860ac:	10864040 	call	1086404 <puts>
	hd44780_printf(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, &data, data2, data3, data4);
 10860b0:	00804274 	movhi	r2,265
 10860b4:	10acca04 	addi	r2,r2,-19672
 10860b8:	10c00017 	ldw	r3,0(r2)
 10860bc:	00804274 	movhi	r2,265
 10860c0:	10acc904 	addi	r2,r2,-19676
 10860c4:	11000017 	ldw	r4,0(r2)
 10860c8:	00804274 	movhi	r2,265
 10860cc:	10accb04 	addi	r2,r2,-19668
 10860d0:	11400017 	ldw	r5,0(r2)
 10860d4:	e1bff904 	addi	r6,fp,-28
 10860d8:	e0bff817 	ldw	r2,-32(fp)
 10860dc:	d8800215 	stw	r2,8(sp)
 10860e0:	e0bffd44 	addi	r2,fp,-11
 10860e4:	d8800115 	stw	r2,4(sp)
 10860e8:	e0bffc44 	addi	r2,fp,-15
 10860ec:	d8800015 	stw	r2,0(sp)
 10860f0:	300f883a 	mov	r7,r6
 10860f4:	280d883a 	mov	r6,r5
 10860f8:	200b883a 	mov	r5,r4
 10860fc:	1809883a 	mov	r4,r3
 1086100:	1085e000 	call	1085e00 <hd44780_printf>

	vTaskDelay(1000*10);
 1086104:	0109c404 	movi	r4,10000
 1086108:	10837b00 	call	10837b0 <vTaskDelay>
 }
 108610c:	003fe506 	br	10860a4 <__alt_data_end+0xfffb0974>

01086110 <sayInBitween>:
}


void sayInBitween (void *p){
 1086110:	defffd04 	addi	sp,sp,-12
 1086114:	dfc00215 	stw	ra,8(sp)
 1086118:	df000115 	stw	fp,4(sp)
 108611c:	df000104 	addi	fp,sp,4
 1086120:	e13fff15 	stw	r4,-4(fp)
while(1){
 printf("In between\n");
 1086124:	01004274 	movhi	r4,265
 1086128:	21230204 	addi	r4,r4,-29688
 108612c:	10864040 	call	1086404 <puts>
 IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, 1 << n);
 1086130:	d0a4e117 	ldw	r2,-27772(gp)
 1086134:	00c00044 	movi	r3,1
 1086138:	1886983a 	sll	r3,r3,r2
 108613c:	00804434 	movhi	r2,272
 1086140:	10842404 	addi	r2,r2,4240
 1086144:	10c00035 	stwio	r3,0(r2)
 n++;
 1086148:	d0a4e117 	ldw	r2,-27772(gp)
 108614c:	10800044 	addi	r2,r2,1
 1086150:	d0a4e115 	stw	r2,-27772(gp)
 if (n == 10) n = 0;
 1086154:	d0a4e117 	ldw	r2,-27772(gp)
 1086158:	10800298 	cmpnei	r2,r2,10
 108615c:	1000011e 	bne	r2,zero,1086164 <sayInBitween+0x54>
 1086160:	d024e115 	stw	zero,-27772(gp)
 vTaskDelay(300*10);
 1086164:	0102ee04 	movi	r4,3000
 1086168:	10837b00 	call	10837b0 <vTaskDelay>
 }
 108616c:	003fed06 	br	1086124 <__alt_data_end+0xfffb09f4>

01086170 <task_lcd_write>:
}
void task_lcd_write(void *p)
{
 1086170:	defffb04 	addi	sp,sp,-20
 1086174:	dfc00415 	stw	ra,16(sp)
 1086178:	df000315 	stw	fp,12(sp)
 108617c:	df000304 	addi	fp,sp,12
 1086180:	e13fff15 	stw	r4,-4(fp)
	hd44780_init(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd);
 1086184:	00804274 	movhi	r2,265
 1086188:	10acca04 	addi	r2,r2,-19672
 108618c:	10c00017 	ldw	r3,0(r2)
 1086190:	00804274 	movhi	r2,265
 1086194:	10acc904 	addi	r2,r2,-19676
 1086198:	11000017 	ldw	r4,0(r2)
 108619c:	00804274 	movhi	r2,265
 10861a0:	10accb04 	addi	r2,r2,-19668
 10861a4:	10800017 	ldw	r2,0(r2)
 10861a8:	100d883a 	mov	r6,r2
 10861ac:	200b883a 	mov	r5,r4
 10861b0:	1809883a 	mov	r4,r3
 10861b4:	1085ebc0 	call	1085ebc <hd44780_init>
	int data, rs;
	while(1)
	{
		xQueueReceive(Queue_lcd_data, &data, portMAX_DELAY);
 10861b8:	00804274 	movhi	r2,265
 10861bc:	10acca04 	addi	r2,r2,-19672
 10861c0:	10800017 	ldw	r2,0(r2)
 10861c4:	01bfffc4 	movi	r6,-1
 10861c8:	e17ffd04 	addi	r5,fp,-12
 10861cc:	1009883a 	mov	r4,r2
 10861d0:	10816f00 	call	10816f0 <xQueueReceive>
		xQueueReceive(Queue_lcd_rs, &rs, portMAX_DELAY);
 10861d4:	00804274 	movhi	r2,265
 10861d8:	10acc904 	addi	r2,r2,-19676
 10861dc:	10800017 	ldw	r2,0(r2)
 10861e0:	e0fffe04 	addi	r3,fp,-8
 10861e4:	01bfffc4 	movi	r6,-1
 10861e8:	180b883a 	mov	r5,r3
 10861ec:	1009883a 	mov	r4,r2
 10861f0:	10816f00 	call	10816f0 <xQueueReceive>
		write(data, rs);
 10861f4:	e0bffd17 	ldw	r2,-12(fp)
 10861f8:	10803fcc 	andi	r2,r2,255
 10861fc:	e0fffe17 	ldw	r3,-8(fp)
 1086200:	180b883a 	mov	r5,r3
 1086204:	1009883a 	mov	r4,r2
 1086208:	10857ac0 	call	10857ac <write>
		while(!read_busy());
 108620c:	0001883a 	nop
 1086210:	10858200 	call	1085820 <read_busy>
 1086214:	103ffe26 	beq	r2,zero,1086210 <__alt_data_end+0xfffb0ae0>
	}
 1086218:	003fe706 	br	10861b8 <__alt_data_end+0xfffb0a88>

0108621c <main>:
}
int main()
{
 108621c:	defffc04 	addi	sp,sp,-16
 1086220:	dfc00315 	stw	ra,12(sp)
 1086224:	df000215 	stw	fp,8(sp)
 1086228:	df000204 	addi	fp,sp,8
	alt_putstr("Hello from Nios II!\n");
 108622c:	01004274 	movhi	r4,265
 1086230:	21230504 	addi	r4,r4,-29676
 1086234:	1086f7c0 	call	1086f7c <alt_putstr>
	Queue_lcd_data = xQueueCreate(100, 1);
 1086238:	000d883a 	mov	r6,zero
 108623c:	01400044 	movi	r5,1
 1086240:	01001904 	movi	r4,100
 1086244:	10810100 	call	1081010 <xQueueGenericCreate>
 1086248:	1007883a 	mov	r3,r2
 108624c:	00804274 	movhi	r2,265
 1086250:	10acca04 	addi	r2,r2,-19672
 1086254:	10c00015 	stw	r3,0(r2)
	Queue_lcd_rs = xQueueCreate(100, 1);
 1086258:	000d883a 	mov	r6,zero
 108625c:	01400044 	movi	r5,1
 1086260:	01001904 	movi	r4,100
 1086264:	10810100 	call	1081010 <xQueueGenericCreate>
 1086268:	1007883a 	mov	r3,r2
 108626c:	00804274 	movhi	r2,265
 1086270:	10acc904 	addi	r2,r2,-19676
 1086274:	10c00015 	stw	r3,0(r2)
	Mutex_write_lcd = xSemaphoreCreateMutex();
 1086278:	01000044 	movi	r4,1
 108627c:	108118c0 	call	108118c <xQueueCreateMutex>
 1086280:	1007883a 	mov	r3,r2
 1086284:	00804274 	movhi	r2,265
 1086288:	10accb04 	addi	r2,r2,-19668
 108628c:	10c00015 	stw	r3,0(r2)
	xTaskCreate(task_lcd_write, "task_lcd_write", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
 1086290:	d8000115 	stw	zero,4(sp)
 1086294:	00800084 	movi	r2,2
 1086298:	d8800015 	stw	r2,0(sp)
 108629c:	000f883a 	mov	r7,zero
 10862a0:	01810004 	movi	r6,1024
 10862a4:	01404274 	movhi	r5,265
 10862a8:	29630b04 	addi	r5,r5,-29652
 10862ac:	01004234 	movhi	r4,264
 10862b0:	21185c04 	addi	r4,r4,24944
 10862b4:	10832100 	call	1083210 <xTaskCreate>
	xTaskCreate(sayHello, "sayHello", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
 10862b8:	d8000115 	stw	zero,4(sp)
 10862bc:	00800084 	movi	r2,2
 10862c0:	d8800015 	stw	r2,0(sp)
 10862c4:	000f883a 	mov	r7,zero
 10862c8:	01810004 	movi	r6,1024
 10862cc:	01404274 	movhi	r5,265
 10862d0:	29630f04 	addi	r5,r5,-29636
 10862d4:	01004234 	movhi	r4,264
 10862d8:	21180a04 	addi	r4,r4,24616
 10862dc:	10832100 	call	1083210 <xTaskCreate>
	printf("sayHello inst\n");
 10862e0:	01004274 	movhi	r4,265
 10862e4:	21231204 	addi	r4,r4,-29624
 10862e8:	10864040 	call	1086404 <puts>
	xTaskCreate(sayInBitween, "sayInBitween",configMINIMAL_STACK_SIZE,NULL,2,NULL);
 10862ec:	d8000115 	stw	zero,4(sp)
 10862f0:	00800084 	movi	r2,2
 10862f4:	d8800015 	stw	r2,0(sp)
 10862f8:	000f883a 	mov	r7,zero
 10862fc:	01810004 	movi	r6,1024
 1086300:	01404274 	movhi	r5,265
 1086304:	29631604 	addi	r5,r5,-29608
 1086308:	01004234 	movhi	r4,264
 108630c:	21184404 	addi	r4,r4,24848
 1086310:	10832100 	call	1083210 <xTaskCreate>
	printf("sayInBitween inst\n");
 1086314:	01004274 	movhi	r4,265
 1086318:	21231a04 	addi	r4,r4,-29592
 108631c:	10864040 	call	1086404 <puts>
	vTaskStartScheduler();
 1086320:	1083d680 	call	1083d68 <vTaskStartScheduler>
	return 0;
 1086324:	0005883a 	mov	r2,zero
}
 1086328:	e037883a 	mov	sp,fp
 108632c:	dfc00117 	ldw	ra,4(sp)
 1086330:	df000017 	ldw	fp,0(sp)
 1086334:	dec00204 	addi	sp,sp,8
 1086338:	f800283a 	ret

0108633c <memcpy>:
 108633c:	2005883a 	mov	r2,r4
 1086340:	2007883a 	mov	r3,r4
 1086344:	218d883a 	add	r6,r4,r6
 1086348:	19800526 	beq	r3,r6,1086360 <memcpy+0x24>
 108634c:	29000003 	ldbu	r4,0(r5)
 1086350:	18c00044 	addi	r3,r3,1
 1086354:	29400044 	addi	r5,r5,1
 1086358:	193fffc5 	stb	r4,-1(r3)
 108635c:	003ffa06 	br	1086348 <__alt_data_end+0xfffb0c18>
 1086360:	f800283a 	ret

01086364 <memset>:
 1086364:	2005883a 	mov	r2,r4
 1086368:	2007883a 	mov	r3,r4
 108636c:	218d883a 	add	r6,r4,r6
 1086370:	19800326 	beq	r3,r6,1086380 <memset+0x1c>
 1086374:	19400005 	stb	r5,0(r3)
 1086378:	18c00044 	addi	r3,r3,1
 108637c:	003ffc06 	br	1086370 <__alt_data_end+0xfffb0c40>
 1086380:	f800283a 	ret

01086384 <_puts_r>:
 1086384:	defffd04 	addi	sp,sp,-12
 1086388:	dc000015 	stw	r16,0(sp)
 108638c:	2021883a 	mov	r16,r4
 1086390:	2809883a 	mov	r4,r5
 1086394:	dfc00215 	stw	ra,8(sp)
 1086398:	dc400115 	stw	r17,4(sp)
 108639c:	2823883a 	mov	r17,r5
 10863a0:	10864180 	call	1086418 <strlen>
 10863a4:	81400217 	ldw	r5,8(r16)
 10863a8:	01004234 	movhi	r4,264
 10863ac:	21192b04 	addi	r4,r4,25772
 10863b0:	29000115 	stw	r4,4(r5)
 10863b4:	100f883a 	mov	r7,r2
 10863b8:	880d883a 	mov	r6,r17
 10863bc:	8009883a 	mov	r4,r16
 10863c0:	10864ac0 	call	10864ac <__sfvwrite_small_dev>
 10863c4:	00ffffc4 	movi	r3,-1
 10863c8:	10c00926 	beq	r2,r3,10863f0 <_puts_r+0x6c>
 10863cc:	81400217 	ldw	r5,8(r16)
 10863d0:	01804274 	movhi	r6,265
 10863d4:	01c00044 	movi	r7,1
 10863d8:	28800117 	ldw	r2,4(r5)
 10863dc:	31a31f04 	addi	r6,r6,-29572
 10863e0:	8009883a 	mov	r4,r16
 10863e4:	103ee83a 	callr	r2
 10863e8:	10bfffe0 	cmpeqi	r2,r2,-1
 10863ec:	0085c83a 	sub	r2,zero,r2
 10863f0:	dfc00217 	ldw	ra,8(sp)
 10863f4:	dc400117 	ldw	r17,4(sp)
 10863f8:	dc000017 	ldw	r16,0(sp)
 10863fc:	dec00304 	addi	sp,sp,12
 1086400:	f800283a 	ret

01086404 <puts>:
 1086404:	00804274 	movhi	r2,265
 1086408:	10a7e804 	addi	r2,r2,-24672
 108640c:	200b883a 	mov	r5,r4
 1086410:	11000017 	ldw	r4,0(r2)
 1086414:	10863841 	jmpi	1086384 <_puts_r>

01086418 <strlen>:
 1086418:	2005883a 	mov	r2,r4
 108641c:	10c00007 	ldb	r3,0(r2)
 1086420:	18000226 	beq	r3,zero,108642c <strlen+0x14>
 1086424:	10800044 	addi	r2,r2,1
 1086428:	003ffc06 	br	108641c <__alt_data_end+0xfffb0cec>
 108642c:	1105c83a 	sub	r2,r2,r4
 1086430:	f800283a 	ret

01086434 <_vsprintf_r>:
 1086434:	defff804 	addi	sp,sp,-32
 1086438:	00808204 	movi	r2,520
 108643c:	d880000d 	sth	r2,0(sp)
 1086440:	00a00034 	movhi	r2,32768
 1086444:	10bfffc4 	addi	r2,r2,-1
 1086448:	d8800515 	stw	r2,20(sp)
 108644c:	d8800315 	stw	r2,12(sp)
 1086450:	00bfffc4 	movi	r2,-1
 1086454:	d880008d 	sth	r2,2(sp)
 1086458:	00804234 	movhi	r2,264
 108645c:	d9400415 	stw	r5,16(sp)
 1086460:	d9400215 	stw	r5,8(sp)
 1086464:	10995904 	addi	r2,r2,25956
 1086468:	d80b883a 	mov	r5,sp
 108646c:	dfc00715 	stw	ra,28(sp)
 1086470:	d8800115 	stw	r2,4(sp)
 1086474:	d8000615 	stw	zero,24(sp)
 1086478:	10866d80 	call	10866d8 <___svfprintf_internal_r>
 108647c:	d8c00417 	ldw	r3,16(sp)
 1086480:	18000005 	stb	zero,0(r3)
 1086484:	dfc00717 	ldw	ra,28(sp)
 1086488:	dec00804 	addi	sp,sp,32
 108648c:	f800283a 	ret

01086490 <vsprintf>:
 1086490:	00804274 	movhi	r2,265
 1086494:	10a7e804 	addi	r2,r2,-24672
 1086498:	300f883a 	mov	r7,r6
 108649c:	280d883a 	mov	r6,r5
 10864a0:	200b883a 	mov	r5,r4
 10864a4:	11000017 	ldw	r4,0(r2)
 10864a8:	10864341 	jmpi	1086434 <_vsprintf_r>

010864ac <__sfvwrite_small_dev>:
 10864ac:	2880000b 	ldhu	r2,0(r5)
 10864b0:	1080020c 	andi	r2,r2,8
 10864b4:	10002126 	beq	r2,zero,108653c <__sfvwrite_small_dev+0x90>
 10864b8:	2880008f 	ldh	r2,2(r5)
 10864bc:	defffa04 	addi	sp,sp,-24
 10864c0:	dc000015 	stw	r16,0(sp)
 10864c4:	dfc00515 	stw	ra,20(sp)
 10864c8:	dd000415 	stw	r20,16(sp)
 10864cc:	dcc00315 	stw	r19,12(sp)
 10864d0:	dc800215 	stw	r18,8(sp)
 10864d4:	dc400115 	stw	r17,4(sp)
 10864d8:	2821883a 	mov	r16,r5
 10864dc:	10001216 	blt	r2,zero,1086528 <__sfvwrite_small_dev+0x7c>
 10864e0:	2027883a 	mov	r19,r4
 10864e4:	3025883a 	mov	r18,r6
 10864e8:	3823883a 	mov	r17,r7
 10864ec:	05010004 	movi	r20,1024
 10864f0:	04400b0e 	bge	zero,r17,1086520 <__sfvwrite_small_dev+0x74>
 10864f4:	880f883a 	mov	r7,r17
 10864f8:	a440010e 	bge	r20,r17,1086500 <__sfvwrite_small_dev+0x54>
 10864fc:	01c10004 	movi	r7,1024
 1086500:	8140008f 	ldh	r5,2(r16)
 1086504:	900d883a 	mov	r6,r18
 1086508:	9809883a 	mov	r4,r19
 108650c:	1086c180 	call	1086c18 <_write_r>
 1086510:	0080050e 	bge	zero,r2,1086528 <__sfvwrite_small_dev+0x7c>
 1086514:	88a3c83a 	sub	r17,r17,r2
 1086518:	90a5883a 	add	r18,r18,r2
 108651c:	003ff406 	br	10864f0 <__alt_data_end+0xfffb0dc0>
 1086520:	0005883a 	mov	r2,zero
 1086524:	00000706 	br	1086544 <__sfvwrite_small_dev+0x98>
 1086528:	8080000b 	ldhu	r2,0(r16)
 108652c:	10801014 	ori	r2,r2,64
 1086530:	8080000d 	sth	r2,0(r16)
 1086534:	00bfffc4 	movi	r2,-1
 1086538:	00000206 	br	1086544 <__sfvwrite_small_dev+0x98>
 108653c:	00bfffc4 	movi	r2,-1
 1086540:	f800283a 	ret
 1086544:	dfc00517 	ldw	ra,20(sp)
 1086548:	dd000417 	ldw	r20,16(sp)
 108654c:	dcc00317 	ldw	r19,12(sp)
 1086550:	dc800217 	ldw	r18,8(sp)
 1086554:	dc400117 	ldw	r17,4(sp)
 1086558:	dc000017 	ldw	r16,0(sp)
 108655c:	dec00604 	addi	sp,sp,24
 1086560:	f800283a 	ret

01086564 <__sfvwrite_small_str>:
 1086564:	2880000b 	ldhu	r2,0(r5)
 1086568:	10c0020c 	andi	r3,r2,8
 108656c:	18002026 	beq	r3,zero,10865f0 <__sfvwrite_small_str+0x8c>
 1086570:	28c0008f 	ldh	r3,2(r5)
 1086574:	defffd04 	addi	sp,sp,-12
 1086578:	dc000015 	stw	r16,0(sp)
 108657c:	dfc00215 	stw	ra,8(sp)
 1086580:	dc400115 	stw	r17,4(sp)
 1086584:	2821883a 	mov	r16,r5
 1086588:	1800150e 	bge	r3,zero,10865e0 <__sfvwrite_small_str+0x7c>
 108658c:	10c0800c 	andi	r3,r2,512
 1086590:	18001326 	beq	r3,zero,10865e0 <__sfvwrite_small_str+0x7c>
 1086594:	2c400517 	ldw	r17,20(r5)
 1086598:	89c0030e 	bge	r17,r7,10865a8 <__sfvwrite_small_str+0x44>
 108659c:	10c0200c 	andi	r3,r2,128
 10865a0:	18000326 	beq	r3,zero,10865b0 <__sfvwrite_small_str+0x4c>
 10865a4:	00000e06 	br	10865e0 <__sfvwrite_small_str+0x7c>
 10865a8:	3c40010e 	bge	r7,r17,10865b0 <__sfvwrite_small_str+0x4c>
 10865ac:	3823883a 	mov	r17,r7
 10865b0:	81000417 	ldw	r4,16(r16)
 10865b4:	300b883a 	mov	r5,r6
 10865b8:	880d883a 	mov	r6,r17
 10865bc:	108660c0 	call	108660c <memmove>
 10865c0:	80800517 	ldw	r2,20(r16)
 10865c4:	1445c83a 	sub	r2,r2,r17
 10865c8:	80800515 	stw	r2,20(r16)
 10865cc:	80800417 	ldw	r2,16(r16)
 10865d0:	1463883a 	add	r17,r2,r17
 10865d4:	84400415 	stw	r17,16(r16)
 10865d8:	0005883a 	mov	r2,zero
 10865dc:	00000606 	br	10865f8 <__sfvwrite_small_str+0x94>
 10865e0:	10801014 	ori	r2,r2,64
 10865e4:	8080000d 	sth	r2,0(r16)
 10865e8:	00bfffc4 	movi	r2,-1
 10865ec:	00000206 	br	10865f8 <__sfvwrite_small_str+0x94>
 10865f0:	00bfffc4 	movi	r2,-1
 10865f4:	f800283a 	ret
 10865f8:	dfc00217 	ldw	ra,8(sp)
 10865fc:	dc400117 	ldw	r17,4(sp)
 1086600:	dc000017 	ldw	r16,0(sp)
 1086604:	dec00304 	addi	sp,sp,12
 1086608:	f800283a 	ret

0108660c <memmove>:
 108660c:	2005883a 	mov	r2,r4
 1086610:	218f883a 	add	r7,r4,r6
 1086614:	29000236 	bltu	r5,r4,1086620 <memmove+0x14>
 1086618:	1007883a 	mov	r3,r2
 108661c:	00000c06 	br	1086650 <memmove+0x44>
 1086620:	2987883a 	add	r3,r5,r6
 1086624:	20fffc2e 	bgeu	r4,r3,1086618 <__alt_data_end+0xfffb0ee8>
 1086628:	380b883a 	mov	r5,r7
 108662c:	30cdc83a 	sub	r6,r6,r3
 1086630:	1989883a 	add	r4,r3,r6
 1086634:	20000526 	beq	r4,zero,108664c <memmove+0x40>
 1086638:	18ffffc4 	addi	r3,r3,-1
 108663c:	19000003 	ldbu	r4,0(r3)
 1086640:	297fffc4 	addi	r5,r5,-1
 1086644:	29000005 	stb	r4,0(r5)
 1086648:	003ff906 	br	1086630 <__alt_data_end+0xfffb0f00>
 108664c:	f800283a 	ret
 1086650:	19c00526 	beq	r3,r7,1086668 <memmove+0x5c>
 1086654:	29000003 	ldbu	r4,0(r5)
 1086658:	18c00044 	addi	r3,r3,1
 108665c:	29400044 	addi	r5,r5,1
 1086660:	193fffc5 	stb	r4,-1(r3)
 1086664:	003ffa06 	br	1086650 <__alt_data_end+0xfffb0f20>
 1086668:	f800283a 	ret

0108666c <print_repeat>:
 108666c:	defffb04 	addi	sp,sp,-20
 1086670:	dc800315 	stw	r18,12(sp)
 1086674:	dc400215 	stw	r17,8(sp)
 1086678:	dc000115 	stw	r16,4(sp)
 108667c:	dfc00415 	stw	ra,16(sp)
 1086680:	2025883a 	mov	r18,r4
 1086684:	2823883a 	mov	r17,r5
 1086688:	d9800005 	stb	r6,0(sp)
 108668c:	3821883a 	mov	r16,r7
 1086690:	04000a0e 	bge	zero,r16,10866bc <print_repeat+0x50>
 1086694:	88800117 	ldw	r2,4(r17)
 1086698:	01c00044 	movi	r7,1
 108669c:	d80d883a 	mov	r6,sp
 10866a0:	880b883a 	mov	r5,r17
 10866a4:	9009883a 	mov	r4,r18
 10866a8:	103ee83a 	callr	r2
 10866ac:	843fffc4 	addi	r16,r16,-1
 10866b0:	103ff726 	beq	r2,zero,1086690 <__alt_data_end+0xfffb0f60>
 10866b4:	00bfffc4 	movi	r2,-1
 10866b8:	00000106 	br	10866c0 <print_repeat+0x54>
 10866bc:	0005883a 	mov	r2,zero
 10866c0:	dfc00417 	ldw	ra,16(sp)
 10866c4:	dc800317 	ldw	r18,12(sp)
 10866c8:	dc400217 	ldw	r17,8(sp)
 10866cc:	dc000117 	ldw	r16,4(sp)
 10866d0:	dec00504 	addi	sp,sp,20
 10866d4:	f800283a 	ret

010866d8 <___svfprintf_internal_r>:
 10866d8:	deffe504 	addi	sp,sp,-108
 10866dc:	d8c00804 	addi	r3,sp,32
 10866e0:	df001915 	stw	fp,100(sp)
 10866e4:	ddc01815 	stw	r23,96(sp)
 10866e8:	dd801715 	stw	r22,92(sp)
 10866ec:	dd401615 	stw	r21,88(sp)
 10866f0:	dd001515 	stw	r20,84(sp)
 10866f4:	dcc01415 	stw	r19,80(sp)
 10866f8:	dc801315 	stw	r18,76(sp)
 10866fc:	dc401215 	stw	r17,72(sp)
 1086700:	dc001115 	stw	r16,68(sp)
 1086704:	dfc01a15 	stw	ra,104(sp)
 1086708:	2027883a 	mov	r19,r4
 108670c:	2839883a 	mov	fp,r5
 1086710:	382d883a 	mov	r22,r7
 1086714:	d9800f15 	stw	r6,60(sp)
 1086718:	0021883a 	mov	r16,zero
 108671c:	d8000e15 	stw	zero,56(sp)
 1086720:	002f883a 	mov	r23,zero
 1086724:	002b883a 	mov	r21,zero
 1086728:	0025883a 	mov	r18,zero
 108672c:	0023883a 	mov	r17,zero
 1086730:	d8000c15 	stw	zero,48(sp)
 1086734:	d8000b15 	stw	zero,44(sp)
 1086738:	0029883a 	mov	r20,zero
 108673c:	d8c00915 	stw	r3,36(sp)
 1086740:	d8c00f17 	ldw	r3,60(sp)
 1086744:	19000003 	ldbu	r4,0(r3)
 1086748:	20803fcc 	andi	r2,r4,255
 108674c:	1080201c 	xori	r2,r2,128
 1086750:	10bfe004 	addi	r2,r2,-128
 1086754:	10011c26 	beq	r2,zero,1086bc8 <___svfprintf_internal_r+0x4f0>
 1086758:	00c00044 	movi	r3,1
 108675c:	a0c01426 	beq	r20,r3,10867b0 <___svfprintf_internal_r+0xd8>
 1086760:	1d000216 	blt	r3,r20,108676c <___svfprintf_internal_r+0x94>
 1086764:	a0000626 	beq	r20,zero,1086780 <___svfprintf_internal_r+0xa8>
 1086768:	00011306 	br	1086bb8 <___svfprintf_internal_r+0x4e0>
 108676c:	01400084 	movi	r5,2
 1086770:	a1401d26 	beq	r20,r5,10867e8 <___svfprintf_internal_r+0x110>
 1086774:	014000c4 	movi	r5,3
 1086778:	a1402926 	beq	r20,r5,1086820 <___svfprintf_internal_r+0x148>
 108677c:	00010e06 	br	1086bb8 <___svfprintf_internal_r+0x4e0>
 1086780:	01400944 	movi	r5,37
 1086784:	1140fb26 	beq	r2,r5,1086b74 <___svfprintf_internal_r+0x49c>
 1086788:	e0800117 	ldw	r2,4(fp)
 108678c:	d9000005 	stb	r4,0(sp)
 1086790:	01c00044 	movi	r7,1
 1086794:	d80d883a 	mov	r6,sp
 1086798:	e00b883a 	mov	r5,fp
 108679c:	9809883a 	mov	r4,r19
 10867a0:	103ee83a 	callr	r2
 10867a4:	1000d61e 	bne	r2,zero,1086b00 <___svfprintf_internal_r+0x428>
 10867a8:	84000044 	addi	r16,r16,1
 10867ac:	00010206 	br	1086bb8 <___svfprintf_internal_r+0x4e0>
 10867b0:	01400c04 	movi	r5,48
 10867b4:	1140f826 	beq	r2,r5,1086b98 <___svfprintf_internal_r+0x4c0>
 10867b8:	01400944 	movi	r5,37
 10867bc:	11400a1e 	bne	r2,r5,10867e8 <___svfprintf_internal_r+0x110>
 10867c0:	d8800005 	stb	r2,0(sp)
 10867c4:	e0800117 	ldw	r2,4(fp)
 10867c8:	a00f883a 	mov	r7,r20
 10867cc:	d80d883a 	mov	r6,sp
 10867d0:	e00b883a 	mov	r5,fp
 10867d4:	9809883a 	mov	r4,r19
 10867d8:	103ee83a 	callr	r2
 10867dc:	1000c81e 	bne	r2,zero,1086b00 <___svfprintf_internal_r+0x428>
 10867e0:	84000044 	addi	r16,r16,1
 10867e4:	0000f306 	br	1086bb4 <___svfprintf_internal_r+0x4dc>
 10867e8:	217ff404 	addi	r5,r4,-48
 10867ec:	29403fcc 	andi	r5,r5,255
 10867f0:	00c00244 	movi	r3,9
 10867f4:	19400736 	bltu	r3,r5,1086814 <___svfprintf_internal_r+0x13c>
 10867f8:	00bfffc4 	movi	r2,-1
 10867fc:	88800226 	beq	r17,r2,1086808 <___svfprintf_internal_r+0x130>
 1086800:	8c4002a4 	muli	r17,r17,10
 1086804:	00000106 	br	108680c <___svfprintf_internal_r+0x134>
 1086808:	0023883a 	mov	r17,zero
 108680c:	2c63883a 	add	r17,r5,r17
 1086810:	0000e206 	br	1086b9c <___svfprintf_internal_r+0x4c4>
 1086814:	01400b84 	movi	r5,46
 1086818:	1140e426 	beq	r2,r5,1086bac <___svfprintf_internal_r+0x4d4>
 108681c:	05000084 	movi	r20,2
 1086820:	213ff404 	addi	r4,r4,-48
 1086824:	21003fcc 	andi	r4,r4,255
 1086828:	00c00244 	movi	r3,9
 108682c:	19000736 	bltu	r3,r4,108684c <___svfprintf_internal_r+0x174>
 1086830:	00bfffc4 	movi	r2,-1
 1086834:	90800226 	beq	r18,r2,1086840 <___svfprintf_internal_r+0x168>
 1086838:	948002a4 	muli	r18,r18,10
 108683c:	00000106 	br	1086844 <___svfprintf_internal_r+0x16c>
 1086840:	0025883a 	mov	r18,zero
 1086844:	24a5883a 	add	r18,r4,r18
 1086848:	0000db06 	br	1086bb8 <___svfprintf_internal_r+0x4e0>
 108684c:	00c01b04 	movi	r3,108
 1086850:	10c0d426 	beq	r2,r3,1086ba4 <___svfprintf_internal_r+0x4cc>
 1086854:	013fffc4 	movi	r4,-1
 1086858:	91000226 	beq	r18,r4,1086864 <___svfprintf_internal_r+0x18c>
 108685c:	d8000b15 	stw	zero,44(sp)
 1086860:	00000106 	br	1086868 <___svfprintf_internal_r+0x190>
 1086864:	04800044 	movi	r18,1
 1086868:	01001a44 	movi	r4,105
 108686c:	11001626 	beq	r2,r4,10868c8 <___svfprintf_internal_r+0x1f0>
 1086870:	20800916 	blt	r4,r2,1086898 <___svfprintf_internal_r+0x1c0>
 1086874:	010018c4 	movi	r4,99
 1086878:	11008a26 	beq	r2,r4,1086aa4 <___svfprintf_internal_r+0x3cc>
 108687c:	01001904 	movi	r4,100
 1086880:	11001126 	beq	r2,r4,10868c8 <___svfprintf_internal_r+0x1f0>
 1086884:	01001604 	movi	r4,88
 1086888:	1100ca1e 	bne	r2,r4,1086bb4 <___svfprintf_internal_r+0x4dc>
 108688c:	00c00044 	movi	r3,1
 1086890:	d8c00e15 	stw	r3,56(sp)
 1086894:	00001406 	br	10868e8 <___svfprintf_internal_r+0x210>
 1086898:	01001cc4 	movi	r4,115
 108689c:	11009a26 	beq	r2,r4,1086b08 <___svfprintf_internal_r+0x430>
 10868a0:	20800416 	blt	r4,r2,10868b4 <___svfprintf_internal_r+0x1dc>
 10868a4:	01001bc4 	movi	r4,111
 10868a8:	1100c21e 	bne	r2,r4,1086bb4 <___svfprintf_internal_r+0x4dc>
 10868ac:	05400204 	movi	r21,8
 10868b0:	00000e06 	br	10868ec <___svfprintf_internal_r+0x214>
 10868b4:	01001d44 	movi	r4,117
 10868b8:	11000c26 	beq	r2,r4,10868ec <___svfprintf_internal_r+0x214>
 10868bc:	01001e04 	movi	r4,120
 10868c0:	11000926 	beq	r2,r4,10868e8 <___svfprintf_internal_r+0x210>
 10868c4:	0000bb06 	br	1086bb4 <___svfprintf_internal_r+0x4dc>
 10868c8:	b5000104 	addi	r20,r22,4
 10868cc:	b8000726 	beq	r23,zero,10868ec <___svfprintf_internal_r+0x214>
 10868d0:	dd000d15 	stw	r20,52(sp)
 10868d4:	b5800017 	ldw	r22,0(r22)
 10868d8:	b000080e 	bge	r22,zero,10868fc <___svfprintf_internal_r+0x224>
 10868dc:	05adc83a 	sub	r22,zero,r22
 10868e0:	02800044 	movi	r10,1
 10868e4:	00000606 	br	1086900 <___svfprintf_internal_r+0x228>
 10868e8:	05400404 	movi	r21,16
 10868ec:	b0c00104 	addi	r3,r22,4
 10868f0:	d8c00d15 	stw	r3,52(sp)
 10868f4:	b5800017 	ldw	r22,0(r22)
 10868f8:	002f883a 	mov	r23,zero
 10868fc:	0015883a 	mov	r10,zero
 1086900:	d829883a 	mov	r20,sp
 1086904:	b0001426 	beq	r22,zero,1086958 <___svfprintf_internal_r+0x280>
 1086908:	b009883a 	mov	r4,r22
 108690c:	a80b883a 	mov	r5,r21
 1086910:	da801015 	stw	r10,64(sp)
 1086914:	1086d680 	call	1086d68 <__udivsi3>
 1086918:	1549383a 	mul	r4,r2,r21
 108691c:	00c00244 	movi	r3,9
 1086920:	da801017 	ldw	r10,64(sp)
 1086924:	b12dc83a 	sub	r22,r22,r4
 1086928:	1d800216 	blt	r3,r22,1086934 <___svfprintf_internal_r+0x25c>
 108692c:	b5800c04 	addi	r22,r22,48
 1086930:	00000506 	br	1086948 <___svfprintf_internal_r+0x270>
 1086934:	d8c00e17 	ldw	r3,56(sp)
 1086938:	18000226 	beq	r3,zero,1086944 <___svfprintf_internal_r+0x26c>
 108693c:	b5800dc4 	addi	r22,r22,55
 1086940:	00000106 	br	1086948 <___svfprintf_internal_r+0x270>
 1086944:	b58015c4 	addi	r22,r22,87
 1086948:	a5800005 	stb	r22,0(r20)
 108694c:	a5000044 	addi	r20,r20,1
 1086950:	102d883a 	mov	r22,r2
 1086954:	003feb06 	br	1086904 <__alt_data_end+0xfffb11d4>
 1086958:	a6c7c83a 	sub	r3,r20,sp
 108695c:	d8c00a15 	stw	r3,40(sp)
 1086960:	90c5c83a 	sub	r2,r18,r3
 1086964:	00800a0e 	bge	zero,r2,1086990 <___svfprintf_internal_r+0x2b8>
 1086968:	a085883a 	add	r2,r20,r2
 108696c:	01400c04 	movi	r5,48
 1086970:	d8c00917 	ldw	r3,36(sp)
 1086974:	a009883a 	mov	r4,r20
 1086978:	a0c0032e 	bgeu	r20,r3,1086988 <___svfprintf_internal_r+0x2b0>
 108697c:	a5000044 	addi	r20,r20,1
 1086980:	21400005 	stb	r5,0(r4)
 1086984:	a0bffa1e 	bne	r20,r2,1086970 <__alt_data_end+0xfffb1240>
 1086988:	a6c7c83a 	sub	r3,r20,sp
 108698c:	d8c00a15 	stw	r3,40(sp)
 1086990:	d8c00a17 	ldw	r3,40(sp)
 1086994:	50d3883a 	add	r9,r10,r3
 1086998:	d8c00b17 	ldw	r3,44(sp)
 108699c:	8a6dc83a 	sub	r22,r17,r9
 10869a0:	18001726 	beq	r3,zero,1086a00 <___svfprintf_internal_r+0x328>
 10869a4:	50000a26 	beq	r10,zero,10869d0 <___svfprintf_internal_r+0x2f8>
 10869a8:	00800b44 	movi	r2,45
 10869ac:	d8800805 	stb	r2,32(sp)
 10869b0:	e0800117 	ldw	r2,4(fp)
 10869b4:	01c00044 	movi	r7,1
 10869b8:	d9800804 	addi	r6,sp,32
 10869bc:	e00b883a 	mov	r5,fp
 10869c0:	9809883a 	mov	r4,r19
 10869c4:	103ee83a 	callr	r2
 10869c8:	10004d1e 	bne	r2,zero,1086b00 <___svfprintf_internal_r+0x428>
 10869cc:	84000044 	addi	r16,r16,1
 10869d0:	0580070e 	bge	zero,r22,10869f0 <___svfprintf_internal_r+0x318>
 10869d4:	b00f883a 	mov	r7,r22
 10869d8:	01800c04 	movi	r6,48
 10869dc:	e00b883a 	mov	r5,fp
 10869e0:	9809883a 	mov	r4,r19
 10869e4:	108666c0 	call	108666c <print_repeat>
 10869e8:	1000451e 	bne	r2,zero,1086b00 <___svfprintf_internal_r+0x428>
 10869ec:	85a1883a 	add	r16,r16,r22
 10869f0:	d8c00a17 	ldw	r3,40(sp)
 10869f4:	a013883a 	mov	r9,r20
 10869f8:	1d2dc83a 	sub	r22,r3,r20
 10869fc:	00002206 	br	1086a88 <___svfprintf_internal_r+0x3b0>
 1086a00:	0580090e 	bge	zero,r22,1086a28 <___svfprintf_internal_r+0x350>
 1086a04:	b00f883a 	mov	r7,r22
 1086a08:	01800804 	movi	r6,32
 1086a0c:	e00b883a 	mov	r5,fp
 1086a10:	9809883a 	mov	r4,r19
 1086a14:	da801015 	stw	r10,64(sp)
 1086a18:	108666c0 	call	108666c <print_repeat>
 1086a1c:	da801017 	ldw	r10,64(sp)
 1086a20:	1000371e 	bne	r2,zero,1086b00 <___svfprintf_internal_r+0x428>
 1086a24:	85a1883a 	add	r16,r16,r22
 1086a28:	503ff126 	beq	r10,zero,10869f0 <__alt_data_end+0xfffb12c0>
 1086a2c:	00800b44 	movi	r2,45
 1086a30:	d8800805 	stb	r2,32(sp)
 1086a34:	e0800117 	ldw	r2,4(fp)
 1086a38:	01c00044 	movi	r7,1
 1086a3c:	d9800804 	addi	r6,sp,32
 1086a40:	e00b883a 	mov	r5,fp
 1086a44:	9809883a 	mov	r4,r19
 1086a48:	103ee83a 	callr	r2
 1086a4c:	10002c1e 	bne	r2,zero,1086b00 <___svfprintf_internal_r+0x428>
 1086a50:	84000044 	addi	r16,r16,1
 1086a54:	003fe606 	br	10869f0 <__alt_data_end+0xfffb12c0>
 1086a58:	4a7fffc4 	addi	r9,r9,-1
 1086a5c:	48800003 	ldbu	r2,0(r9)
 1086a60:	01c00044 	movi	r7,1
 1086a64:	d9800804 	addi	r6,sp,32
 1086a68:	d8800805 	stb	r2,32(sp)
 1086a6c:	e0800117 	ldw	r2,4(fp)
 1086a70:	e00b883a 	mov	r5,fp
 1086a74:	da401015 	stw	r9,64(sp)
 1086a78:	9809883a 	mov	r4,r19
 1086a7c:	103ee83a 	callr	r2
 1086a80:	da401017 	ldw	r9,64(sp)
 1086a84:	10001e1e 	bne	r2,zero,1086b00 <___svfprintf_internal_r+0x428>
 1086a88:	8245c83a 	sub	r2,r16,r9
 1086a8c:	4d89883a 	add	r4,r9,r22
 1086a90:	a085883a 	add	r2,r20,r2
 1086a94:	013ff016 	blt	zero,r4,1086a58 <__alt_data_end+0xfffb1328>
 1086a98:	1021883a 	mov	r16,r2
 1086a9c:	dd800d17 	ldw	r22,52(sp)
 1086aa0:	00004406 	br	1086bb4 <___svfprintf_internal_r+0x4dc>
 1086aa4:	00800044 	movi	r2,1
 1086aa8:	1440080e 	bge	r2,r17,1086acc <___svfprintf_internal_r+0x3f4>
 1086aac:	8d3fffc4 	addi	r20,r17,-1
 1086ab0:	a00f883a 	mov	r7,r20
 1086ab4:	01800804 	movi	r6,32
 1086ab8:	e00b883a 	mov	r5,fp
 1086abc:	9809883a 	mov	r4,r19
 1086ac0:	108666c0 	call	108666c <print_repeat>
 1086ac4:	10000e1e 	bne	r2,zero,1086b00 <___svfprintf_internal_r+0x428>
 1086ac8:	8521883a 	add	r16,r16,r20
 1086acc:	b0800017 	ldw	r2,0(r22)
 1086ad0:	01c00044 	movi	r7,1
 1086ad4:	d80d883a 	mov	r6,sp
 1086ad8:	d8800005 	stb	r2,0(sp)
 1086adc:	e0800117 	ldw	r2,4(fp)
 1086ae0:	e00b883a 	mov	r5,fp
 1086ae4:	9809883a 	mov	r4,r19
 1086ae8:	b5000104 	addi	r20,r22,4
 1086aec:	103ee83a 	callr	r2
 1086af0:	1000031e 	bne	r2,zero,1086b00 <___svfprintf_internal_r+0x428>
 1086af4:	84000044 	addi	r16,r16,1
 1086af8:	a02d883a 	mov	r22,r20
 1086afc:	00002d06 	br	1086bb4 <___svfprintf_internal_r+0x4dc>
 1086b00:	00bfffc4 	movi	r2,-1
 1086b04:	00003106 	br	1086bcc <___svfprintf_internal_r+0x4f4>
 1086b08:	b5000017 	ldw	r20,0(r22)
 1086b0c:	b0c00104 	addi	r3,r22,4
 1086b10:	d8c00a15 	stw	r3,40(sp)
 1086b14:	a009883a 	mov	r4,r20
 1086b18:	10864180 	call	1086418 <strlen>
 1086b1c:	8893c83a 	sub	r9,r17,r2
 1086b20:	102d883a 	mov	r22,r2
 1086b24:	0240090e 	bge	zero,r9,1086b4c <___svfprintf_internal_r+0x474>
 1086b28:	480f883a 	mov	r7,r9
 1086b2c:	01800804 	movi	r6,32
 1086b30:	e00b883a 	mov	r5,fp
 1086b34:	9809883a 	mov	r4,r19
 1086b38:	da401015 	stw	r9,64(sp)
 1086b3c:	108666c0 	call	108666c <print_repeat>
 1086b40:	da401017 	ldw	r9,64(sp)
 1086b44:	103fee1e 	bne	r2,zero,1086b00 <__alt_data_end+0xfffb13d0>
 1086b48:	8261883a 	add	r16,r16,r9
 1086b4c:	e0800117 	ldw	r2,4(fp)
 1086b50:	b00f883a 	mov	r7,r22
 1086b54:	a00d883a 	mov	r6,r20
 1086b58:	e00b883a 	mov	r5,fp
 1086b5c:	9809883a 	mov	r4,r19
 1086b60:	103ee83a 	callr	r2
 1086b64:	103fe61e 	bne	r2,zero,1086b00 <__alt_data_end+0xfffb13d0>
 1086b68:	85a1883a 	add	r16,r16,r22
 1086b6c:	dd800a17 	ldw	r22,40(sp)
 1086b70:	00001006 	br	1086bb4 <___svfprintf_internal_r+0x4dc>
 1086b74:	05c00044 	movi	r23,1
 1086b78:	04bfffc4 	movi	r18,-1
 1086b7c:	d8000e15 	stw	zero,56(sp)
 1086b80:	05400284 	movi	r21,10
 1086b84:	9023883a 	mov	r17,r18
 1086b88:	d8000c15 	stw	zero,48(sp)
 1086b8c:	d8000b15 	stw	zero,44(sp)
 1086b90:	b829883a 	mov	r20,r23
 1086b94:	00000806 	br	1086bb8 <___svfprintf_internal_r+0x4e0>
 1086b98:	dd000b15 	stw	r20,44(sp)
 1086b9c:	05000084 	movi	r20,2
 1086ba0:	00000506 	br	1086bb8 <___svfprintf_internal_r+0x4e0>
 1086ba4:	00c00044 	movi	r3,1
 1086ba8:	d8c00c15 	stw	r3,48(sp)
 1086bac:	050000c4 	movi	r20,3
 1086bb0:	00000106 	br	1086bb8 <___svfprintf_internal_r+0x4e0>
 1086bb4:	0029883a 	mov	r20,zero
 1086bb8:	d8c00f17 	ldw	r3,60(sp)
 1086bbc:	18c00044 	addi	r3,r3,1
 1086bc0:	d8c00f15 	stw	r3,60(sp)
 1086bc4:	003ede06 	br	1086740 <__alt_data_end+0xfffb1010>
 1086bc8:	8005883a 	mov	r2,r16
 1086bcc:	dfc01a17 	ldw	ra,104(sp)
 1086bd0:	df001917 	ldw	fp,100(sp)
 1086bd4:	ddc01817 	ldw	r23,96(sp)
 1086bd8:	dd801717 	ldw	r22,92(sp)
 1086bdc:	dd401617 	ldw	r21,88(sp)
 1086be0:	dd001517 	ldw	r20,84(sp)
 1086be4:	dcc01417 	ldw	r19,80(sp)
 1086be8:	dc801317 	ldw	r18,76(sp)
 1086bec:	dc401217 	ldw	r17,72(sp)
 1086bf0:	dc001117 	ldw	r16,68(sp)
 1086bf4:	dec01b04 	addi	sp,sp,108
 1086bf8:	f800283a 	ret

01086bfc <__vfprintf_internal_unused>:
 1086bfc:	00804274 	movhi	r2,265
 1086c00:	10a7e804 	addi	r2,r2,-24672
 1086c04:	300f883a 	mov	r7,r6
 1086c08:	280d883a 	mov	r6,r5
 1086c0c:	200b883a 	mov	r5,r4
 1086c10:	11000017 	ldw	r4,0(r2)
 1086c14:	10866d81 	jmpi	10866d8 <___svfprintf_internal_r>

01086c18 <_write_r>:
 1086c18:	defffd04 	addi	sp,sp,-12
 1086c1c:	dc000015 	stw	r16,0(sp)
 1086c20:	04004274 	movhi	r16,265
 1086c24:	dc400115 	stw	r17,4(sp)
 1086c28:	842ccc04 	addi	r16,r16,-19664
 1086c2c:	2023883a 	mov	r17,r4
 1086c30:	2809883a 	mov	r4,r5
 1086c34:	300b883a 	mov	r5,r6
 1086c38:	380d883a 	mov	r6,r7
 1086c3c:	dfc00215 	stw	ra,8(sp)
 1086c40:	80000015 	stw	zero,0(r16)
 1086c44:	10870100 	call	1087010 <write>
 1086c48:	00ffffc4 	movi	r3,-1
 1086c4c:	10c0031e 	bne	r2,r3,1086c5c <_write_r+0x44>
 1086c50:	80c00017 	ldw	r3,0(r16)
 1086c54:	18000126 	beq	r3,zero,1086c5c <_write_r+0x44>
 1086c58:	88c00015 	stw	r3,0(r17)
 1086c5c:	dfc00217 	ldw	ra,8(sp)
 1086c60:	dc400117 	ldw	r17,4(sp)
 1086c64:	dc000017 	ldw	r16,0(sp)
 1086c68:	dec00304 	addi	sp,sp,12
 1086c6c:	f800283a 	ret

01086c70 <__divsi3>:
 1086c70:	20001b16 	blt	r4,zero,1086ce0 <__divsi3+0x70>
 1086c74:	000f883a 	mov	r7,zero
 1086c78:	28001616 	blt	r5,zero,1086cd4 <__divsi3+0x64>
 1086c7c:	200d883a 	mov	r6,r4
 1086c80:	29001a2e 	bgeu	r5,r4,1086cec <__divsi3+0x7c>
 1086c84:	00800804 	movi	r2,32
 1086c88:	00c00044 	movi	r3,1
 1086c8c:	00000106 	br	1086c94 <__divsi3+0x24>
 1086c90:	10000d26 	beq	r2,zero,1086cc8 <__divsi3+0x58>
 1086c94:	294b883a 	add	r5,r5,r5
 1086c98:	10bfffc4 	addi	r2,r2,-1
 1086c9c:	18c7883a 	add	r3,r3,r3
 1086ca0:	293ffb36 	bltu	r5,r4,1086c90 <__alt_data_end+0xfffb1560>
 1086ca4:	0005883a 	mov	r2,zero
 1086ca8:	18000726 	beq	r3,zero,1086cc8 <__divsi3+0x58>
 1086cac:	0005883a 	mov	r2,zero
 1086cb0:	31400236 	bltu	r6,r5,1086cbc <__divsi3+0x4c>
 1086cb4:	314dc83a 	sub	r6,r6,r5
 1086cb8:	10c4b03a 	or	r2,r2,r3
 1086cbc:	1806d07a 	srli	r3,r3,1
 1086cc0:	280ad07a 	srli	r5,r5,1
 1086cc4:	183ffa1e 	bne	r3,zero,1086cb0 <__alt_data_end+0xfffb1580>
 1086cc8:	38000126 	beq	r7,zero,1086cd0 <__divsi3+0x60>
 1086ccc:	0085c83a 	sub	r2,zero,r2
 1086cd0:	f800283a 	ret
 1086cd4:	014bc83a 	sub	r5,zero,r5
 1086cd8:	39c0005c 	xori	r7,r7,1
 1086cdc:	003fe706 	br	1086c7c <__alt_data_end+0xfffb154c>
 1086ce0:	0109c83a 	sub	r4,zero,r4
 1086ce4:	01c00044 	movi	r7,1
 1086ce8:	003fe306 	br	1086c78 <__alt_data_end+0xfffb1548>
 1086cec:	00c00044 	movi	r3,1
 1086cf0:	003fee06 	br	1086cac <__alt_data_end+0xfffb157c>

01086cf4 <__modsi3>:
 1086cf4:	20001716 	blt	r4,zero,1086d54 <__modsi3+0x60>
 1086cf8:	000f883a 	mov	r7,zero
 1086cfc:	2005883a 	mov	r2,r4
 1086d00:	28001216 	blt	r5,zero,1086d4c <__modsi3+0x58>
 1086d04:	2900162e 	bgeu	r5,r4,1086d60 <__modsi3+0x6c>
 1086d08:	01800804 	movi	r6,32
 1086d0c:	00c00044 	movi	r3,1
 1086d10:	00000106 	br	1086d18 <__modsi3+0x24>
 1086d14:	30000a26 	beq	r6,zero,1086d40 <__modsi3+0x4c>
 1086d18:	294b883a 	add	r5,r5,r5
 1086d1c:	31bfffc4 	addi	r6,r6,-1
 1086d20:	18c7883a 	add	r3,r3,r3
 1086d24:	293ffb36 	bltu	r5,r4,1086d14 <__alt_data_end+0xfffb15e4>
 1086d28:	18000526 	beq	r3,zero,1086d40 <__modsi3+0x4c>
 1086d2c:	1806d07a 	srli	r3,r3,1
 1086d30:	11400136 	bltu	r2,r5,1086d38 <__modsi3+0x44>
 1086d34:	1145c83a 	sub	r2,r2,r5
 1086d38:	280ad07a 	srli	r5,r5,1
 1086d3c:	183ffb1e 	bne	r3,zero,1086d2c <__alt_data_end+0xfffb15fc>
 1086d40:	38000126 	beq	r7,zero,1086d48 <__modsi3+0x54>
 1086d44:	0085c83a 	sub	r2,zero,r2
 1086d48:	f800283a 	ret
 1086d4c:	014bc83a 	sub	r5,zero,r5
 1086d50:	003fec06 	br	1086d04 <__alt_data_end+0xfffb15d4>
 1086d54:	0109c83a 	sub	r4,zero,r4
 1086d58:	01c00044 	movi	r7,1
 1086d5c:	003fe706 	br	1086cfc <__alt_data_end+0xfffb15cc>
 1086d60:	00c00044 	movi	r3,1
 1086d64:	003ff106 	br	1086d2c <__alt_data_end+0xfffb15fc>

01086d68 <__udivsi3>:
 1086d68:	200d883a 	mov	r6,r4
 1086d6c:	2900152e 	bgeu	r5,r4,1086dc4 <__udivsi3+0x5c>
 1086d70:	28001416 	blt	r5,zero,1086dc4 <__udivsi3+0x5c>
 1086d74:	00800804 	movi	r2,32
 1086d78:	00c00044 	movi	r3,1
 1086d7c:	00000206 	br	1086d88 <__udivsi3+0x20>
 1086d80:	10000e26 	beq	r2,zero,1086dbc <__udivsi3+0x54>
 1086d84:	28000516 	blt	r5,zero,1086d9c <__udivsi3+0x34>
 1086d88:	294b883a 	add	r5,r5,r5
 1086d8c:	10bfffc4 	addi	r2,r2,-1
 1086d90:	18c7883a 	add	r3,r3,r3
 1086d94:	293ffa36 	bltu	r5,r4,1086d80 <__alt_data_end+0xfffb1650>
 1086d98:	18000826 	beq	r3,zero,1086dbc <__udivsi3+0x54>
 1086d9c:	0005883a 	mov	r2,zero
 1086da0:	31400236 	bltu	r6,r5,1086dac <__udivsi3+0x44>
 1086da4:	314dc83a 	sub	r6,r6,r5
 1086da8:	10c4b03a 	or	r2,r2,r3
 1086dac:	1806d07a 	srli	r3,r3,1
 1086db0:	280ad07a 	srli	r5,r5,1
 1086db4:	183ffa1e 	bne	r3,zero,1086da0 <__alt_data_end+0xfffb1670>
 1086db8:	f800283a 	ret
 1086dbc:	0005883a 	mov	r2,zero
 1086dc0:	f800283a 	ret
 1086dc4:	00c00044 	movi	r3,1
 1086dc8:	003ff406 	br	1086d9c <__alt_data_end+0xfffb166c>

01086dcc <__umodsi3>:
 1086dcc:	2005883a 	mov	r2,r4
 1086dd0:	2900122e 	bgeu	r5,r4,1086e1c <__umodsi3+0x50>
 1086dd4:	28001116 	blt	r5,zero,1086e1c <__umodsi3+0x50>
 1086dd8:	01800804 	movi	r6,32
 1086ddc:	00c00044 	movi	r3,1
 1086de0:	00000206 	br	1086dec <__umodsi3+0x20>
 1086de4:	30000c26 	beq	r6,zero,1086e18 <__umodsi3+0x4c>
 1086de8:	28000516 	blt	r5,zero,1086e00 <__umodsi3+0x34>
 1086dec:	294b883a 	add	r5,r5,r5
 1086df0:	31bfffc4 	addi	r6,r6,-1
 1086df4:	18c7883a 	add	r3,r3,r3
 1086df8:	293ffa36 	bltu	r5,r4,1086de4 <__alt_data_end+0xfffb16b4>
 1086dfc:	18000626 	beq	r3,zero,1086e18 <__umodsi3+0x4c>
 1086e00:	1806d07a 	srli	r3,r3,1
 1086e04:	11400136 	bltu	r2,r5,1086e0c <__umodsi3+0x40>
 1086e08:	1145c83a 	sub	r2,r2,r5
 1086e0c:	280ad07a 	srli	r5,r5,1
 1086e10:	183ffb1e 	bne	r3,zero,1086e00 <__alt_data_end+0xfffb16d0>
 1086e14:	f800283a 	ret
 1086e18:	f800283a 	ret
 1086e1c:	00c00044 	movi	r3,1
 1086e20:	003ff706 	br	1086e00 <__alt_data_end+0xfffb16d0>

01086e24 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 1086e24:	defffc04 	addi	sp,sp,-16
 1086e28:	df000315 	stw	fp,12(sp)
 1086e2c:	df000304 	addi	fp,sp,12
 1086e30:	e13ffd15 	stw	r4,-12(fp)
 1086e34:	e17ffe15 	stw	r5,-8(fp)
 1086e38:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 1086e3c:	e0fffe17 	ldw	r3,-8(fp)
 1086e40:	e0bffd17 	ldw	r2,-12(fp)
 1086e44:	18800c26 	beq	r3,r2,1086e78 <alt_load_section+0x54>
  {
    while( to != end )
 1086e48:	00000806 	br	1086e6c <alt_load_section+0x48>
    {
      *to++ = *from++;
 1086e4c:	e0bffe17 	ldw	r2,-8(fp)
 1086e50:	10c00104 	addi	r3,r2,4
 1086e54:	e0fffe15 	stw	r3,-8(fp)
 1086e58:	e0fffd17 	ldw	r3,-12(fp)
 1086e5c:	19000104 	addi	r4,r3,4
 1086e60:	e13ffd15 	stw	r4,-12(fp)
 1086e64:	18c00017 	ldw	r3,0(r3)
 1086e68:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 1086e6c:	e0fffe17 	ldw	r3,-8(fp)
 1086e70:	e0bfff17 	ldw	r2,-4(fp)
 1086e74:	18bff51e 	bne	r3,r2,1086e4c <__alt_data_end+0xfffb171c>
    {
      *to++ = *from++;
    }
  }
}
 1086e78:	0001883a 	nop
 1086e7c:	e037883a 	mov	sp,fp
 1086e80:	df000017 	ldw	fp,0(sp)
 1086e84:	dec00104 	addi	sp,sp,4
 1086e88:	f800283a 	ret

01086e8c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 1086e8c:	defffe04 	addi	sp,sp,-8
 1086e90:	dfc00115 	stw	ra,4(sp)
 1086e94:	df000015 	stw	fp,0(sp)
 1086e98:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 1086e9c:	01804274 	movhi	r6,265
 1086ea0:	31a7f204 	addi	r6,r6,-24632
 1086ea4:	01404274 	movhi	r5,265
 1086ea8:	29632d04 	addi	r5,r5,-29516
 1086eac:	01004274 	movhi	r4,265
 1086eb0:	2127f204 	addi	r4,r4,-24632
 1086eb4:	1086e240 	call	1086e24 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 1086eb8:	01802034 	movhi	r6,128
 1086ebc:	31809504 	addi	r6,r6,596
 1086ec0:	01402034 	movhi	r5,128
 1086ec4:	29400804 	addi	r5,r5,32
 1086ec8:	01002034 	movhi	r4,128
 1086ecc:	21000804 	addi	r4,r4,32
 1086ed0:	1086e240 	call	1086e24 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 1086ed4:	01804274 	movhi	r6,265
 1086ed8:	31a32d04 	addi	r6,r6,-29516
 1086edc:	01404274 	movhi	r5,265
 1086ee0:	2962d904 	addi	r5,r5,-29852
 1086ee4:	01004274 	movhi	r4,265
 1086ee8:	2122d904 	addi	r4,r4,-29852
 1086eec:	1086e240 	call	1086e24 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 1086ef0:	1087e940 	call	1087e94 <alt_dcache_flush_all>
  alt_icache_flush_all();
 1086ef4:	1087ffc0 	call	1087ffc <alt_icache_flush_all>
}
 1086ef8:	0001883a 	nop
 1086efc:	e037883a 	mov	sp,fp
 1086f00:	dfc00117 	ldw	ra,4(sp)
 1086f04:	df000017 	ldw	fp,0(sp)
 1086f08:	dec00204 	addi	sp,sp,8
 1086f0c:	f800283a 	ret

01086f10 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 1086f10:	defffd04 	addi	sp,sp,-12
 1086f14:	dfc00215 	stw	ra,8(sp)
 1086f18:	df000115 	stw	fp,4(sp)
 1086f1c:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 1086f20:	0009883a 	mov	r4,zero
 1086f24:	10871400 	call	1087140 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 1086f28:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 1086f2c:	10871780 	call	1087178 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 1086f30:	01804274 	movhi	r6,265
 1086f34:	31a32004 	addi	r6,r6,-29568
 1086f38:	01404274 	movhi	r5,265
 1086f3c:	29632004 	addi	r5,r5,-29568
 1086f40:	01004274 	movhi	r4,265
 1086f44:	21232004 	addi	r4,r4,-29568
 1086f48:	10880f40 	call	10880f4 <alt_io_redirect>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 1086f4c:	d0a4e717 	ldw	r2,-27748(gp)
 1086f50:	d0e4e817 	ldw	r3,-27744(gp)
 1086f54:	d124e917 	ldw	r4,-27740(gp)
 1086f58:	200d883a 	mov	r6,r4
 1086f5c:	180b883a 	mov	r5,r3
 1086f60:	1009883a 	mov	r4,r2
 1086f64:	108621c0 	call	108621c <main>
 1086f68:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 1086f6c:	01000044 	movi	r4,1
 1086f70:	1087dc40 	call	1087dc4 <close>
  exit (result);
 1086f74:	e13fff17 	ldw	r4,-4(fp)
 1086f78:	10888f80 	call	10888f8 <exit>

01086f7c <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
 1086f7c:	defffd04 	addi	sp,sp,-12
 1086f80:	dfc00215 	stw	ra,8(sp)
 1086f84:	df000115 	stw	fp,4(sp)
 1086f88:	df000104 	addi	fp,sp,4
 1086f8c:	e13fff15 	stw	r4,-4(fp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
#else
    return fputs(str, stdout);
 1086f90:	00804274 	movhi	r2,265
 1086f94:	10a7e804 	addi	r2,r2,-24672
 1086f98:	10800017 	ldw	r2,0(r2)
 1086f9c:	10800217 	ldw	r2,8(r2)
 1086fa0:	100b883a 	mov	r5,r2
 1086fa4:	e13fff17 	ldw	r4,-4(fp)
 1086fa8:	10889180 	call	1088918 <fputs>
#endif
#endif
}
 1086fac:	e037883a 	mov	sp,fp
 1086fb0:	dfc00117 	ldw	ra,4(sp)
 1086fb4:	df000017 	ldw	fp,0(sp)
 1086fb8:	dec00204 	addi	sp,sp,8
 1086fbc:	f800283a 	ret

01086fc0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1086fc0:	defffe04 	addi	sp,sp,-8
 1086fc4:	dfc00115 	stw	ra,4(sp)
 1086fc8:	df000015 	stw	fp,0(sp)
 1086fcc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1086fd0:	00804274 	movhi	r2,265
 1086fd4:	10a7ef04 	addi	r2,r2,-24644
 1086fd8:	10800017 	ldw	r2,0(r2)
 1086fdc:	10000526 	beq	r2,zero,1086ff4 <alt_get_errno+0x34>
 1086fe0:	00804274 	movhi	r2,265
 1086fe4:	10a7ef04 	addi	r2,r2,-24644
 1086fe8:	10800017 	ldw	r2,0(r2)
 1086fec:	103ee83a 	callr	r2
 1086ff0:	00000206 	br	1086ffc <alt_get_errno+0x3c>
 1086ff4:	00804274 	movhi	r2,265
 1086ff8:	10accc04 	addi	r2,r2,-19664
}
 1086ffc:	e037883a 	mov	sp,fp
 1087000:	dfc00117 	ldw	ra,4(sp)
 1087004:	df000017 	ldw	fp,0(sp)
 1087008:	dec00204 	addi	sp,sp,8
 108700c:	f800283a 	ret

01087010 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 1087010:	defff904 	addi	sp,sp,-28
 1087014:	dfc00615 	stw	ra,24(sp)
 1087018:	df000515 	stw	fp,20(sp)
 108701c:	df000504 	addi	fp,sp,20
 1087020:	e13ffd15 	stw	r4,-12(fp)
 1087024:	e17ffe15 	stw	r5,-8(fp)
 1087028:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 108702c:	e0bffd17 	ldw	r2,-12(fp)
 1087030:	10000616 	blt	r2,zero,108704c <write+0x3c>
 1087034:	e0bffd17 	ldw	r2,-12(fp)
 1087038:	10c00324 	muli	r3,r2,12
 108703c:	00804274 	movhi	r2,265
 1087040:	10a78704 	addi	r2,r2,-25060
 1087044:	1885883a 	add	r2,r3,r2
 1087048:	00000106 	br	1087050 <write+0x40>
 108704c:	0005883a 	mov	r2,zero
 1087050:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 1087054:	e0bffb17 	ldw	r2,-20(fp)
 1087058:	10002126 	beq	r2,zero,10870e0 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 108705c:	e0bffb17 	ldw	r2,-20(fp)
 1087060:	10800217 	ldw	r2,8(r2)
 1087064:	108000cc 	andi	r2,r2,3
 1087068:	10001826 	beq	r2,zero,10870cc <write+0xbc>
 108706c:	e0bffb17 	ldw	r2,-20(fp)
 1087070:	10800017 	ldw	r2,0(r2)
 1087074:	10800617 	ldw	r2,24(r2)
 1087078:	10001426 	beq	r2,zero,10870cc <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 108707c:	e0bffb17 	ldw	r2,-20(fp)
 1087080:	10800017 	ldw	r2,0(r2)
 1087084:	10800617 	ldw	r2,24(r2)
 1087088:	e0ffff17 	ldw	r3,-4(fp)
 108708c:	180d883a 	mov	r6,r3
 1087090:	e17ffe17 	ldw	r5,-8(fp)
 1087094:	e13ffb17 	ldw	r4,-20(fp)
 1087098:	103ee83a 	callr	r2
 108709c:	e0bffc15 	stw	r2,-16(fp)
 10870a0:	e0bffc17 	ldw	r2,-16(fp)
 10870a4:	1000070e 	bge	r2,zero,10870c4 <write+0xb4>
      {
        ALT_ERRNO = -rval;
 10870a8:	1086fc00 	call	1086fc0 <alt_get_errno>
 10870ac:	1007883a 	mov	r3,r2
 10870b0:	e0bffc17 	ldw	r2,-16(fp)
 10870b4:	0085c83a 	sub	r2,zero,r2
 10870b8:	18800015 	stw	r2,0(r3)
        return -1;
 10870bc:	00bfffc4 	movi	r2,-1
 10870c0:	00000c06 	br	10870f4 <write+0xe4>
      }
      return rval;
 10870c4:	e0bffc17 	ldw	r2,-16(fp)
 10870c8:	00000a06 	br	10870f4 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 10870cc:	1086fc00 	call	1086fc0 <alt_get_errno>
 10870d0:	1007883a 	mov	r3,r2
 10870d4:	00800344 	movi	r2,13
 10870d8:	18800015 	stw	r2,0(r3)
 10870dc:	00000406 	br	10870f0 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 10870e0:	1086fc00 	call	1086fc0 <alt_get_errno>
 10870e4:	1007883a 	mov	r3,r2
 10870e8:	00801444 	movi	r2,81
 10870ec:	18800015 	stw	r2,0(r3)
  }
  return -1;
 10870f0:	00bfffc4 	movi	r2,-1
}
 10870f4:	e037883a 	mov	sp,fp
 10870f8:	dfc00117 	ldw	ra,4(sp)
 10870fc:	df000017 	ldw	fp,0(sp)
 1087100:	dec00204 	addi	sp,sp,8
 1087104:	f800283a 	ret

01087108 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 1087108:	defffd04 	addi	sp,sp,-12
 108710c:	dfc00215 	stw	ra,8(sp)
 1087110:	df000115 	stw	fp,4(sp)
 1087114:	df000104 	addi	fp,sp,4
 1087118:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 108711c:	01404274 	movhi	r5,265
 1087120:	2967ec04 	addi	r5,r5,-24656
 1087124:	e13fff17 	ldw	r4,-4(fp)
 1087128:	1087f580 	call	1087f58 <alt_dev_llist_insert>
}
 108712c:	e037883a 	mov	sp,fp
 1087130:	dfc00117 	ldw	ra,4(sp)
 1087134:	df000017 	ldw	fp,0(sp)
 1087138:	dec00204 	addi	sp,sp,8
 108713c:	f800283a 	ret

01087140 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 1087140:	defffd04 	addi	sp,sp,-12
 1087144:	dfc00215 	stw	ra,8(sp)
 1087148:	df000115 	stw	fp,4(sp)
 108714c:	df000104 	addi	fp,sp,4
 1087150:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
 1087154:	10885ec0 	call	10885ec <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 1087158:	00800044 	movi	r2,1
 108715c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 1087160:	0001883a 	nop
 1087164:	e037883a 	mov	sp,fp
 1087168:	dfc00117 	ldw	ra,4(sp)
 108716c:	df000017 	ldw	fp,0(sp)
 1087170:	dec00204 	addi	sp,sp,8
 1087174:	f800283a 	ret

01087178 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 1087178:	defffe04 	addi	sp,sp,-8
 108717c:	dfc00115 	stw	ra,4(sp)
 1087180:	df000015 	stw	fp,0(sp)
 1087184:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 1087188:	000d883a 	mov	r6,zero
 108718c:	000b883a 	mov	r5,zero
 1087190:	01004274 	movhi	r4,265
 1087194:	21236f04 	addi	r4,r4,-29252
 1087198:	10873280 	call	1087328 <altera_avalon_jtag_uart_init>
 108719c:	01004274 	movhi	r4,265
 10871a0:	21236504 	addi	r4,r4,-29292
 10871a4:	10871080 	call	1087108 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
 10871a8:	0001883a 	nop
}
 10871ac:	0001883a 	nop
 10871b0:	e037883a 	mov	sp,fp
 10871b4:	dfc00117 	ldw	ra,4(sp)
 10871b8:	df000017 	ldw	fp,0(sp)
 10871bc:	dec00204 	addi	sp,sp,8
 10871c0:	f800283a 	ret

010871c4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 10871c4:	defffa04 	addi	sp,sp,-24
 10871c8:	dfc00515 	stw	ra,20(sp)
 10871cc:	df000415 	stw	fp,16(sp)
 10871d0:	df000404 	addi	fp,sp,16
 10871d4:	e13ffd15 	stw	r4,-12(fp)
 10871d8:	e17ffe15 	stw	r5,-8(fp)
 10871dc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 10871e0:	e0bffd17 	ldw	r2,-12(fp)
 10871e4:	10800017 	ldw	r2,0(r2)
 10871e8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 10871ec:	e0bffc17 	ldw	r2,-16(fp)
 10871f0:	10c00a04 	addi	r3,r2,40
 10871f4:	e0bffd17 	ldw	r2,-12(fp)
 10871f8:	10800217 	ldw	r2,8(r2)
 10871fc:	100f883a 	mov	r7,r2
 1087200:	e1bfff17 	ldw	r6,-4(fp)
 1087204:	e17ffe17 	ldw	r5,-8(fp)
 1087208:	1809883a 	mov	r4,r3
 108720c:	10877f40 	call	10877f4 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 1087210:	e037883a 	mov	sp,fp
 1087214:	dfc00117 	ldw	ra,4(sp)
 1087218:	df000017 	ldw	fp,0(sp)
 108721c:	dec00204 	addi	sp,sp,8
 1087220:	f800283a 	ret

01087224 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 1087224:	defffa04 	addi	sp,sp,-24
 1087228:	dfc00515 	stw	ra,20(sp)
 108722c:	df000415 	stw	fp,16(sp)
 1087230:	df000404 	addi	fp,sp,16
 1087234:	e13ffd15 	stw	r4,-12(fp)
 1087238:	e17ffe15 	stw	r5,-8(fp)
 108723c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1087240:	e0bffd17 	ldw	r2,-12(fp)
 1087244:	10800017 	ldw	r2,0(r2)
 1087248:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 108724c:	e0bffc17 	ldw	r2,-16(fp)
 1087250:	10c00a04 	addi	r3,r2,40
 1087254:	e0bffd17 	ldw	r2,-12(fp)
 1087258:	10800217 	ldw	r2,8(r2)
 108725c:	100f883a 	mov	r7,r2
 1087260:	e1bfff17 	ldw	r6,-4(fp)
 1087264:	e17ffe17 	ldw	r5,-8(fp)
 1087268:	1809883a 	mov	r4,r3
 108726c:	1087a100 	call	1087a10 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 1087270:	e037883a 	mov	sp,fp
 1087274:	dfc00117 	ldw	ra,4(sp)
 1087278:	df000017 	ldw	fp,0(sp)
 108727c:	dec00204 	addi	sp,sp,8
 1087280:	f800283a 	ret

01087284 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 1087284:	defffc04 	addi	sp,sp,-16
 1087288:	dfc00315 	stw	ra,12(sp)
 108728c:	df000215 	stw	fp,8(sp)
 1087290:	df000204 	addi	fp,sp,8
 1087294:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1087298:	e0bfff17 	ldw	r2,-4(fp)
 108729c:	10800017 	ldw	r2,0(r2)
 10872a0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 10872a4:	e0bffe17 	ldw	r2,-8(fp)
 10872a8:	10c00a04 	addi	r3,r2,40
 10872ac:	e0bfff17 	ldw	r2,-4(fp)
 10872b0:	10800217 	ldw	r2,8(r2)
 10872b4:	100b883a 	mov	r5,r2
 10872b8:	1809883a 	mov	r4,r3
 10872bc:	108769c0 	call	108769c <altera_avalon_jtag_uart_close>
}
 10872c0:	e037883a 	mov	sp,fp
 10872c4:	dfc00117 	ldw	ra,4(sp)
 10872c8:	df000017 	ldw	fp,0(sp)
 10872cc:	dec00204 	addi	sp,sp,8
 10872d0:	f800283a 	ret

010872d4 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 10872d4:	defffa04 	addi	sp,sp,-24
 10872d8:	dfc00515 	stw	ra,20(sp)
 10872dc:	df000415 	stw	fp,16(sp)
 10872e0:	df000404 	addi	fp,sp,16
 10872e4:	e13ffd15 	stw	r4,-12(fp)
 10872e8:	e17ffe15 	stw	r5,-8(fp)
 10872ec:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 10872f0:	e0bffd17 	ldw	r2,-12(fp)
 10872f4:	10800017 	ldw	r2,0(r2)
 10872f8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 10872fc:	e0bffc17 	ldw	r2,-16(fp)
 1087300:	10800a04 	addi	r2,r2,40
 1087304:	e1bfff17 	ldw	r6,-4(fp)
 1087308:	e17ffe17 	ldw	r5,-8(fp)
 108730c:	1009883a 	mov	r4,r2
 1087310:	10877040 	call	1087704 <altera_avalon_jtag_uart_ioctl>
}
 1087314:	e037883a 	mov	sp,fp
 1087318:	dfc00117 	ldw	ra,4(sp)
 108731c:	df000017 	ldw	fp,0(sp)
 1087320:	dec00204 	addi	sp,sp,8
 1087324:	f800283a 	ret

01087328 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 1087328:	defffb04 	addi	sp,sp,-20
 108732c:	dfc00415 	stw	ra,16(sp)
 1087330:	df000315 	stw	fp,12(sp)
 1087334:	df000304 	addi	fp,sp,12
 1087338:	e13ffd15 	stw	r4,-12(fp)
 108733c:	e17ffe15 	stw	r5,-8(fp)
 1087340:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1087344:	e0bffd17 	ldw	r2,-12(fp)
 1087348:	00c00044 	movi	r3,1
 108734c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 1087350:	e0bffd17 	ldw	r2,-12(fp)
 1087354:	10800017 	ldw	r2,0(r2)
 1087358:	10800104 	addi	r2,r2,4
 108735c:	1007883a 	mov	r3,r2
 1087360:	e0bffd17 	ldw	r2,-12(fp)
 1087364:	10800817 	ldw	r2,32(r2)
 1087368:	18800035 	stwio	r2,0(r3)
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
                      sp, NULL);
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
 108736c:	e0bfff17 	ldw	r2,-4(fp)
 1087370:	01804234 	movhi	r6,264
 1087374:	319cf904 	addi	r6,r6,29668
 1087378:	e17ffd17 	ldw	r5,-12(fp)
 108737c:	1009883a 	mov	r4,r2
 1087380:	1080c280 	call	1080c28 <alt_irq_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 1087384:	e0bffd17 	ldw	r2,-12(fp)
 1087388:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 108738c:	e0bffd17 	ldw	r2,-12(fp)
 1087390:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 1087394:	00804274 	movhi	r2,265
 1087398:	10acd104 	addi	r2,r2,-19644
 108739c:	10800017 	ldw	r2,0(r2)
 10873a0:	e1fffd17 	ldw	r7,-12(fp)
 10873a4:	01804234 	movhi	r6,264
 10873a8:	319d7d04 	addi	r6,r6,30196
 10873ac:	100b883a 	mov	r5,r2
 10873b0:	1809883a 	mov	r4,r3
 10873b4:	1087c340 	call	1087c34 <alt_alarm_start>
 10873b8:	1000040e 	bge	r2,zero,10873cc <altera_avalon_jtag_uart_init+0xa4>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 10873bc:	e0fffd17 	ldw	r3,-12(fp)
 10873c0:	00a00034 	movhi	r2,32768
 10873c4:	10bfffc4 	addi	r2,r2,-1
 10873c8:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 10873cc:	0001883a 	nop
 10873d0:	e037883a 	mov	sp,fp
 10873d4:	dfc00117 	ldw	ra,4(sp)
 10873d8:	df000017 	ldw	fp,0(sp)
 10873dc:	dec00204 	addi	sp,sp,8
 10873e0:	f800283a 	ret

010873e4 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 10873e4:	defff704 	addi	sp,sp,-36
 10873e8:	df000815 	stw	fp,32(sp)
 10873ec:	df000804 	addi	fp,sp,32
 10873f0:	e13ffe15 	stw	r4,-8(fp)
 10873f4:	e17fff15 	stw	r5,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 10873f8:	e0bffe17 	ldw	r2,-8(fp)
 10873fc:	e0bffa15 	stw	r2,-24(fp)
  unsigned int base = sp->base;
 1087400:	e0bffa17 	ldw	r2,-24(fp)
 1087404:	10800017 	ldw	r2,0(r2)
 1087408:	e0bffb15 	stw	r2,-20(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 108740c:	e0bffb17 	ldw	r2,-20(fp)
 1087410:	10800104 	addi	r2,r2,4
 1087414:	10800037 	ldwio	r2,0(r2)
 1087418:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 108741c:	e0bffc17 	ldw	r2,-16(fp)
 1087420:	1080c00c 	andi	r2,r2,768
 1087424:	10006d26 	beq	r2,zero,10875dc <altera_avalon_jtag_uart_irq+0x1f8>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 1087428:	e0bffc17 	ldw	r2,-16(fp)
 108742c:	1080400c 	andi	r2,r2,256
 1087430:	10003526 	beq	r2,zero,1087508 <altera_avalon_jtag_uart_irq+0x124>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 1087434:	00800074 	movhi	r2,1
 1087438:	e0bff815 	stw	r2,-32(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 108743c:	e0bffa17 	ldw	r2,-24(fp)
 1087440:	10800a17 	ldw	r2,40(r2)
 1087444:	10800044 	addi	r2,r2,1
 1087448:	1081ffcc 	andi	r2,r2,2047
 108744c:	e0bffd15 	stw	r2,-12(fp)
        if (next == sp->rx_out)
 1087450:	e0bffa17 	ldw	r2,-24(fp)
 1087454:	10c00b17 	ldw	r3,44(r2)
 1087458:	e0bffd17 	ldw	r2,-12(fp)
 108745c:	18801526 	beq	r3,r2,10874b4 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 1087460:	e0bffb17 	ldw	r2,-20(fp)
 1087464:	10800037 	ldwio	r2,0(r2)
 1087468:	e0bff815 	stw	r2,-32(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 108746c:	e0bff817 	ldw	r2,-32(fp)
 1087470:	10a0000c 	andi	r2,r2,32768
 1087474:	10001126 	beq	r2,zero,10874bc <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 1087478:	e0bffa17 	ldw	r2,-24(fp)
 108747c:	10800a17 	ldw	r2,40(r2)
 1087480:	e0fff817 	ldw	r3,-32(fp)
 1087484:	1809883a 	mov	r4,r3
 1087488:	e0fffa17 	ldw	r3,-24(fp)
 108748c:	1885883a 	add	r2,r3,r2
 1087490:	10800e04 	addi	r2,r2,56
 1087494:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1087498:	e0bffa17 	ldw	r2,-24(fp)
 108749c:	10800a17 	ldw	r2,40(r2)
 10874a0:	10800044 	addi	r2,r2,1
 10874a4:	10c1ffcc 	andi	r3,r2,2047
 10874a8:	e0bffa17 	ldw	r2,-24(fp)
 10874ac:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 10874b0:	003fe206 	br	108743c <__alt_data_end+0xfffb1d0c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 10874b4:	0001883a 	nop
 10874b8:	00000106 	br	10874c0 <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 10874bc:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 10874c0:	e0bff817 	ldw	r2,-32(fp)
 10874c4:	10bfffec 	andhi	r2,r2,65535
 10874c8:	10000f26 	beq	r2,zero,1087508 <altera_avalon_jtag_uart_irq+0x124>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 10874cc:	e0bffa17 	ldw	r2,-24(fp)
 10874d0:	10c00817 	ldw	r3,32(r2)
 10874d4:	00bfff84 	movi	r2,-2
 10874d8:	1886703a 	and	r3,r3,r2
 10874dc:	e0bffa17 	ldw	r2,-24(fp)
 10874e0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 10874e4:	e0bffb17 	ldw	r2,-20(fp)
 10874e8:	10800104 	addi	r2,r2,4
 10874ec:	1007883a 	mov	r3,r2
 10874f0:	e0bffa17 	ldw	r2,-24(fp)
 10874f4:	10800817 	ldw	r2,32(r2)
 10874f8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 10874fc:	e0bffb17 	ldw	r2,-20(fp)
 1087500:	10800104 	addi	r2,r2,4
 1087504:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 1087508:	e0bffc17 	ldw	r2,-16(fp)
 108750c:	1080800c 	andi	r2,r2,512
 1087510:	103fbe26 	beq	r2,zero,108740c <__alt_data_end+0xfffb1cdc>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 1087514:	e0bffc17 	ldw	r2,-16(fp)
 1087518:	1004d43a 	srli	r2,r2,16
 108751c:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 1087520:	00001406 	br	1087574 <altera_avalon_jtag_uart_irq+0x190>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 1087524:	e0bffb17 	ldw	r2,-20(fp)
 1087528:	e0fffa17 	ldw	r3,-24(fp)
 108752c:	18c00d17 	ldw	r3,52(r3)
 1087530:	e13ffa17 	ldw	r4,-24(fp)
 1087534:	20c7883a 	add	r3,r4,r3
 1087538:	18c20e04 	addi	r3,r3,2104
 108753c:	18c00003 	ldbu	r3,0(r3)
 1087540:	18c03fcc 	andi	r3,r3,255
 1087544:	18c0201c 	xori	r3,r3,128
 1087548:	18ffe004 	addi	r3,r3,-128
 108754c:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1087550:	e0bffa17 	ldw	r2,-24(fp)
 1087554:	10800d17 	ldw	r2,52(r2)
 1087558:	10800044 	addi	r2,r2,1
 108755c:	10c1ffcc 	andi	r3,r2,2047
 1087560:	e0bffa17 	ldw	r2,-24(fp)
 1087564:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 1087568:	e0bff917 	ldw	r2,-28(fp)
 108756c:	10bfffc4 	addi	r2,r2,-1
 1087570:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 1087574:	e0bff917 	ldw	r2,-28(fp)
 1087578:	10000526 	beq	r2,zero,1087590 <altera_avalon_jtag_uart_irq+0x1ac>
 108757c:	e0bffa17 	ldw	r2,-24(fp)
 1087580:	10c00d17 	ldw	r3,52(r2)
 1087584:	e0bffa17 	ldw	r2,-24(fp)
 1087588:	10800c17 	ldw	r2,48(r2)
 108758c:	18bfe51e 	bne	r3,r2,1087524 <__alt_data_end+0xfffb1df4>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 1087590:	e0bff917 	ldw	r2,-28(fp)
 1087594:	103f9d26 	beq	r2,zero,108740c <__alt_data_end+0xfffb1cdc>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 1087598:	e0bffa17 	ldw	r2,-24(fp)
 108759c:	10c00817 	ldw	r3,32(r2)
 10875a0:	00bfff44 	movi	r2,-3
 10875a4:	1886703a 	and	r3,r3,r2
 10875a8:	e0bffa17 	ldw	r2,-24(fp)
 10875ac:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 10875b0:	e0bffa17 	ldw	r2,-24(fp)
 10875b4:	10800017 	ldw	r2,0(r2)
 10875b8:	10800104 	addi	r2,r2,4
 10875bc:	1007883a 	mov	r3,r2
 10875c0:	e0bffa17 	ldw	r2,-24(fp)
 10875c4:	10800817 	ldw	r2,32(r2)
 10875c8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 10875cc:	e0bffb17 	ldw	r2,-20(fp)
 10875d0:	10800104 	addi	r2,r2,4
 10875d4:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 10875d8:	003f8c06 	br	108740c <__alt_data_end+0xfffb1cdc>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 10875dc:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 10875e0:	0001883a 	nop
 10875e4:	e037883a 	mov	sp,fp
 10875e8:	df000017 	ldw	fp,0(sp)
 10875ec:	dec00104 	addi	sp,sp,4
 10875f0:	f800283a 	ret

010875f4 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 10875f4:	defff804 	addi	sp,sp,-32
 10875f8:	df000715 	stw	fp,28(sp)
 10875fc:	df000704 	addi	fp,sp,28
 1087600:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 1087604:	e0bffb17 	ldw	r2,-20(fp)
 1087608:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 108760c:	e0bff917 	ldw	r2,-28(fp)
 1087610:	10800017 	ldw	r2,0(r2)
 1087614:	10800104 	addi	r2,r2,4
 1087618:	10800037 	ldwio	r2,0(r2)
 108761c:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 1087620:	e0bffa17 	ldw	r2,-24(fp)
 1087624:	1081000c 	andi	r2,r2,1024
 1087628:	10000b26 	beq	r2,zero,1087658 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 108762c:	e0bff917 	ldw	r2,-28(fp)
 1087630:	10800017 	ldw	r2,0(r2)
 1087634:	10800104 	addi	r2,r2,4
 1087638:	1007883a 	mov	r3,r2
 108763c:	e0bff917 	ldw	r2,-28(fp)
 1087640:	10800817 	ldw	r2,32(r2)
 1087644:	10810014 	ori	r2,r2,1024
 1087648:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 108764c:	e0bff917 	ldw	r2,-28(fp)
 1087650:	10000915 	stw	zero,36(r2)
 1087654:	00000a06 	br	1087680 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 1087658:	e0bff917 	ldw	r2,-28(fp)
 108765c:	10c00917 	ldw	r3,36(r2)
 1087660:	00a00034 	movhi	r2,32768
 1087664:	10bfff04 	addi	r2,r2,-4
 1087668:	10c00536 	bltu	r2,r3,1087680 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 108766c:	e0bff917 	ldw	r2,-28(fp)
 1087670:	10800917 	ldw	r2,36(r2)
 1087674:	10c00044 	addi	r3,r2,1
 1087678:	e0bff917 	ldw	r2,-28(fp)
 108767c:	10c00915 	stw	r3,36(r2)
 1087680:	00804274 	movhi	r2,265
 1087684:	10acd104 	addi	r2,r2,-19644
 1087688:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 108768c:	e037883a 	mov	sp,fp
 1087690:	df000017 	ldw	fp,0(sp)
 1087694:	dec00104 	addi	sp,sp,4
 1087698:	f800283a 	ret

0108769c <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 108769c:	defffd04 	addi	sp,sp,-12
 10876a0:	df000215 	stw	fp,8(sp)
 10876a4:	df000204 	addi	fp,sp,8
 10876a8:	e13ffe15 	stw	r4,-8(fp)
 10876ac:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 10876b0:	00000506 	br	10876c8 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 10876b4:	e0bfff17 	ldw	r2,-4(fp)
 10876b8:	1090000c 	andi	r2,r2,16384
 10876bc:	10000226 	beq	r2,zero,10876c8 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 10876c0:	00bffd44 	movi	r2,-11
 10876c4:	00000b06 	br	10876f4 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 10876c8:	e0bffe17 	ldw	r2,-8(fp)
 10876cc:	10c00d17 	ldw	r3,52(r2)
 10876d0:	e0bffe17 	ldw	r2,-8(fp)
 10876d4:	10800c17 	ldw	r2,48(r2)
 10876d8:	18800526 	beq	r3,r2,10876f0 <altera_avalon_jtag_uart_close+0x54>
 10876dc:	e0bffe17 	ldw	r2,-8(fp)
 10876e0:	10c00917 	ldw	r3,36(r2)
 10876e4:	e0bffe17 	ldw	r2,-8(fp)
 10876e8:	10800117 	ldw	r2,4(r2)
 10876ec:	18bff136 	bltu	r3,r2,10876b4 <__alt_data_end+0xfffb1f84>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 10876f0:	0005883a 	mov	r2,zero
}
 10876f4:	e037883a 	mov	sp,fp
 10876f8:	df000017 	ldw	fp,0(sp)
 10876fc:	dec00104 	addi	sp,sp,4
 1087700:	f800283a 	ret

01087704 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 1087704:	defffa04 	addi	sp,sp,-24
 1087708:	df000515 	stw	fp,20(sp)
 108770c:	df000504 	addi	fp,sp,20
 1087710:	e13ffd15 	stw	r4,-12(fp)
 1087714:	e17ffe15 	stw	r5,-8(fp)
 1087718:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 108771c:	00bff9c4 	movi	r2,-25
 1087720:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 1087724:	e0bffe17 	ldw	r2,-8(fp)
 1087728:	10da8060 	cmpeqi	r3,r2,27137
 108772c:	1800031e 	bne	r3,zero,108773c <altera_avalon_jtag_uart_ioctl+0x38>
 1087730:	109a80a0 	cmpeqi	r2,r2,27138
 1087734:	1000181e 	bne	r2,zero,1087798 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 1087738:	00002906 	br	10877e0 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 108773c:	e0bffd17 	ldw	r2,-12(fp)
 1087740:	10c00117 	ldw	r3,4(r2)
 1087744:	00a00034 	movhi	r2,32768
 1087748:	10bfffc4 	addi	r2,r2,-1
 108774c:	18802126 	beq	r3,r2,10877d4 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 1087750:	e0bfff17 	ldw	r2,-4(fp)
 1087754:	10800017 	ldw	r2,0(r2)
 1087758:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 108775c:	e0bffc17 	ldw	r2,-16(fp)
 1087760:	10800090 	cmplti	r2,r2,2
 1087764:	1000061e 	bne	r2,zero,1087780 <altera_avalon_jtag_uart_ioctl+0x7c>
 1087768:	e0fffc17 	ldw	r3,-16(fp)
 108776c:	00a00034 	movhi	r2,32768
 1087770:	10bfffc4 	addi	r2,r2,-1
 1087774:	18800226 	beq	r3,r2,1087780 <altera_avalon_jtag_uart_ioctl+0x7c>
 1087778:	e0bffc17 	ldw	r2,-16(fp)
 108777c:	00000206 	br	1087788 <altera_avalon_jtag_uart_ioctl+0x84>
 1087780:	00a00034 	movhi	r2,32768
 1087784:	10bfff84 	addi	r2,r2,-2
 1087788:	e0fffd17 	ldw	r3,-12(fp)
 108778c:	18800115 	stw	r2,4(r3)
      rc = 0;
 1087790:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 1087794:	00000f06 	br	10877d4 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 1087798:	e0bffd17 	ldw	r2,-12(fp)
 108779c:	10c00117 	ldw	r3,4(r2)
 10877a0:	00a00034 	movhi	r2,32768
 10877a4:	10bfffc4 	addi	r2,r2,-1
 10877a8:	18800c26 	beq	r3,r2,10877dc <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 10877ac:	e0bffd17 	ldw	r2,-12(fp)
 10877b0:	10c00917 	ldw	r3,36(r2)
 10877b4:	e0bffd17 	ldw	r2,-12(fp)
 10877b8:	10800117 	ldw	r2,4(r2)
 10877bc:	1885803a 	cmpltu	r2,r3,r2
 10877c0:	10c03fcc 	andi	r3,r2,255
 10877c4:	e0bfff17 	ldw	r2,-4(fp)
 10877c8:	10c00015 	stw	r3,0(r2)
      rc = 0;
 10877cc:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 10877d0:	00000206 	br	10877dc <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 10877d4:	0001883a 	nop
 10877d8:	00000106 	br	10877e0 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 10877dc:	0001883a 	nop

  default:
    break;
  }

  return rc;
 10877e0:	e0bffb17 	ldw	r2,-20(fp)
}
 10877e4:	e037883a 	mov	sp,fp
 10877e8:	df000017 	ldw	fp,0(sp)
 10877ec:	dec00104 	addi	sp,sp,4
 10877f0:	f800283a 	ret

010877f4 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 10877f4:	defff304 	addi	sp,sp,-52
 10877f8:	dfc00c15 	stw	ra,48(sp)
 10877fc:	df000b15 	stw	fp,44(sp)
 1087800:	df000b04 	addi	fp,sp,44
 1087804:	e13ffc15 	stw	r4,-16(fp)
 1087808:	e17ffd15 	stw	r5,-12(fp)
 108780c:	e1bffe15 	stw	r6,-8(fp)
 1087810:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 1087814:	e0bffd17 	ldw	r2,-12(fp)
 1087818:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 108781c:	00004706 	br	108793c <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 1087820:	e0bffc17 	ldw	r2,-16(fp)
 1087824:	10800a17 	ldw	r2,40(r2)
 1087828:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 108782c:	e0bffc17 	ldw	r2,-16(fp)
 1087830:	10800b17 	ldw	r2,44(r2)
 1087834:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
 1087838:	e0fff717 	ldw	r3,-36(fp)
 108783c:	e0bff817 	ldw	r2,-32(fp)
 1087840:	18800536 	bltu	r3,r2,1087858 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 1087844:	e0fff717 	ldw	r3,-36(fp)
 1087848:	e0bff817 	ldw	r2,-32(fp)
 108784c:	1885c83a 	sub	r2,r3,r2
 1087850:	e0bff615 	stw	r2,-40(fp)
 1087854:	00000406 	br	1087868 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 1087858:	00c20004 	movi	r3,2048
 108785c:	e0bff817 	ldw	r2,-32(fp)
 1087860:	1885c83a 	sub	r2,r3,r2
 1087864:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 1087868:	e0bff617 	ldw	r2,-40(fp)
 108786c:	10001e26 	beq	r2,zero,10878e8 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 1087870:	e0fffe17 	ldw	r3,-8(fp)
 1087874:	e0bff617 	ldw	r2,-40(fp)
 1087878:	1880022e 	bgeu	r3,r2,1087884 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 108787c:	e0bffe17 	ldw	r2,-8(fp)
 1087880:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 1087884:	e0bffc17 	ldw	r2,-16(fp)
 1087888:	10c00e04 	addi	r3,r2,56
 108788c:	e0bff817 	ldw	r2,-32(fp)
 1087890:	1885883a 	add	r2,r3,r2
 1087894:	e1bff617 	ldw	r6,-40(fp)
 1087898:	100b883a 	mov	r5,r2
 108789c:	e13ff517 	ldw	r4,-44(fp)
 10878a0:	108633c0 	call	108633c <memcpy>
      ptr   += n;
 10878a4:	e0fff517 	ldw	r3,-44(fp)
 10878a8:	e0bff617 	ldw	r2,-40(fp)
 10878ac:	1885883a 	add	r2,r3,r2
 10878b0:	e0bff515 	stw	r2,-44(fp)
      space -= n;
 10878b4:	e0fffe17 	ldw	r3,-8(fp)
 10878b8:	e0bff617 	ldw	r2,-40(fp)
 10878bc:	1885c83a 	sub	r2,r3,r2
 10878c0:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 10878c4:	e0fff817 	ldw	r3,-32(fp)
 10878c8:	e0bff617 	ldw	r2,-40(fp)
 10878cc:	1885883a 	add	r2,r3,r2
 10878d0:	10c1ffcc 	andi	r3,r2,2047
 10878d4:	e0bffc17 	ldw	r2,-16(fp)
 10878d8:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 10878dc:	e0bffe17 	ldw	r2,-8(fp)
 10878e0:	00bfcf16 	blt	zero,r2,1087820 <__alt_data_end+0xfffb20f0>
 10878e4:	00000106 	br	10878ec <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 10878e8:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 10878ec:	e0fff517 	ldw	r3,-44(fp)
 10878f0:	e0bffd17 	ldw	r2,-12(fp)
 10878f4:	1880141e 	bne	r3,r2,1087948 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 10878f8:	e0bfff17 	ldw	r2,-4(fp)
 10878fc:	1090000c 	andi	r2,r2,16384
 1087900:	1000131e 	bne	r2,zero,1087950 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 1087904:	0001883a 	nop
 1087908:	e0bffc17 	ldw	r2,-16(fp)
 108790c:	10c00a17 	ldw	r3,40(r2)
 1087910:	e0bff717 	ldw	r2,-36(fp)
 1087914:	1880051e 	bne	r3,r2,108792c <altera_avalon_jtag_uart_read+0x138>
 1087918:	e0bffc17 	ldw	r2,-16(fp)
 108791c:	10c00917 	ldw	r3,36(r2)
 1087920:	e0bffc17 	ldw	r2,-16(fp)
 1087924:	10800117 	ldw	r2,4(r2)
 1087928:	18bff736 	bltu	r3,r2,1087908 <__alt_data_end+0xfffb21d8>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 108792c:	e0bffc17 	ldw	r2,-16(fp)
 1087930:	10c00a17 	ldw	r3,40(r2)
 1087934:	e0bff717 	ldw	r2,-36(fp)
 1087938:	18800726 	beq	r3,r2,1087958 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 108793c:	e0bffe17 	ldw	r2,-8(fp)
 1087940:	00bfb716 	blt	zero,r2,1087820 <__alt_data_end+0xfffb20f0>
 1087944:	00000506 	br	108795c <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 1087948:	0001883a 	nop
 108794c:	00000306 	br	108795c <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 1087950:	0001883a 	nop
 1087954:	00000106 	br	108795c <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 1087958:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 108795c:	e0fff517 	ldw	r3,-44(fp)
 1087960:	e0bffd17 	ldw	r2,-12(fp)
 1087964:	18801826 	beq	r3,r2,10879c8 <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1087968:	0005303a 	rdctl	r2,status
 108796c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1087970:	e0fffb17 	ldw	r3,-20(fp)
 1087974:	00bfff84 	movi	r2,-2
 1087978:	1884703a 	and	r2,r3,r2
 108797c:	1001703a 	wrctl	status,r2
  
  return context;
 1087980:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 1087984:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1087988:	e0bffc17 	ldw	r2,-16(fp)
 108798c:	10800817 	ldw	r2,32(r2)
 1087990:	10c00054 	ori	r3,r2,1
 1087994:	e0bffc17 	ldw	r2,-16(fp)
 1087998:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 108799c:	e0bffc17 	ldw	r2,-16(fp)
 10879a0:	10800017 	ldw	r2,0(r2)
 10879a4:	10800104 	addi	r2,r2,4
 10879a8:	1007883a 	mov	r3,r2
 10879ac:	e0bffc17 	ldw	r2,-16(fp)
 10879b0:	10800817 	ldw	r2,32(r2)
 10879b4:	18800035 	stwio	r2,0(r3)
 10879b8:	e0bffa17 	ldw	r2,-24(fp)
 10879bc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 10879c0:	e0bff917 	ldw	r2,-28(fp)
 10879c4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 10879c8:	e0fff517 	ldw	r3,-44(fp)
 10879cc:	e0bffd17 	ldw	r2,-12(fp)
 10879d0:	18800426 	beq	r3,r2,10879e4 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
 10879d4:	e0fff517 	ldw	r3,-44(fp)
 10879d8:	e0bffd17 	ldw	r2,-12(fp)
 10879dc:	1885c83a 	sub	r2,r3,r2
 10879e0:	00000606 	br	10879fc <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
 10879e4:	e0bfff17 	ldw	r2,-4(fp)
 10879e8:	1090000c 	andi	r2,r2,16384
 10879ec:	10000226 	beq	r2,zero,10879f8 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 10879f0:	00bffd44 	movi	r2,-11
 10879f4:	00000106 	br	10879fc <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
 10879f8:	00bffec4 	movi	r2,-5
}
 10879fc:	e037883a 	mov	sp,fp
 1087a00:	dfc00117 	ldw	ra,4(sp)
 1087a04:	df000017 	ldw	fp,0(sp)
 1087a08:	dec00204 	addi	sp,sp,8
 1087a0c:	f800283a 	ret

01087a10 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 1087a10:	defff304 	addi	sp,sp,-52
 1087a14:	dfc00c15 	stw	ra,48(sp)
 1087a18:	df000b15 	stw	fp,44(sp)
 1087a1c:	df000b04 	addi	fp,sp,44
 1087a20:	e13ffc15 	stw	r4,-16(fp)
 1087a24:	e17ffd15 	stw	r5,-12(fp)
 1087a28:	e1bffe15 	stw	r6,-8(fp)
 1087a2c:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 1087a30:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 1087a34:	e0bffd17 	ldw	r2,-12(fp)
 1087a38:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 1087a3c:	00003706 	br	1087b1c <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 1087a40:	e0bffc17 	ldw	r2,-16(fp)
 1087a44:	10800c17 	ldw	r2,48(r2)
 1087a48:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 1087a4c:	e0bffc17 	ldw	r2,-16(fp)
 1087a50:	10800d17 	ldw	r2,52(r2)
 1087a54:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
 1087a58:	e0fff917 	ldw	r3,-28(fp)
 1087a5c:	e0bff517 	ldw	r2,-44(fp)
 1087a60:	1880062e 	bgeu	r3,r2,1087a7c <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 1087a64:	e0fff517 	ldw	r3,-44(fp)
 1087a68:	e0bff917 	ldw	r2,-28(fp)
 1087a6c:	1885c83a 	sub	r2,r3,r2
 1087a70:	10bfffc4 	addi	r2,r2,-1
 1087a74:	e0bff615 	stw	r2,-40(fp)
 1087a78:	00000b06 	br	1087aa8 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 1087a7c:	e0bff517 	ldw	r2,-44(fp)
 1087a80:	10000526 	beq	r2,zero,1087a98 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 1087a84:	00c20004 	movi	r3,2048
 1087a88:	e0bff917 	ldw	r2,-28(fp)
 1087a8c:	1885c83a 	sub	r2,r3,r2
 1087a90:	e0bff615 	stw	r2,-40(fp)
 1087a94:	00000406 	br	1087aa8 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 1087a98:	00c1ffc4 	movi	r3,2047
 1087a9c:	e0bff917 	ldw	r2,-28(fp)
 1087aa0:	1885c83a 	sub	r2,r3,r2
 1087aa4:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 1087aa8:	e0bff617 	ldw	r2,-40(fp)
 1087aac:	10001e26 	beq	r2,zero,1087b28 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 1087ab0:	e0fffe17 	ldw	r3,-8(fp)
 1087ab4:	e0bff617 	ldw	r2,-40(fp)
 1087ab8:	1880022e 	bgeu	r3,r2,1087ac4 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 1087abc:	e0bffe17 	ldw	r2,-8(fp)
 1087ac0:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 1087ac4:	e0bffc17 	ldw	r2,-16(fp)
 1087ac8:	10c20e04 	addi	r3,r2,2104
 1087acc:	e0bff917 	ldw	r2,-28(fp)
 1087ad0:	1885883a 	add	r2,r3,r2
 1087ad4:	e1bff617 	ldw	r6,-40(fp)
 1087ad8:	e17ffd17 	ldw	r5,-12(fp)
 1087adc:	1009883a 	mov	r4,r2
 1087ae0:	108633c0 	call	108633c <memcpy>
      ptr   += n;
 1087ae4:	e0fffd17 	ldw	r3,-12(fp)
 1087ae8:	e0bff617 	ldw	r2,-40(fp)
 1087aec:	1885883a 	add	r2,r3,r2
 1087af0:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 1087af4:	e0fffe17 	ldw	r3,-8(fp)
 1087af8:	e0bff617 	ldw	r2,-40(fp)
 1087afc:	1885c83a 	sub	r2,r3,r2
 1087b00:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1087b04:	e0fff917 	ldw	r3,-28(fp)
 1087b08:	e0bff617 	ldw	r2,-40(fp)
 1087b0c:	1885883a 	add	r2,r3,r2
 1087b10:	10c1ffcc 	andi	r3,r2,2047
 1087b14:	e0bffc17 	ldw	r2,-16(fp)
 1087b18:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 1087b1c:	e0bffe17 	ldw	r2,-8(fp)
 1087b20:	00bfc716 	blt	zero,r2,1087a40 <__alt_data_end+0xfffb2310>
 1087b24:	00000106 	br	1087b2c <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 1087b28:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1087b2c:	0005303a 	rdctl	r2,status
 1087b30:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1087b34:	e0fffb17 	ldw	r3,-20(fp)
 1087b38:	00bfff84 	movi	r2,-2
 1087b3c:	1884703a 	and	r2,r3,r2
 1087b40:	1001703a 	wrctl	status,r2
  
  return context;
 1087b44:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 1087b48:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 1087b4c:	e0bffc17 	ldw	r2,-16(fp)
 1087b50:	10800817 	ldw	r2,32(r2)
 1087b54:	10c00094 	ori	r3,r2,2
 1087b58:	e0bffc17 	ldw	r2,-16(fp)
 1087b5c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 1087b60:	e0bffc17 	ldw	r2,-16(fp)
 1087b64:	10800017 	ldw	r2,0(r2)
 1087b68:	10800104 	addi	r2,r2,4
 1087b6c:	1007883a 	mov	r3,r2
 1087b70:	e0bffc17 	ldw	r2,-16(fp)
 1087b74:	10800817 	ldw	r2,32(r2)
 1087b78:	18800035 	stwio	r2,0(r3)
 1087b7c:	e0bffa17 	ldw	r2,-24(fp)
 1087b80:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1087b84:	e0bff817 	ldw	r2,-32(fp)
 1087b88:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 1087b8c:	e0bffe17 	ldw	r2,-8(fp)
 1087b90:	0080100e 	bge	zero,r2,1087bd4 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
 1087b94:	e0bfff17 	ldw	r2,-4(fp)
 1087b98:	1090000c 	andi	r2,r2,16384
 1087b9c:	1000101e 	bne	r2,zero,1087be0 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 1087ba0:	0001883a 	nop
 1087ba4:	e0bffc17 	ldw	r2,-16(fp)
 1087ba8:	10c00d17 	ldw	r3,52(r2)
 1087bac:	e0bff517 	ldw	r2,-44(fp)
 1087bb0:	1880051e 	bne	r3,r2,1087bc8 <altera_avalon_jtag_uart_write+0x1b8>
 1087bb4:	e0bffc17 	ldw	r2,-16(fp)
 1087bb8:	10c00917 	ldw	r3,36(r2)
 1087bbc:	e0bffc17 	ldw	r2,-16(fp)
 1087bc0:	10800117 	ldw	r2,4(r2)
 1087bc4:	18bff736 	bltu	r3,r2,1087ba4 <__alt_data_end+0xfffb2474>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 1087bc8:	e0bffc17 	ldw	r2,-16(fp)
 1087bcc:	10800917 	ldw	r2,36(r2)
 1087bd0:	1000051e 	bne	r2,zero,1087be8 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
 1087bd4:	e0bffe17 	ldw	r2,-8(fp)
 1087bd8:	00bfd016 	blt	zero,r2,1087b1c <__alt_data_end+0xfffb23ec>
 1087bdc:	00000306 	br	1087bec <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 1087be0:	0001883a 	nop
 1087be4:	00000106 	br	1087bec <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 1087be8:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 1087bec:	e0fffd17 	ldw	r3,-12(fp)
 1087bf0:	e0bff717 	ldw	r2,-36(fp)
 1087bf4:	18800426 	beq	r3,r2,1087c08 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
 1087bf8:	e0fffd17 	ldw	r3,-12(fp)
 1087bfc:	e0bff717 	ldw	r2,-36(fp)
 1087c00:	1885c83a 	sub	r2,r3,r2
 1087c04:	00000606 	br	1087c20 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
 1087c08:	e0bfff17 	ldw	r2,-4(fp)
 1087c0c:	1090000c 	andi	r2,r2,16384
 1087c10:	10000226 	beq	r2,zero,1087c1c <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
 1087c14:	00bffd44 	movi	r2,-11
 1087c18:	00000106 	br	1087c20 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 1087c1c:	00bffec4 	movi	r2,-5
}
 1087c20:	e037883a 	mov	sp,fp
 1087c24:	dfc00117 	ldw	ra,4(sp)
 1087c28:	df000017 	ldw	fp,0(sp)
 1087c2c:	dec00204 	addi	sp,sp,8
 1087c30:	f800283a 	ret

01087c34 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 1087c34:	defff504 	addi	sp,sp,-44
 1087c38:	df000a15 	stw	fp,40(sp)
 1087c3c:	df000a04 	addi	fp,sp,40
 1087c40:	e13ffc15 	stw	r4,-16(fp)
 1087c44:	e17ffd15 	stw	r5,-12(fp)
 1087c48:	e1bffe15 	stw	r6,-8(fp)
 1087c4c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 1087c50:	e03ff615 	stw	zero,-40(fp)
 1087c54:	00804274 	movhi	r2,265
 1087c58:	10acd104 	addi	r2,r2,-19644
 1087c5c:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 1087c60:	10003f26 	beq	r2,zero,1087d60 <alt_alarm_start+0x12c>
  {
    if (alarm)
 1087c64:	e0bffc17 	ldw	r2,-16(fp)
 1087c68:	10003b26 	beq	r2,zero,1087d58 <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
 1087c6c:	e0bffc17 	ldw	r2,-16(fp)
 1087c70:	e0fffe17 	ldw	r3,-8(fp)
 1087c74:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 1087c78:	e0bffc17 	ldw	r2,-16(fp)
 1087c7c:	e0ffff17 	ldw	r3,-4(fp)
 1087c80:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1087c84:	0005303a 	rdctl	r2,status
 1087c88:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1087c8c:	e0fff917 	ldw	r3,-28(fp)
 1087c90:	00bfff84 	movi	r2,-2
 1087c94:	1884703a 	and	r2,r3,r2
 1087c98:	1001703a 	wrctl	status,r2
  
  return context;
 1087c9c:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 1087ca0:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 1087ca4:	00804274 	movhi	r2,265
 1087ca8:	10acd204 	addi	r2,r2,-19640
 1087cac:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 1087cb0:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 1087cb4:	e0fffd17 	ldw	r3,-12(fp)
 1087cb8:	e0bff617 	ldw	r2,-40(fp)
 1087cbc:	1885883a 	add	r2,r3,r2
 1087cc0:	10c00044 	addi	r3,r2,1
 1087cc4:	e0bffc17 	ldw	r2,-16(fp)
 1087cc8:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 1087ccc:	e0bffc17 	ldw	r2,-16(fp)
 1087cd0:	10c00217 	ldw	r3,8(r2)
 1087cd4:	e0bff617 	ldw	r2,-40(fp)
 1087cd8:	1880042e 	bgeu	r3,r2,1087cec <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
 1087cdc:	e0bffc17 	ldw	r2,-16(fp)
 1087ce0:	00c00044 	movi	r3,1
 1087ce4:	10c00405 	stb	r3,16(r2)
 1087ce8:	00000206 	br	1087cf4 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
 1087cec:	e0bffc17 	ldw	r2,-16(fp)
 1087cf0:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 1087cf4:	e0fffc17 	ldw	r3,-16(fp)
 1087cf8:	00804274 	movhi	r2,265
 1087cfc:	10a7f004 	addi	r2,r2,-24640
 1087d00:	e0bffa15 	stw	r2,-24(fp)
 1087d04:	e0fffb15 	stw	r3,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 1087d08:	e0bffb17 	ldw	r2,-20(fp)
 1087d0c:	e0fffa17 	ldw	r3,-24(fp)
 1087d10:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 1087d14:	e0bffa17 	ldw	r2,-24(fp)
 1087d18:	10c00017 	ldw	r3,0(r2)
 1087d1c:	e0bffb17 	ldw	r2,-20(fp)
 1087d20:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 1087d24:	e0bffa17 	ldw	r2,-24(fp)
 1087d28:	10800017 	ldw	r2,0(r2)
 1087d2c:	e0fffb17 	ldw	r3,-20(fp)
 1087d30:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 1087d34:	e0bffa17 	ldw	r2,-24(fp)
 1087d38:	e0fffb17 	ldw	r3,-20(fp)
 1087d3c:	10c00015 	stw	r3,0(r2)
 1087d40:	e0bff817 	ldw	r2,-32(fp)
 1087d44:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1087d48:	e0bff717 	ldw	r2,-36(fp)
 1087d4c:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 1087d50:	0005883a 	mov	r2,zero
 1087d54:	00000306 	br	1087d64 <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
 1087d58:	00bffa84 	movi	r2,-22
 1087d5c:	00000106 	br	1087d64 <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
 1087d60:	00bfde84 	movi	r2,-134
  }
}
 1087d64:	e037883a 	mov	sp,fp
 1087d68:	df000017 	ldw	fp,0(sp)
 1087d6c:	dec00104 	addi	sp,sp,4
 1087d70:	f800283a 	ret

01087d74 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1087d74:	defffe04 	addi	sp,sp,-8
 1087d78:	dfc00115 	stw	ra,4(sp)
 1087d7c:	df000015 	stw	fp,0(sp)
 1087d80:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1087d84:	00804274 	movhi	r2,265
 1087d88:	10a7ef04 	addi	r2,r2,-24644
 1087d8c:	10800017 	ldw	r2,0(r2)
 1087d90:	10000526 	beq	r2,zero,1087da8 <alt_get_errno+0x34>
 1087d94:	00804274 	movhi	r2,265
 1087d98:	10a7ef04 	addi	r2,r2,-24644
 1087d9c:	10800017 	ldw	r2,0(r2)
 1087da0:	103ee83a 	callr	r2
 1087da4:	00000206 	br	1087db0 <alt_get_errno+0x3c>
 1087da8:	00804274 	movhi	r2,265
 1087dac:	10accc04 	addi	r2,r2,-19664
}
 1087db0:	e037883a 	mov	sp,fp
 1087db4:	dfc00117 	ldw	ra,4(sp)
 1087db8:	df000017 	ldw	fp,0(sp)
 1087dbc:	dec00204 	addi	sp,sp,8
 1087dc0:	f800283a 	ret

01087dc4 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 1087dc4:	defffb04 	addi	sp,sp,-20
 1087dc8:	dfc00415 	stw	ra,16(sp)
 1087dcc:	df000315 	stw	fp,12(sp)
 1087dd0:	df000304 	addi	fp,sp,12
 1087dd4:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 1087dd8:	e0bfff17 	ldw	r2,-4(fp)
 1087ddc:	10000616 	blt	r2,zero,1087df8 <close+0x34>
 1087de0:	e0bfff17 	ldw	r2,-4(fp)
 1087de4:	10c00324 	muli	r3,r2,12
 1087de8:	00804274 	movhi	r2,265
 1087dec:	10a78704 	addi	r2,r2,-25060
 1087df0:	1885883a 	add	r2,r3,r2
 1087df4:	00000106 	br	1087dfc <close+0x38>
 1087df8:	0005883a 	mov	r2,zero
 1087dfc:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 1087e00:	e0bffd17 	ldw	r2,-12(fp)
 1087e04:	10001926 	beq	r2,zero,1087e6c <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 1087e08:	e0bffd17 	ldw	r2,-12(fp)
 1087e0c:	10800017 	ldw	r2,0(r2)
 1087e10:	10800417 	ldw	r2,16(r2)
 1087e14:	10000626 	beq	r2,zero,1087e30 <close+0x6c>
 1087e18:	e0bffd17 	ldw	r2,-12(fp)
 1087e1c:	10800017 	ldw	r2,0(r2)
 1087e20:	10800417 	ldw	r2,16(r2)
 1087e24:	e13ffd17 	ldw	r4,-12(fp)
 1087e28:	103ee83a 	callr	r2
 1087e2c:	00000106 	br	1087e34 <close+0x70>
 1087e30:	0005883a 	mov	r2,zero
 1087e34:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 1087e38:	e13fff17 	ldw	r4,-4(fp)
 1087e3c:	10883e40 	call	10883e4 <alt_release_fd>
    if (rval < 0)
 1087e40:	e0bffe17 	ldw	r2,-8(fp)
 1087e44:	1000070e 	bge	r2,zero,1087e64 <close+0xa0>
    {
      ALT_ERRNO = -rval;
 1087e48:	1087d740 	call	1087d74 <alt_get_errno>
 1087e4c:	1007883a 	mov	r3,r2
 1087e50:	e0bffe17 	ldw	r2,-8(fp)
 1087e54:	0085c83a 	sub	r2,zero,r2
 1087e58:	18800015 	stw	r2,0(r3)
      return -1;
 1087e5c:	00bfffc4 	movi	r2,-1
 1087e60:	00000706 	br	1087e80 <close+0xbc>
    }
    return 0;
 1087e64:	0005883a 	mov	r2,zero
 1087e68:	00000506 	br	1087e80 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1087e6c:	1087d740 	call	1087d74 <alt_get_errno>
 1087e70:	1007883a 	mov	r3,r2
 1087e74:	00801444 	movi	r2,81
 1087e78:	18800015 	stw	r2,0(r3)
    return -1;
 1087e7c:	00bfffc4 	movi	r2,-1
  }
}
 1087e80:	e037883a 	mov	sp,fp
 1087e84:	dfc00117 	ldw	ra,4(sp)
 1087e88:	df000017 	ldw	fp,0(sp)
 1087e8c:	dec00204 	addi	sp,sp,8
 1087e90:	f800283a 	ret

01087e94 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 1087e94:	defffe04 	addi	sp,sp,-8
 1087e98:	df000115 	stw	fp,4(sp)
 1087e9c:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 1087ea0:	e03fff15 	stw	zero,-4(fp)
 1087ea4:	00000506 	br	1087ebc <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 1087ea8:	e0bfff17 	ldw	r2,-4(fp)
 1087eac:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 1087eb0:	e0bfff17 	ldw	r2,-4(fp)
 1087eb4:	10800804 	addi	r2,r2,32
 1087eb8:	e0bfff15 	stw	r2,-4(fp)
 1087ebc:	e0bfff17 	ldw	r2,-4(fp)
 1087ec0:	10820030 	cmpltui	r2,r2,2048
 1087ec4:	103ff81e 	bne	r2,zero,1087ea8 <__alt_data_end+0xfffb2778>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 1087ec8:	0001883a 	nop
 1087ecc:	e037883a 	mov	sp,fp
 1087ed0:	df000017 	ldw	fp,0(sp)
 1087ed4:	dec00104 	addi	sp,sp,4
 1087ed8:	f800283a 	ret

01087edc <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 1087edc:	defffc04 	addi	sp,sp,-16
 1087ee0:	df000315 	stw	fp,12(sp)
 1087ee4:	df000304 	addi	fp,sp,12
 1087ee8:	e13ffd15 	stw	r4,-12(fp)
 1087eec:	e17ffe15 	stw	r5,-8(fp)
 1087ef0:	e1bfff15 	stw	r6,-4(fp)
  return len;
 1087ef4:	e0bfff17 	ldw	r2,-4(fp)
}
 1087ef8:	e037883a 	mov	sp,fp
 1087efc:	df000017 	ldw	fp,0(sp)
 1087f00:	dec00104 	addi	sp,sp,4
 1087f04:	f800283a 	ret

01087f08 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1087f08:	defffe04 	addi	sp,sp,-8
 1087f0c:	dfc00115 	stw	ra,4(sp)
 1087f10:	df000015 	stw	fp,0(sp)
 1087f14:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1087f18:	00804274 	movhi	r2,265
 1087f1c:	10a7ef04 	addi	r2,r2,-24644
 1087f20:	10800017 	ldw	r2,0(r2)
 1087f24:	10000526 	beq	r2,zero,1087f3c <alt_get_errno+0x34>
 1087f28:	00804274 	movhi	r2,265
 1087f2c:	10a7ef04 	addi	r2,r2,-24644
 1087f30:	10800017 	ldw	r2,0(r2)
 1087f34:	103ee83a 	callr	r2
 1087f38:	00000206 	br	1087f44 <alt_get_errno+0x3c>
 1087f3c:	00804274 	movhi	r2,265
 1087f40:	10accc04 	addi	r2,r2,-19664
}
 1087f44:	e037883a 	mov	sp,fp
 1087f48:	dfc00117 	ldw	ra,4(sp)
 1087f4c:	df000017 	ldw	fp,0(sp)
 1087f50:	dec00204 	addi	sp,sp,8
 1087f54:	f800283a 	ret

01087f58 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 1087f58:	defffa04 	addi	sp,sp,-24
 1087f5c:	dfc00515 	stw	ra,20(sp)
 1087f60:	df000415 	stw	fp,16(sp)
 1087f64:	df000404 	addi	fp,sp,16
 1087f68:	e13ffe15 	stw	r4,-8(fp)
 1087f6c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 1087f70:	e0bffe17 	ldw	r2,-8(fp)
 1087f74:	10000326 	beq	r2,zero,1087f84 <alt_dev_llist_insert+0x2c>
 1087f78:	e0bffe17 	ldw	r2,-8(fp)
 1087f7c:	10800217 	ldw	r2,8(r2)
 1087f80:	1000061e 	bne	r2,zero,1087f9c <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 1087f84:	1087f080 	call	1087f08 <alt_get_errno>
 1087f88:	1007883a 	mov	r3,r2
 1087f8c:	00800584 	movi	r2,22
 1087f90:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 1087f94:	00bffa84 	movi	r2,-22
 1087f98:	00001306 	br	1087fe8 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 1087f9c:	e0bffe17 	ldw	r2,-8(fp)
 1087fa0:	e0ffff17 	ldw	r3,-4(fp)
 1087fa4:	e0fffc15 	stw	r3,-16(fp)
 1087fa8:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 1087fac:	e0bffd17 	ldw	r2,-12(fp)
 1087fb0:	e0fffc17 	ldw	r3,-16(fp)
 1087fb4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 1087fb8:	e0bffc17 	ldw	r2,-16(fp)
 1087fbc:	10c00017 	ldw	r3,0(r2)
 1087fc0:	e0bffd17 	ldw	r2,-12(fp)
 1087fc4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 1087fc8:	e0bffc17 	ldw	r2,-16(fp)
 1087fcc:	10800017 	ldw	r2,0(r2)
 1087fd0:	e0fffd17 	ldw	r3,-12(fp)
 1087fd4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 1087fd8:	e0bffc17 	ldw	r2,-16(fp)
 1087fdc:	e0fffd17 	ldw	r3,-12(fp)
 1087fe0:	10c00015 	stw	r3,0(r2)

  return 0;  
 1087fe4:	0005883a 	mov	r2,zero
}
 1087fe8:	e037883a 	mov	sp,fp
 1087fec:	dfc00117 	ldw	ra,4(sp)
 1087ff0:	df000017 	ldw	fp,0(sp)
 1087ff4:	dec00204 	addi	sp,sp,8
 1087ff8:	f800283a 	ret

01087ffc <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 1087ffc:	defffe04 	addi	sp,sp,-8
 1088000:	dfc00115 	stw	ra,4(sp)
 1088004:	df000015 	stw	fp,0(sp)
 1088008:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 108800c:	01440004 	movi	r5,4096
 1088010:	0009883a 	mov	r4,zero
 1088014:	10888680 	call	1088868 <alt_icache_flush>
#endif
}
 1088018:	0001883a 	nop
 108801c:	e037883a 	mov	sp,fp
 1088020:	dfc00117 	ldw	ra,4(sp)
 1088024:	df000017 	ldw	fp,0(sp)
 1088028:	dec00204 	addi	sp,sp,8
 108802c:	f800283a 	ret

01088030 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 1088030:	defff904 	addi	sp,sp,-28
 1088034:	dfc00615 	stw	ra,24(sp)
 1088038:	df000515 	stw	fp,20(sp)
 108803c:	df000504 	addi	fp,sp,20
 1088040:	e13ffc15 	stw	r4,-16(fp)
 1088044:	e17ffd15 	stw	r5,-12(fp)
 1088048:	e1bffe15 	stw	r6,-8(fp)
 108804c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 1088050:	e1bfff17 	ldw	r6,-4(fp)
 1088054:	e17ffe17 	ldw	r5,-8(fp)
 1088058:	e13ffd17 	ldw	r4,-12(fp)
 108805c:	108828c0 	call	108828c <open>
 1088060:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 1088064:	e0bffb17 	ldw	r2,-20(fp)
 1088068:	10001c16 	blt	r2,zero,10880dc <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 108806c:	00804274 	movhi	r2,265
 1088070:	10a78704 	addi	r2,r2,-25060
 1088074:	e0fffb17 	ldw	r3,-20(fp)
 1088078:	18c00324 	muli	r3,r3,12
 108807c:	10c5883a 	add	r2,r2,r3
 1088080:	10c00017 	ldw	r3,0(r2)
 1088084:	e0bffc17 	ldw	r2,-16(fp)
 1088088:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 108808c:	00804274 	movhi	r2,265
 1088090:	10a78704 	addi	r2,r2,-25060
 1088094:	e0fffb17 	ldw	r3,-20(fp)
 1088098:	18c00324 	muli	r3,r3,12
 108809c:	10c5883a 	add	r2,r2,r3
 10880a0:	10800104 	addi	r2,r2,4
 10880a4:	10c00017 	ldw	r3,0(r2)
 10880a8:	e0bffc17 	ldw	r2,-16(fp)
 10880ac:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 10880b0:	00804274 	movhi	r2,265
 10880b4:	10a78704 	addi	r2,r2,-25060
 10880b8:	e0fffb17 	ldw	r3,-20(fp)
 10880bc:	18c00324 	muli	r3,r3,12
 10880c0:	10c5883a 	add	r2,r2,r3
 10880c4:	10800204 	addi	r2,r2,8
 10880c8:	10c00017 	ldw	r3,0(r2)
 10880cc:	e0bffc17 	ldw	r2,-16(fp)
 10880d0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 10880d4:	e13ffb17 	ldw	r4,-20(fp)
 10880d8:	10883e40 	call	10883e4 <alt_release_fd>
  }
} 
 10880dc:	0001883a 	nop
 10880e0:	e037883a 	mov	sp,fp
 10880e4:	dfc00117 	ldw	ra,4(sp)
 10880e8:	df000017 	ldw	fp,0(sp)
 10880ec:	dec00204 	addi	sp,sp,8
 10880f0:	f800283a 	ret

010880f4 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 10880f4:	defffb04 	addi	sp,sp,-20
 10880f8:	dfc00415 	stw	ra,16(sp)
 10880fc:	df000315 	stw	fp,12(sp)
 1088100:	df000304 	addi	fp,sp,12
 1088104:	e13ffd15 	stw	r4,-12(fp)
 1088108:	e17ffe15 	stw	r5,-8(fp)
 108810c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 1088110:	01c07fc4 	movi	r7,511
 1088114:	01800044 	movi	r6,1
 1088118:	e17ffd17 	ldw	r5,-12(fp)
 108811c:	01004274 	movhi	r4,265
 1088120:	21278a04 	addi	r4,r4,-25048
 1088124:	10880300 	call	1088030 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 1088128:	01c07fc4 	movi	r7,511
 108812c:	000d883a 	mov	r6,zero
 1088130:	e17ffe17 	ldw	r5,-8(fp)
 1088134:	01004274 	movhi	r4,265
 1088138:	21278704 	addi	r4,r4,-25060
 108813c:	10880300 	call	1088030 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 1088140:	01c07fc4 	movi	r7,511
 1088144:	01800044 	movi	r6,1
 1088148:	e17fff17 	ldw	r5,-4(fp)
 108814c:	01004274 	movhi	r4,265
 1088150:	21278d04 	addi	r4,r4,-25036
 1088154:	10880300 	call	1088030 <alt_open_fd>
}  
 1088158:	0001883a 	nop
 108815c:	e037883a 	mov	sp,fp
 1088160:	dfc00117 	ldw	ra,4(sp)
 1088164:	df000017 	ldw	fp,0(sp)
 1088168:	dec00204 	addi	sp,sp,8
 108816c:	f800283a 	ret

01088170 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1088170:	defffe04 	addi	sp,sp,-8
 1088174:	dfc00115 	stw	ra,4(sp)
 1088178:	df000015 	stw	fp,0(sp)
 108817c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1088180:	00804274 	movhi	r2,265
 1088184:	10a7ef04 	addi	r2,r2,-24644
 1088188:	10800017 	ldw	r2,0(r2)
 108818c:	10000526 	beq	r2,zero,10881a4 <alt_get_errno+0x34>
 1088190:	00804274 	movhi	r2,265
 1088194:	10a7ef04 	addi	r2,r2,-24644
 1088198:	10800017 	ldw	r2,0(r2)
 108819c:	103ee83a 	callr	r2
 10881a0:	00000206 	br	10881ac <alt_get_errno+0x3c>
 10881a4:	00804274 	movhi	r2,265
 10881a8:	10accc04 	addi	r2,r2,-19664
}
 10881ac:	e037883a 	mov	sp,fp
 10881b0:	dfc00117 	ldw	ra,4(sp)
 10881b4:	df000017 	ldw	fp,0(sp)
 10881b8:	dec00204 	addi	sp,sp,8
 10881bc:	f800283a 	ret

010881c0 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 10881c0:	defffd04 	addi	sp,sp,-12
 10881c4:	df000215 	stw	fp,8(sp)
 10881c8:	df000204 	addi	fp,sp,8
 10881cc:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 10881d0:	e0bfff17 	ldw	r2,-4(fp)
 10881d4:	10800217 	ldw	r2,8(r2)
 10881d8:	10d00034 	orhi	r3,r2,16384
 10881dc:	e0bfff17 	ldw	r2,-4(fp)
 10881e0:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 10881e4:	e03ffe15 	stw	zero,-8(fp)
 10881e8:	00001d06 	br	1088260 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 10881ec:	00804274 	movhi	r2,265
 10881f0:	10a78704 	addi	r2,r2,-25060
 10881f4:	e0fffe17 	ldw	r3,-8(fp)
 10881f8:	18c00324 	muli	r3,r3,12
 10881fc:	10c5883a 	add	r2,r2,r3
 1088200:	10c00017 	ldw	r3,0(r2)
 1088204:	e0bfff17 	ldw	r2,-4(fp)
 1088208:	10800017 	ldw	r2,0(r2)
 108820c:	1880111e 	bne	r3,r2,1088254 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 1088210:	00804274 	movhi	r2,265
 1088214:	10a78704 	addi	r2,r2,-25060
 1088218:	e0fffe17 	ldw	r3,-8(fp)
 108821c:	18c00324 	muli	r3,r3,12
 1088220:	10c5883a 	add	r2,r2,r3
 1088224:	10800204 	addi	r2,r2,8
 1088228:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 108822c:	1000090e 	bge	r2,zero,1088254 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 1088230:	e0bffe17 	ldw	r2,-8(fp)
 1088234:	10c00324 	muli	r3,r2,12
 1088238:	00804274 	movhi	r2,265
 108823c:	10a78704 	addi	r2,r2,-25060
 1088240:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 1088244:	e0bfff17 	ldw	r2,-4(fp)
 1088248:	18800226 	beq	r3,r2,1088254 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 108824c:	00bffcc4 	movi	r2,-13
 1088250:	00000a06 	br	108827c <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 1088254:	e0bffe17 	ldw	r2,-8(fp)
 1088258:	10800044 	addi	r2,r2,1
 108825c:	e0bffe15 	stw	r2,-8(fp)
 1088260:	00804274 	movhi	r2,265
 1088264:	10a7ee04 	addi	r2,r2,-24648
 1088268:	10800017 	ldw	r2,0(r2)
 108826c:	1007883a 	mov	r3,r2
 1088270:	e0bffe17 	ldw	r2,-8(fp)
 1088274:	18bfdd2e 	bgeu	r3,r2,10881ec <__alt_data_end+0xfffb2abc>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 1088278:	0005883a 	mov	r2,zero
}
 108827c:	e037883a 	mov	sp,fp
 1088280:	df000017 	ldw	fp,0(sp)
 1088284:	dec00104 	addi	sp,sp,4
 1088288:	f800283a 	ret

0108828c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 108828c:	defff604 	addi	sp,sp,-40
 1088290:	dfc00915 	stw	ra,36(sp)
 1088294:	df000815 	stw	fp,32(sp)
 1088298:	df000804 	addi	fp,sp,32
 108829c:	e13ffd15 	stw	r4,-12(fp)
 10882a0:	e17ffe15 	stw	r5,-8(fp)
 10882a4:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 10882a8:	00bfffc4 	movi	r2,-1
 10882ac:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 10882b0:	00bffb44 	movi	r2,-19
 10882b4:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 10882b8:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 10882bc:	01404274 	movhi	r5,265
 10882c0:	2967ec04 	addi	r5,r5,-24656
 10882c4:	e13ffd17 	ldw	r4,-12(fp)
 10882c8:	10886100 	call	1088610 <alt_find_dev>
 10882cc:	e0bff815 	stw	r2,-32(fp)
 10882d0:	e0bff817 	ldw	r2,-32(fp)
 10882d4:	1000051e 	bne	r2,zero,10882ec <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 10882d8:	e13ffd17 	ldw	r4,-12(fp)
 10882dc:	10886a00 	call	10886a0 <alt_find_file>
 10882e0:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 10882e4:	00800044 	movi	r2,1
 10882e8:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 10882ec:	e0bff817 	ldw	r2,-32(fp)
 10882f0:	10002926 	beq	r2,zero,1088398 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
 10882f4:	e13ff817 	ldw	r4,-32(fp)
 10882f8:	10887b40 	call	10887b4 <alt_get_fd>
 10882fc:	e0bff915 	stw	r2,-28(fp)
 1088300:	e0bff917 	ldw	r2,-28(fp)
 1088304:	1000030e 	bge	r2,zero,1088314 <open+0x88>
    {
      status = index;
 1088308:	e0bff917 	ldw	r2,-28(fp)
 108830c:	e0bffa15 	stw	r2,-24(fp)
 1088310:	00002306 	br	10883a0 <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
 1088314:	e0bff917 	ldw	r2,-28(fp)
 1088318:	10c00324 	muli	r3,r2,12
 108831c:	00804274 	movhi	r2,265
 1088320:	10a78704 	addi	r2,r2,-25060
 1088324:	1885883a 	add	r2,r3,r2
 1088328:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 108832c:	e0fffe17 	ldw	r3,-8(fp)
 1088330:	00900034 	movhi	r2,16384
 1088334:	10bfffc4 	addi	r2,r2,-1
 1088338:	1886703a 	and	r3,r3,r2
 108833c:	e0bffc17 	ldw	r2,-16(fp)
 1088340:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 1088344:	e0bffb17 	ldw	r2,-20(fp)
 1088348:	1000051e 	bne	r2,zero,1088360 <open+0xd4>
 108834c:	e13ffc17 	ldw	r4,-16(fp)
 1088350:	10881c00 	call	10881c0 <alt_file_locked>
 1088354:	e0bffa15 	stw	r2,-24(fp)
 1088358:	e0bffa17 	ldw	r2,-24(fp)
 108835c:	10001016 	blt	r2,zero,10883a0 <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 1088360:	e0bff817 	ldw	r2,-32(fp)
 1088364:	10800317 	ldw	r2,12(r2)
 1088368:	10000826 	beq	r2,zero,108838c <open+0x100>
 108836c:	e0bff817 	ldw	r2,-32(fp)
 1088370:	10800317 	ldw	r2,12(r2)
 1088374:	e1ffff17 	ldw	r7,-4(fp)
 1088378:	e1bffe17 	ldw	r6,-8(fp)
 108837c:	e17ffd17 	ldw	r5,-12(fp)
 1088380:	e13ffc17 	ldw	r4,-16(fp)
 1088384:	103ee83a 	callr	r2
 1088388:	00000106 	br	1088390 <open+0x104>
 108838c:	0005883a 	mov	r2,zero
 1088390:	e0bffa15 	stw	r2,-24(fp)
 1088394:	00000206 	br	10883a0 <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
 1088398:	00bffb44 	movi	r2,-19
 108839c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 10883a0:	e0bffa17 	ldw	r2,-24(fp)
 10883a4:	1000090e 	bge	r2,zero,10883cc <open+0x140>
  {
    alt_release_fd (index);  
 10883a8:	e13ff917 	ldw	r4,-28(fp)
 10883ac:	10883e40 	call	10883e4 <alt_release_fd>
    ALT_ERRNO = -status;
 10883b0:	10881700 	call	1088170 <alt_get_errno>
 10883b4:	1007883a 	mov	r3,r2
 10883b8:	e0bffa17 	ldw	r2,-24(fp)
 10883bc:	0085c83a 	sub	r2,zero,r2
 10883c0:	18800015 	stw	r2,0(r3)
    return -1;
 10883c4:	00bfffc4 	movi	r2,-1
 10883c8:	00000106 	br	10883d0 <open+0x144>
  }
  
  /* return the reference upon success */

  return index;
 10883cc:	e0bff917 	ldw	r2,-28(fp)
}
 10883d0:	e037883a 	mov	sp,fp
 10883d4:	dfc00117 	ldw	ra,4(sp)
 10883d8:	df000017 	ldw	fp,0(sp)
 10883dc:	dec00204 	addi	sp,sp,8
 10883e0:	f800283a 	ret

010883e4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 10883e4:	defffe04 	addi	sp,sp,-8
 10883e8:	df000115 	stw	fp,4(sp)
 10883ec:	df000104 	addi	fp,sp,4
 10883f0:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 10883f4:	e0bfff17 	ldw	r2,-4(fp)
 10883f8:	108000d0 	cmplti	r2,r2,3
 10883fc:	10000d1e 	bne	r2,zero,1088434 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 1088400:	00804274 	movhi	r2,265
 1088404:	10a78704 	addi	r2,r2,-25060
 1088408:	e0ffff17 	ldw	r3,-4(fp)
 108840c:	18c00324 	muli	r3,r3,12
 1088410:	10c5883a 	add	r2,r2,r3
 1088414:	10800204 	addi	r2,r2,8
 1088418:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 108841c:	00804274 	movhi	r2,265
 1088420:	10a78704 	addi	r2,r2,-25060
 1088424:	e0ffff17 	ldw	r3,-4(fp)
 1088428:	18c00324 	muli	r3,r3,12
 108842c:	10c5883a 	add	r2,r2,r3
 1088430:	10000015 	stw	zero,0(r2)
  }
}
 1088434:	0001883a 	nop
 1088438:	e037883a 	mov	sp,fp
 108843c:	df000017 	ldw	fp,0(sp)
 1088440:	dec00104 	addi	sp,sp,4
 1088444:	f800283a 	ret

01088448 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 1088448:	defffa04 	addi	sp,sp,-24
 108844c:	df000515 	stw	fp,20(sp)
 1088450:	df000504 	addi	fp,sp,20
 1088454:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1088458:	0005303a 	rdctl	r2,status
 108845c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1088460:	e0fffc17 	ldw	r3,-16(fp)
 1088464:	00bfff84 	movi	r2,-2
 1088468:	1884703a 	and	r2,r3,r2
 108846c:	1001703a 	wrctl	status,r2
  
  return context;
 1088470:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 1088474:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 1088478:	e0bfff17 	ldw	r2,-4(fp)
 108847c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 1088480:	e0bffd17 	ldw	r2,-12(fp)
 1088484:	10800017 	ldw	r2,0(r2)
 1088488:	e0fffd17 	ldw	r3,-12(fp)
 108848c:	18c00117 	ldw	r3,4(r3)
 1088490:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 1088494:	e0bffd17 	ldw	r2,-12(fp)
 1088498:	10800117 	ldw	r2,4(r2)
 108849c:	e0fffd17 	ldw	r3,-12(fp)
 10884a0:	18c00017 	ldw	r3,0(r3)
 10884a4:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 10884a8:	e0bffd17 	ldw	r2,-12(fp)
 10884ac:	e0fffd17 	ldw	r3,-12(fp)
 10884b0:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 10884b4:	e0bffd17 	ldw	r2,-12(fp)
 10884b8:	e0fffd17 	ldw	r3,-12(fp)
 10884bc:	10c00015 	stw	r3,0(r2)
 10884c0:	e0bffb17 	ldw	r2,-20(fp)
 10884c4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 10884c8:	e0bffe17 	ldw	r2,-8(fp)
 10884cc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 10884d0:	0001883a 	nop
 10884d4:	e037883a 	mov	sp,fp
 10884d8:	df000017 	ldw	fp,0(sp)
 10884dc:	dec00104 	addi	sp,sp,4
 10884e0:	f800283a 	ret

010884e4 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 10884e4:	defffb04 	addi	sp,sp,-20
 10884e8:	dfc00415 	stw	ra,16(sp)
 10884ec:	df000315 	stw	fp,12(sp)
 10884f0:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 10884f4:	d0a00917 	ldw	r2,-32732(gp)
 10884f8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 10884fc:	d0a4eb17 	ldw	r2,-27732(gp)
 1088500:	10800044 	addi	r2,r2,1
 1088504:	d0a4eb15 	stw	r2,-27732(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 1088508:	00002e06 	br	10885c4 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 108850c:	e0bffd17 	ldw	r2,-12(fp)
 1088510:	10800017 	ldw	r2,0(r2)
 1088514:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 1088518:	e0bffd17 	ldw	r2,-12(fp)
 108851c:	10800403 	ldbu	r2,16(r2)
 1088520:	10803fcc 	andi	r2,r2,255
 1088524:	10000426 	beq	r2,zero,1088538 <alt_tick+0x54>
 1088528:	d0a4eb17 	ldw	r2,-27732(gp)
 108852c:	1000021e 	bne	r2,zero,1088538 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 1088530:	e0bffd17 	ldw	r2,-12(fp)
 1088534:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 1088538:	e0bffd17 	ldw	r2,-12(fp)
 108853c:	10800217 	ldw	r2,8(r2)
 1088540:	d0e4eb17 	ldw	r3,-27732(gp)
 1088544:	18801d36 	bltu	r3,r2,10885bc <alt_tick+0xd8>
 1088548:	e0bffd17 	ldw	r2,-12(fp)
 108854c:	10800403 	ldbu	r2,16(r2)
 1088550:	10803fcc 	andi	r2,r2,255
 1088554:	1000191e 	bne	r2,zero,10885bc <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 1088558:	e0bffd17 	ldw	r2,-12(fp)
 108855c:	10800317 	ldw	r2,12(r2)
 1088560:	e0fffd17 	ldw	r3,-12(fp)
 1088564:	18c00517 	ldw	r3,20(r3)
 1088568:	1809883a 	mov	r4,r3
 108856c:	103ee83a 	callr	r2
 1088570:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 1088574:	e0bfff17 	ldw	r2,-4(fp)
 1088578:	1000031e 	bne	r2,zero,1088588 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 108857c:	e13ffd17 	ldw	r4,-12(fp)
 1088580:	10884480 	call	1088448 <alt_alarm_stop>
 1088584:	00000d06 	br	10885bc <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 1088588:	e0bffd17 	ldw	r2,-12(fp)
 108858c:	10c00217 	ldw	r3,8(r2)
 1088590:	e0bfff17 	ldw	r2,-4(fp)
 1088594:	1887883a 	add	r3,r3,r2
 1088598:	e0bffd17 	ldw	r2,-12(fp)
 108859c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 10885a0:	e0bffd17 	ldw	r2,-12(fp)
 10885a4:	10c00217 	ldw	r3,8(r2)
 10885a8:	d0a4eb17 	ldw	r2,-27732(gp)
 10885ac:	1880032e 	bgeu	r3,r2,10885bc <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 10885b0:	e0bffd17 	ldw	r2,-12(fp)
 10885b4:	00c00044 	movi	r3,1
 10885b8:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 10885bc:	e0bffe17 	ldw	r2,-8(fp)
 10885c0:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 10885c4:	e0fffd17 	ldw	r3,-12(fp)
 10885c8:	d0a00904 	addi	r2,gp,-32732
 10885cc:	18bfcf1e 	bne	r3,r2,108850c <__alt_data_end+0xfffb2ddc>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 10885d0:	0001883a 	nop
}
 10885d4:	0001883a 	nop
 10885d8:	e037883a 	mov	sp,fp
 10885dc:	dfc00117 	ldw	ra,4(sp)
 10885e0:	df000017 	ldw	fp,0(sp)
 10885e4:	dec00204 	addi	sp,sp,8
 10885e8:	f800283a 	ret

010885ec <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 10885ec:	deffff04 	addi	sp,sp,-4
 10885f0:	df000015 	stw	fp,0(sp)
 10885f4:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 10885f8:	000170fa 	wrctl	ienable,zero
}
 10885fc:	0001883a 	nop
 1088600:	e037883a 	mov	sp,fp
 1088604:	df000017 	ldw	fp,0(sp)
 1088608:	dec00104 	addi	sp,sp,4
 108860c:	f800283a 	ret

01088610 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 1088610:	defffa04 	addi	sp,sp,-24
 1088614:	dfc00515 	stw	ra,20(sp)
 1088618:	df000415 	stw	fp,16(sp)
 108861c:	df000404 	addi	fp,sp,16
 1088620:	e13ffe15 	stw	r4,-8(fp)
 1088624:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 1088628:	e0bfff17 	ldw	r2,-4(fp)
 108862c:	10800017 	ldw	r2,0(r2)
 1088630:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 1088634:	e13ffe17 	ldw	r4,-8(fp)
 1088638:	10864180 	call	1086418 <strlen>
 108863c:	10800044 	addi	r2,r2,1
 1088640:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 1088644:	00000d06 	br	108867c <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 1088648:	e0bffc17 	ldw	r2,-16(fp)
 108864c:	10800217 	ldw	r2,8(r2)
 1088650:	e0fffd17 	ldw	r3,-12(fp)
 1088654:	180d883a 	mov	r6,r3
 1088658:	e17ffe17 	ldw	r5,-8(fp)
 108865c:	1009883a 	mov	r4,r2
 1088660:	10889700 	call	1088970 <memcmp>
 1088664:	1000021e 	bne	r2,zero,1088670 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 1088668:	e0bffc17 	ldw	r2,-16(fp)
 108866c:	00000706 	br	108868c <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 1088670:	e0bffc17 	ldw	r2,-16(fp)
 1088674:	10800017 	ldw	r2,0(r2)
 1088678:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 108867c:	e0fffc17 	ldw	r3,-16(fp)
 1088680:	e0bfff17 	ldw	r2,-4(fp)
 1088684:	18bff01e 	bne	r3,r2,1088648 <__alt_data_end+0xfffb2f18>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 1088688:	0005883a 	mov	r2,zero
}
 108868c:	e037883a 	mov	sp,fp
 1088690:	dfc00117 	ldw	ra,4(sp)
 1088694:	df000017 	ldw	fp,0(sp)
 1088698:	dec00204 	addi	sp,sp,8
 108869c:	f800283a 	ret

010886a0 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 10886a0:	defffb04 	addi	sp,sp,-20
 10886a4:	dfc00415 	stw	ra,16(sp)
 10886a8:	df000315 	stw	fp,12(sp)
 10886ac:	df000304 	addi	fp,sp,12
 10886b0:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 10886b4:	00804274 	movhi	r2,265
 10886b8:	10a7ea04 	addi	r2,r2,-24664
 10886bc:	10800017 	ldw	r2,0(r2)
 10886c0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 10886c4:	00003106 	br	108878c <alt_find_file+0xec>
  {
    len = strlen(next->name);
 10886c8:	e0bffd17 	ldw	r2,-12(fp)
 10886cc:	10800217 	ldw	r2,8(r2)
 10886d0:	1009883a 	mov	r4,r2
 10886d4:	10864180 	call	1086418 <strlen>
 10886d8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 10886dc:	e0bffd17 	ldw	r2,-12(fp)
 10886e0:	10c00217 	ldw	r3,8(r2)
 10886e4:	e0bffe17 	ldw	r2,-8(fp)
 10886e8:	10bfffc4 	addi	r2,r2,-1
 10886ec:	1885883a 	add	r2,r3,r2
 10886f0:	10800003 	ldbu	r2,0(r2)
 10886f4:	10803fcc 	andi	r2,r2,255
 10886f8:	1080201c 	xori	r2,r2,128
 10886fc:	10bfe004 	addi	r2,r2,-128
 1088700:	10800bd8 	cmpnei	r2,r2,47
 1088704:	1000031e 	bne	r2,zero,1088714 <alt_find_file+0x74>
    {
      len -= 1;
 1088708:	e0bffe17 	ldw	r2,-8(fp)
 108870c:	10bfffc4 	addi	r2,r2,-1
 1088710:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 1088714:	e0bffe17 	ldw	r2,-8(fp)
 1088718:	e0ffff17 	ldw	r3,-4(fp)
 108871c:	1885883a 	add	r2,r3,r2
 1088720:	10800003 	ldbu	r2,0(r2)
 1088724:	10803fcc 	andi	r2,r2,255
 1088728:	1080201c 	xori	r2,r2,128
 108872c:	10bfe004 	addi	r2,r2,-128
 1088730:	10800be0 	cmpeqi	r2,r2,47
 1088734:	1000081e 	bne	r2,zero,1088758 <alt_find_file+0xb8>
 1088738:	e0bffe17 	ldw	r2,-8(fp)
 108873c:	e0ffff17 	ldw	r3,-4(fp)
 1088740:	1885883a 	add	r2,r3,r2
 1088744:	10800003 	ldbu	r2,0(r2)
 1088748:	10803fcc 	andi	r2,r2,255
 108874c:	1080201c 	xori	r2,r2,128
 1088750:	10bfe004 	addi	r2,r2,-128
 1088754:	10000a1e 	bne	r2,zero,1088780 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
 1088758:	e0bffd17 	ldw	r2,-12(fp)
 108875c:	10800217 	ldw	r2,8(r2)
 1088760:	e0fffe17 	ldw	r3,-8(fp)
 1088764:	180d883a 	mov	r6,r3
 1088768:	e17fff17 	ldw	r5,-4(fp)
 108876c:	1009883a 	mov	r4,r2
 1088770:	10889700 	call	1088970 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 1088774:	1000021e 	bne	r2,zero,1088780 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 1088778:	e0bffd17 	ldw	r2,-12(fp)
 108877c:	00000806 	br	10887a0 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
 1088780:	e0bffd17 	ldw	r2,-12(fp)
 1088784:	10800017 	ldw	r2,0(r2)
 1088788:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 108878c:	e0fffd17 	ldw	r3,-12(fp)
 1088790:	00804274 	movhi	r2,265
 1088794:	10a7ea04 	addi	r2,r2,-24664
 1088798:	18bfcb1e 	bne	r3,r2,10886c8 <__alt_data_end+0xfffb2f98>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 108879c:	0005883a 	mov	r2,zero
}
 10887a0:	e037883a 	mov	sp,fp
 10887a4:	dfc00117 	ldw	ra,4(sp)
 10887a8:	df000017 	ldw	fp,0(sp)
 10887ac:	dec00204 	addi	sp,sp,8
 10887b0:	f800283a 	ret

010887b4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 10887b4:	defffc04 	addi	sp,sp,-16
 10887b8:	df000315 	stw	fp,12(sp)
 10887bc:	df000304 	addi	fp,sp,12
 10887c0:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 10887c4:	00bffa04 	movi	r2,-24
 10887c8:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 10887cc:	e03ffd15 	stw	zero,-12(fp)
 10887d0:	00001d06 	br	1088848 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
 10887d4:	00804274 	movhi	r2,265
 10887d8:	10a78704 	addi	r2,r2,-25060
 10887dc:	e0fffd17 	ldw	r3,-12(fp)
 10887e0:	18c00324 	muli	r3,r3,12
 10887e4:	10c5883a 	add	r2,r2,r3
 10887e8:	10800017 	ldw	r2,0(r2)
 10887ec:	1000131e 	bne	r2,zero,108883c <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
 10887f0:	00804274 	movhi	r2,265
 10887f4:	10a78704 	addi	r2,r2,-25060
 10887f8:	e0fffd17 	ldw	r3,-12(fp)
 10887fc:	18c00324 	muli	r3,r3,12
 1088800:	10c5883a 	add	r2,r2,r3
 1088804:	e0ffff17 	ldw	r3,-4(fp)
 1088808:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 108880c:	00804274 	movhi	r2,265
 1088810:	10a7ee04 	addi	r2,r2,-24648
 1088814:	10c00017 	ldw	r3,0(r2)
 1088818:	e0bffd17 	ldw	r2,-12(fp)
 108881c:	1880040e 	bge	r3,r2,1088830 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
 1088820:	00804274 	movhi	r2,265
 1088824:	10a7ee04 	addi	r2,r2,-24648
 1088828:	e0fffd17 	ldw	r3,-12(fp)
 108882c:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
 1088830:	e0bffd17 	ldw	r2,-12(fp)
 1088834:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
 1088838:	00000606 	br	1088854 <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 108883c:	e0bffd17 	ldw	r2,-12(fp)
 1088840:	10800044 	addi	r2,r2,1
 1088844:	e0bffd15 	stw	r2,-12(fp)
 1088848:	e0bffd17 	ldw	r2,-12(fp)
 108884c:	10800810 	cmplti	r2,r2,32
 1088850:	103fe01e 	bne	r2,zero,10887d4 <__alt_data_end+0xfffb30a4>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 1088854:	e0bffe17 	ldw	r2,-8(fp)
}
 1088858:	e037883a 	mov	sp,fp
 108885c:	df000017 	ldw	fp,0(sp)
 1088860:	dec00104 	addi	sp,sp,4
 1088864:	f800283a 	ret

01088868 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 1088868:	defffb04 	addi	sp,sp,-20
 108886c:	df000415 	stw	fp,16(sp)
 1088870:	df000404 	addi	fp,sp,16
 1088874:	e13ffe15 	stw	r4,-8(fp)
 1088878:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 108887c:	e0bfff17 	ldw	r2,-4(fp)
 1088880:	10840070 	cmpltui	r2,r2,4097
 1088884:	1000021e 	bne	r2,zero,1088890 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 1088888:	00840004 	movi	r2,4096
 108888c:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 1088890:	e0fffe17 	ldw	r3,-8(fp)
 1088894:	e0bfff17 	ldw	r2,-4(fp)
 1088898:	1885883a 	add	r2,r3,r2
 108889c:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 10888a0:	e0bffe17 	ldw	r2,-8(fp)
 10888a4:	e0bffc15 	stw	r2,-16(fp)
 10888a8:	00000506 	br	10888c0 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 10888ac:	e0bffc17 	ldw	r2,-16(fp)
 10888b0:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 10888b4:	e0bffc17 	ldw	r2,-16(fp)
 10888b8:	10800804 	addi	r2,r2,32
 10888bc:	e0bffc15 	stw	r2,-16(fp)
 10888c0:	e0fffc17 	ldw	r3,-16(fp)
 10888c4:	e0bffd17 	ldw	r2,-12(fp)
 10888c8:	18bff836 	bltu	r3,r2,10888ac <__alt_data_end+0xfffb317c>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 10888cc:	e0bffe17 	ldw	r2,-8(fp)
 10888d0:	108007cc 	andi	r2,r2,31
 10888d4:	10000226 	beq	r2,zero,10888e0 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 10888d8:	e0bffc17 	ldw	r2,-16(fp)
 10888dc:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 10888e0:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 10888e4:	0001883a 	nop
 10888e8:	e037883a 	mov	sp,fp
 10888ec:	df000017 	ldw	fp,0(sp)
 10888f0:	dec00104 	addi	sp,sp,4
 10888f4:	f800283a 	ret

010888f8 <exit>:
 10888f8:	defffe04 	addi	sp,sp,-8
 10888fc:	000b883a 	mov	r5,zero
 1088900:	dc000015 	stw	r16,0(sp)
 1088904:	dfc00115 	stw	ra,4(sp)
 1088908:	2021883a 	mov	r16,r4
 108890c:	10889a00 	call	10889a0 <__call_exitprocs>
 1088910:	8009883a 	mov	r4,r16
 1088914:	1088b300 	call	1088b30 <_exit>

01088918 <fputs>:
 1088918:	defffd04 	addi	sp,sp,-12
 108891c:	dfc00215 	stw	ra,8(sp)
 1088920:	dc000115 	stw	r16,4(sp)
 1088924:	d9400015 	stw	r5,0(sp)
 1088928:	2021883a 	mov	r16,r4
 108892c:	10864180 	call	1086418 <strlen>
 1088930:	100f883a 	mov	r7,r2
 1088934:	00804274 	movhi	r2,265
 1088938:	d9400017 	ldw	r5,0(sp)
 108893c:	10a7e804 	addi	r2,r2,-24672
 1088940:	11000017 	ldw	r4,0(r2)
 1088944:	00c04234 	movhi	r3,264
 1088948:	18d92b04 	addi	r3,r3,25772
 108894c:	28c00115 	stw	r3,4(r5)
 1088950:	800d883a 	mov	r6,r16
 1088954:	10864ac0 	call	10864ac <__sfvwrite_small_dev>
 1088958:	10bfffe0 	cmpeqi	r2,r2,-1
 108895c:	0085c83a 	sub	r2,zero,r2
 1088960:	dfc00217 	ldw	ra,8(sp)
 1088964:	dc000117 	ldw	r16,4(sp)
 1088968:	dec00304 	addi	sp,sp,12
 108896c:	f800283a 	ret

01088970 <memcmp>:
 1088970:	218d883a 	add	r6,r4,r6
 1088974:	21800826 	beq	r4,r6,1088998 <memcmp+0x28>
 1088978:	20800003 	ldbu	r2,0(r4)
 108897c:	28c00003 	ldbu	r3,0(r5)
 1088980:	10c00226 	beq	r2,r3,108898c <memcmp+0x1c>
 1088984:	10c5c83a 	sub	r2,r2,r3
 1088988:	f800283a 	ret
 108898c:	21000044 	addi	r4,r4,1
 1088990:	29400044 	addi	r5,r5,1
 1088994:	003ff706 	br	1088974 <__alt_data_end+0xfffb3244>
 1088998:	0005883a 	mov	r2,zero
 108899c:	f800283a 	ret

010889a0 <__call_exitprocs>:
 10889a0:	defff504 	addi	sp,sp,-44
 10889a4:	dd000515 	stw	r20,20(sp)
 10889a8:	05004274 	movhi	r20,265
 10889ac:	dc800315 	stw	r18,12(sp)
 10889b0:	dfc00a15 	stw	ra,40(sp)
 10889b4:	df000915 	stw	fp,36(sp)
 10889b8:	ddc00815 	stw	r23,32(sp)
 10889bc:	dd800715 	stw	r22,28(sp)
 10889c0:	dd400615 	stw	r21,24(sp)
 10889c4:	dcc00415 	stw	r19,16(sp)
 10889c8:	dc400215 	stw	r17,8(sp)
 10889cc:	dc000115 	stw	r16,4(sp)
 10889d0:	d9000015 	stw	r4,0(sp)
 10889d4:	2825883a 	mov	r18,r5
 10889d8:	a527e704 	addi	r20,r20,-24676
 10889dc:	a4400017 	ldw	r17,0(r20)
 10889e0:	8cc00c17 	ldw	r19,48(r17)
 10889e4:	8c400c04 	addi	r17,r17,48
 10889e8:	98004526 	beq	r19,zero,1088b00 <__call_exitprocs+0x160>
 10889ec:	9c000117 	ldw	r16,4(r19)
 10889f0:	00900034 	movhi	r2,16384
 10889f4:	10bfffc4 	addi	r2,r2,-1
 10889f8:	9d402217 	ldw	r21,136(r19)
 10889fc:	85bfffc4 	addi	r22,r16,-1
 1088a00:	80a1883a 	add	r16,r16,r2
 1088a04:	8421883a 	add	r16,r16,r16
 1088a08:	8421883a 	add	r16,r16,r16
 1088a0c:	ac2f883a 	add	r23,r21,r16
 1088a10:	84000204 	addi	r16,r16,8
 1088a14:	9c21883a 	add	r16,r19,r16
 1088a18:	b0002716 	blt	r22,zero,1088ab8 <__call_exitprocs+0x118>
 1088a1c:	90000726 	beq	r18,zero,1088a3c <__call_exitprocs+0x9c>
 1088a20:	a800041e 	bne	r21,zero,1088a34 <__call_exitprocs+0x94>
 1088a24:	b5bfffc4 	addi	r22,r22,-1
 1088a28:	bdffff04 	addi	r23,r23,-4
 1088a2c:	843fff04 	addi	r16,r16,-4
 1088a30:	003ff906 	br	1088a18 <__alt_data_end+0xfffb32e8>
 1088a34:	b9002017 	ldw	r4,128(r23)
 1088a38:	913ffa1e 	bne	r18,r4,1088a24 <__alt_data_end+0xfffb32f4>
 1088a3c:	99000117 	ldw	r4,4(r19)
 1088a40:	82000017 	ldw	r8,0(r16)
 1088a44:	213fffc4 	addi	r4,r4,-1
 1088a48:	b100021e 	bne	r22,r4,1088a54 <__call_exitprocs+0xb4>
 1088a4c:	9d800115 	stw	r22,4(r19)
 1088a50:	00000106 	br	1088a58 <__call_exitprocs+0xb8>
 1088a54:	80000015 	stw	zero,0(r16)
 1088a58:	403ff226 	beq	r8,zero,1088a24 <__alt_data_end+0xfffb32f4>
 1088a5c:	9f000117 	ldw	fp,4(r19)
 1088a60:	a8000526 	beq	r21,zero,1088a78 <__call_exitprocs+0xd8>
 1088a64:	00800044 	movi	r2,1
 1088a68:	1592983a 	sll	r9,r2,r22
 1088a6c:	a9404017 	ldw	r5,256(r21)
 1088a70:	494a703a 	and	r5,r9,r5
 1088a74:	2800021e 	bne	r5,zero,1088a80 <__call_exitprocs+0xe0>
 1088a78:	403ee83a 	callr	r8
 1088a7c:	00000906 	br	1088aa4 <__call_exitprocs+0x104>
 1088a80:	a9004117 	ldw	r4,260(r21)
 1088a84:	4908703a 	and	r4,r9,r4
 1088a88:	2000041e 	bne	r4,zero,1088a9c <__call_exitprocs+0xfc>
 1088a8c:	b9400017 	ldw	r5,0(r23)
 1088a90:	d9000017 	ldw	r4,0(sp)
 1088a94:	403ee83a 	callr	r8
 1088a98:	00000206 	br	1088aa4 <__call_exitprocs+0x104>
 1088a9c:	b9000017 	ldw	r4,0(r23)
 1088aa0:	403ee83a 	callr	r8
 1088aa4:	99000117 	ldw	r4,4(r19)
 1088aa8:	e13fcc1e 	bne	fp,r4,10889dc <__alt_data_end+0xfffb32ac>
 1088aac:	89000017 	ldw	r4,0(r17)
 1088ab0:	993fdc26 	beq	r19,r4,1088a24 <__alt_data_end+0xfffb32f4>
 1088ab4:	003fc906 	br	10889dc <__alt_data_end+0xfffb32ac>
 1088ab8:	00800034 	movhi	r2,0
 1088abc:	10800004 	addi	r2,r2,0
 1088ac0:	10000f26 	beq	r2,zero,1088b00 <__call_exitprocs+0x160>
 1088ac4:	99400117 	ldw	r5,4(r19)
 1088ac8:	99000017 	ldw	r4,0(r19)
 1088acc:	2800091e 	bne	r5,zero,1088af4 <__call_exitprocs+0x154>
 1088ad0:	20000826 	beq	r4,zero,1088af4 <__call_exitprocs+0x154>
 1088ad4:	89000015 	stw	r4,0(r17)
 1088ad8:	a8000226 	beq	r21,zero,1088ae4 <__call_exitprocs+0x144>
 1088adc:	a809883a 	mov	r4,r21
 1088ae0:	00000000 	call	0 <__alt_mem_sdram-0x800000>
 1088ae4:	9809883a 	mov	r4,r19
 1088ae8:	00000000 	call	0 <__alt_mem_sdram-0x800000>
 1088aec:	8cc00017 	ldw	r19,0(r17)
 1088af0:	003fbd06 	br	10889e8 <__alt_data_end+0xfffb32b8>
 1088af4:	9823883a 	mov	r17,r19
 1088af8:	2027883a 	mov	r19,r4
 1088afc:	003fba06 	br	10889e8 <__alt_data_end+0xfffb32b8>
 1088b00:	dfc00a17 	ldw	ra,40(sp)
 1088b04:	df000917 	ldw	fp,36(sp)
 1088b08:	ddc00817 	ldw	r23,32(sp)
 1088b0c:	dd800717 	ldw	r22,28(sp)
 1088b10:	dd400617 	ldw	r21,24(sp)
 1088b14:	dd000517 	ldw	r20,20(sp)
 1088b18:	dcc00417 	ldw	r19,16(sp)
 1088b1c:	dc800317 	ldw	r18,12(sp)
 1088b20:	dc400217 	ldw	r17,8(sp)
 1088b24:	dc000117 	ldw	r16,4(sp)
 1088b28:	dec00b04 	addi	sp,sp,44
 1088b2c:	f800283a 	ret

01088b30 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 1088b30:	defffd04 	addi	sp,sp,-12
 1088b34:	df000215 	stw	fp,8(sp)
 1088b38:	df000204 	addi	fp,sp,8
 1088b3c:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 1088b40:	0001883a 	nop
 1088b44:	e0bfff17 	ldw	r2,-4(fp)
 1088b48:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 1088b4c:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 1088b50:	10000226 	beq	r2,zero,1088b5c <_exit+0x2c>
    ALT_SIM_FAIL();
 1088b54:	002af070 	cmpltui	zero,zero,43969
 1088b58:	00000106 	br	1088b60 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 1088b5c:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 1088b60:	003fff06 	br	1088b60 <__alt_data_end+0xfffb3430>
